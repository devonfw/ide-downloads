[ {
  "versionRange" : "[3.1.4,3.1.4]",
  "severity" : 5.0,
  "cveName" : "CVE-2012-0845",
  "description" : "SimpleXMLRPCServer.py in SimpleXMLRPCServer in Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 allows remote attackers to cause a denial of service (infinite loop and CPU consumption) via an XML-RPC POST request that contains a smaller amount of data than specified by the Content-Length header.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-0845"
}, {
  "versionRange" : "[2.7.0,2.7.17)",
  "severity" : 6.1,
  "cveName" : "CVE-2019-9947",
  "description" : "An issue was discovered in urllib2 in Python 2.x through 2.7.16 and urllib in Python 3.x through 3.7.3. CRLF injection is possible if the attacker controls a url parameter, as demonstrated by the first argument to urllib.request.urlopen with \\r\\n (specifically in the path component of a URL that lacks a ? character) followed by an HTTP header or a Redis command. This is similar to the CVE-2019-9740 query string issue. This is fixed in: v2.7.17, v2.7.17rc1, v2.7.18, v2.7.18rc1; v3.5.10, v3.5.10rc1, v3.5.8, v3.5.8rc1, v3.5.8rc2, v3.5.9; v3.6.10, v3.6.10rc1, v3.6.11, v3.6.11rc1, v3.6.12, v3.6.9, v3.6.9rc1; v3.7.4, v3.7.4rc1, v3.7.4rc2, v3.7.5, v3.7.5rc1, v3.7.6, v3.7.6rc1, v3.7.7, v3.7.7rc1, v3.7.8, v3.7.8rc1, v3.7.9.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2019-9947"
}, {
  "versionRange" : "[2.7.13,2.7.13]",
  "severity" : 7.8,
  "cveName" : "CVE-2017-20052",
  "description" : "A vulnerability classified as problematic was found in Python 2.7.13. This vulnerability affects unknown code of the component pgAdmin4. The manipulation leads to uncontrolled search path. The attack can be initiated remotely. The exploit has been disclosed to the public and may be used.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2017-20052"
}, {
  "versionRange" : "[2.5.0,2.5.3)",
  "severity" : 7.5,
  "cveName" : "CVE-2008-3142",
  "description" : "Multiple buffer overflows in Python 2.5.2 and earlier on 32bit platforms allow context-dependent attackers to cause a denial of service (crash) or have unspecified other impact via a long string that leads to incorrect memory allocation during Unicode string processing, related to the unicode_resize function and the PyMem_RESIZE macro.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2008-3142"
}, {
  "versionRange" : "[3.7.0,3.7.10)",
  "severity" : 5.9,
  "cveName" : "CVE-2021-23336",
  "description" : "The package python/cpython from 0 and before 3.6.13, from 3.7.0 and before 3.7.10, from 3.8.0 and before 3.8.8, from 3.9.0 and before 3.9.2 are vulnerable to Web Cache Poisoning via urllib.parse.parse_qsl and urllib.parse.parse_qs by using a vector called parameter cloaking. When the attacker can separate query parameters using a semicolon (;), they can cause a difference in the interpretation of the request between the proxy (running with default configuration) and the server. This can result in malicious requests being cached as completely safe ones, as the proxy would usually not see the semicolon as a separator, and therefore would not include it in a cache key of an unkeyed parameter.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2021-23336"
}, {
  "versionRange" : "[2.5.2,2.5.2]",
  "severity" : 7.5,
  "cveName" : "CVE-2014-1912",
  "description" : "Buffer overflow in the socket.recvfrom_into function in Modules/socketmodule.c in Python 2.5 before 2.7.7, 3.x before 3.3.4, and 3.4.x before 3.4rc1 allows remote attackers to execute arbitrary code via a crafted string.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-1912"
}, {
  "versionRange" : "[2.7.5,2.7.5]",
  "severity" : 4.3,
  "cveName" : "CVE-2013-7040",
  "description" : "Python 2.7 before 3.4 only uses the last eight bits of the prefix to randomize hash values, which causes it to compute hash values without restricting the ability to trigger hash collisions predictably and makes it easier for context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2012-1150.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-7040"
}, {
  "versionRange" : "[3.10.0,3.10.13)",
  "severity" : 5.3,
  "cveName" : "CVE-2023-40217",
  "description" : "An issue was discovered in Python before 3.8.18, 3.9.x before 3.9.18, 3.10.x before 3.10.13, and 3.11.x before 3.11.5. It primarily affects servers (such as HTTP servers) that use TLS client authentication. If a TLS server-side socket is created, receives data into the socket buffer, and then is closed quickly, there is a brief window where the SSLSocket instance will detect the socket as \"not connected\" and won't initiate a handshake, but buffered data will still be readable from the socket buffer. This data will not be authenticated if the server-side TLS peer is expecting client certificate authentication, and is indistinguishable from valid TLS stream data. Data is limited in size to the amount that will fit in the buffer. (The TLS connection cannot directly be used for data exfiltration because the vulnerable code path requires that the connection be closed on initialization of the SSLSocket.)",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2023-40217"
}, {
  "versionRange" : "[2.7.3,2.7.3]",
  "severity" : 7.5,
  "cveName" : "CVE-2014-1912",
  "description" : "Buffer overflow in the socket.recvfrom_into function in Modules/socketmodule.c in Python 2.5 before 2.7.7, 3.x before 3.3.4, and 3.4.x before 3.4rc1 allows remote attackers to execute arbitrary code via a crafted string.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-1912"
}, {
  "versionRange" : "[3.1.4,3.1.4]",
  "severity" : 5.0,
  "cveName" : "CVE-2012-1150",
  "description" : "Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 computes hash values without restricting the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-1150"
}, {
  "versionRange" : "[2.6.5,2.6.5]",
  "severity" : 2.6,
  "cveName" : "CVE-2011-4940",
  "description" : "The list_directory function in Lib/SimpleHTTPServer.py in SimpleHTTPServer in Python before 2.5.6c1, 2.6.x before 2.6.7 rc2, and 2.7.x before 2.7.2 does not place a charset parameter in the Content-Type HTTP header, which makes it easier for remote attackers to conduct cross-site scripting (XSS) attacks against Internet Explorer 7 via UTF-7 encoding.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-4940"
}, {
  "versionRange" : "[3.5.0,3.5.0]",
  "severity" : 9.8,
  "cveName" : "CVE-2016-5636",
  "description" : "Integer overflow in the get_data function in zipimport.c in CPython (aka Python) before 2.7.12, 3.x before 3.4.5, and 3.5.x before 3.5.2 allows remote attackers to have unspecified impact via a negative data size value, which triggers a heap-based buffer overflow.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-5636"
}, {
  "versionRange" : "[2.1.1,2.1.1]",
  "severity" : 2.6,
  "cveName" : "CVE-2011-4940",
  "description" : "The list_directory function in Lib/SimpleHTTPServer.py in SimpleHTTPServer in Python before 2.5.6c1, 2.6.x before 2.6.7 rc2, and 2.7.x before 2.7.2 does not place a charset parameter in the Content-Type HTTP header, which makes it easier for remote attackers to conduct cross-site scripting (XSS) attacks against Internet Explorer 7 via UTF-7 encoding.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-4940"
}, {
  "versionRange" : "[3.6.0,3.6.9)",
  "severity" : 7.5,
  "cveName" : "CVE-2019-5010",
  "description" : "An exploitable denial-of-service vulnerability exists in the X509 certificate parser of Python.org Python 2.7.11 / 3.6.6. A specially crafted X509 certificate can cause a NULL pointer dereference, resulting in a denial of service. An attacker can initiate or accept TLS connections using crafted certificates to trigger this vulnerability.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2019-5010"
}, {
  "versionRange" : "[3.3.4,3.3.4]",
  "severity" : 6.1,
  "cveName" : "CVE-2016-5699",
  "description" : "CRLF injection vulnerability in the HTTPConnection.putheader function in urllib2 and urllib in CPython (aka Python) before 2.7.10 and 3.x before 3.4.4 allows remote attackers to inject arbitrary HTTP headers via CRLF sequences in a URL.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-5699"
}, {
  "versionRange" : "[2.7.3,2.7.3]",
  "severity" : 6.4,
  "cveName" : "CVE-2014-7185",
  "description" : "Integer overflow in bufferobject.c in Python before 2.7.8 allows context-dependent attackers to obtain sensitive information from process memory via a large size and offset in a \"buffer\" function.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-7185"
}, {
  "versionRange" : "[2.7.6,2.7.6]",
  "severity" : 4.3,
  "cveName" : "CVE-2013-7040",
  "description" : "Python 2.7 before 3.4 only uses the last eight bits of the prefix to randomize hash values, which causes it to compute hash values without restricting the ability to trigger hash collisions predictably and makes it easier for context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2012-1150.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-7040"
}, {
  "versionRange" : "(,3.11.4]",
  "severity" : 7.5,
  "cveName" : "CVE-2023-36632",
  "description" : "The legacy email.utils.parseaddr function in Python through 3.11.4 allows attackers to trigger \"RecursionError: maximum recursion depth exceeded while calling a Python object\" via a crafted argument. This argument is plausibly an untrusted value from an application's input data that was supposed to contain a name and an e-mail address. NOTE: email.utils.parseaddr is categorized as a Legacy API in the documentation of the Python email package. Applications should instead use the email.parser.BytesParser or email.parser.Parser class. NOTE: the vendor's perspective is that this is neither a vulnerability nor a bug. The email package is intended to have size limits and to throw an exception when limits are exceeded; they were exceeded by the example demonstration code.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2023-36632"
}, {
  "versionRange" : "[2.3.7,2.3.7]",
  "severity" : 10.0,
  "cveName" : "CVE-2008-5031",
  "description" : "Multiple integer overflows in Python 2.2.3 through 2.5.1, and 2.6, allow context-dependent attackers to have an unknown impact via a large integer value in the tabsize argument to the expandtabs method, as implemented by (1) the string_expandtabs function in Objects/stringobject.c and (2) the unicode_expandtabs function in Objects/unicodeobject.c.  NOTE: this vulnerability reportedly exists because of an incomplete fix for CVE-2008-2315.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2008-5031"
}, {
  "versionRange" : "[2.5.2,2.5.2]",
  "severity" : 6.4,
  "cveName" : "CVE-2011-1521",
  "description" : "The urllib and urllib2 modules in Python 2.x before 2.7.2 and 3.x before 3.2.1 process Location headers that specify redirection to file: URLs, which makes it easier for remote attackers to obtain sensitive information or cause a denial of service (resource consumption) via a crafted URL, as demonstrated by the file:///etc/passwd and file:///dev/zero URLs.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-1521"
}, {
  "versionRange" : "[3.0.0,3.7.14)",
  "severity" : 7.4,
  "cveName" : "CVE-2021-28861",
  "description" : "Python 3.x through 3.10 has an open redirection vulnerability in lib/http/server.py due to no protection against multiple (/) at the beginning of URI path which may leads to information disclosure. NOTE: this is disputed by a third party because the http.server.html documentation page states \"Warning: http.server is not recommended for production. It only implements basic security checks.\"",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2021-28861"
}, {
  "versionRange" : "[3.4.0,3.4.7)",
  "severity" : 8.1,
  "cveName" : "CVE-2016-4472",
  "description" : "The overflow protection in Expat is removed by compilers with certain optimization settings, which allows remote attackers to cause a denial of service (crash) or possibly execute arbitrary code via crafted XML data.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2015-1283 and CVE-2015-2716.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-4472"
}, {
  "versionRange" : "[2.5.6,2.5.6]",
  "severity" : 7.5,
  "cveName" : "CVE-2014-1912",
  "description" : "Buffer overflow in the socket.recvfrom_into function in Modules/socketmodule.c in Python 2.5 before 2.7.7, 3.x before 3.3.4, and 3.4.x before 3.4rc1 allows remote attackers to execute arbitrary code via a crafted string.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-1912"
}, {
  "versionRange" : "[3.2.0,3.2.6)",
  "severity" : 7.5,
  "cveName" : "CVE-2013-1753",
  "description" : "The gzip_decode function in the xmlrpc client library in Python 3.4 and earlier allows remote attackers to cause a denial of service (memory consumption) via a crafted HTTP request.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-1753"
}, {
  "versionRange" : "[3.3.2,3.3.2]",
  "severity" : 6.5,
  "cveName" : "CVE-2016-0772",
  "description" : "The smtplib library in CPython (aka Python) before 2.7.12, 3.x before 3.4.5, and 3.5.x before 3.5.2 does not return an error when StartTLS fails, which might allow man-in-the-middle attackers to bypass the TLS protections by leveraging a network position between the client and the registry to block the StartTLS command, aka a \"StartTLS stripping attack.\"",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-0772"
}, {
  "versionRange" : "[2.6.8,2.6.8]",
  "severity" : 4.3,
  "cveName" : "CVE-2013-4238",
  "description" : "The ssl.match_hostname function in the SSL module in Python 2.6 through 3.4 does not properly handle a '\\0' character in a domain name in the Subject Alternative Name field of an X.509 certificate, which allows man-in-the-middle attackers to spoof arbitrary SSL servers via a crafted certificate issued by a legitimate Certification Authority, a related issue to CVE-2009-2408.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-4238"
}, {
  "versionRange" : "[3.5.0,3.5.0]",
  "severity" : 6.5,
  "cveName" : "CVE-2016-0772",
  "description" : "The smtplib library in CPython (aka Python) before 2.7.12, 3.x before 3.4.5, and 3.5.x before 3.5.2 does not return an error when StartTLS fails, which might allow man-in-the-middle attackers to bypass the TLS protections by leveraging a network position between the client and the registry to block the StartTLS command, aka a \"StartTLS stripping attack.\"",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-0772"
}, {
  "versionRange" : "[3.6.0,3.6.14)",
  "severity" : 7.5,
  "cveName" : "CVE-2021-3737",
  "description" : "A flaw was found in python. An improperly handled HTTP response in the HTTP client code of python may allow a remote attacker, who controls the HTTP server, to make the client script enter an infinite loop, consuming CPU time. The highest threat from this vulnerability is to system availability.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2021-3737"
}, {
  "versionRange" : "[3.4.0,3.4.10]",
  "severity" : 7.5,
  "cveName" : "CVE-2019-16056",
  "description" : "An issue was discovered in Python through 2.7.16, 3.x through 3.5.7, 3.6.x through 3.6.9, and 3.7.x through 3.7.4. The email module wrongly parses email addresses that contain multiple @ characters. An application that uses the email module and implements some kind of checks on the From/To headers of a message could be tricked into accepting an email address that should be denied. An attack may be the same as in CVE-2019-11340; however, this CVE applies to Python more generally.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2019-16056"
}, {
  "versionRange" : "[3.1.2,3.1.2]",
  "severity" : 1.9,
  "cveName" : "CVE-2011-4944",
  "description" : "Python 2.6 through 3.2 creates ~/.pypirc with world-readable permissions before changing them after data has been written, which introduces a race condition that allows local users to obtain a username and password by reading this file.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-4944"
}, {
  "versionRange" : "[2.6.4,2.6.4]",
  "severity" : 6.4,
  "cveName" : "CVE-2011-1521",
  "description" : "The urllib and urllib2 modules in Python 2.x before 2.7.2 and 3.x before 3.2.1 process Location headers that specify redirection to file: URLs, which makes it easier for remote attackers to obtain sensitive information or cause a denial of service (resource consumption) via a crafted URL, as demonstrated by the file:///etc/passwd and file:///dev/zero URLs.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-1521"
}, {
  "versionRange" : "(,2.6.7]",
  "severity" : 5.0,
  "cveName" : "CVE-2012-1150",
  "description" : "Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 computes hash values without restricting the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-1150"
}, {
  "versionRange" : "[2.7.4,2.7.4]",
  "severity" : 4.3,
  "cveName" : "CVE-2013-7040",
  "description" : "Python 2.7 before 3.4 only uses the last eight bits of the prefix to randomize hash values, which causes it to compute hash values without restricting the ability to trigger hash collisions predictably and makes it easier for context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2012-1150.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-7040"
}, {
  "versionRange" : "[3.4.0,3.4.7)",
  "severity" : 7.5,
  "cveName" : "CVE-2016-2183",
  "description" : "The DES and Triple DES ciphers, as used in the TLS, SSH, and IPSec protocols and other protocols and products, have a birthday bound of approximately four billion blocks, which makes it easier for remote attackers to obtain cleartext data via a birthday attack against a long-duration encrypted session, as demonstrated by an HTTPS session using Triple DES in CBC mode, aka a \"Sweet32\" attack.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-2183"
}, {
  "versionRange" : "[3.6,3.6.4]",
  "severity" : 7.5,
  "cveName" : "CVE-2018-1061",
  "description" : "python before versions 2.7.15, 3.4.9, 3.5.6rc1, 3.6.5rc1 and 3.7.0 is vulnerable to catastrophic backtracking in the difflib.IS_LINE_JUNK method.  An attacker could use this flaw to cause denial of service.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2018-1061"
}, {
  "versionRange" : "[2.6.4,2.6.4]",
  "severity" : 1.9,
  "cveName" : "CVE-2011-4944",
  "description" : "Python 2.6 through 3.2 creates ~/.pypirc with world-readable permissions before changing them after data has been written, which introduces a race condition that allows local users to obtain a username and password by reading this file.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-4944"
}, {
  "versionRange" : "[3.1.1,3.1.1]",
  "severity" : 6.4,
  "cveName" : "CVE-2011-1521",
  "description" : "The urllib and urllib2 modules in Python 2.x before 2.7.2 and 3.x before 3.2.1 process Location headers that specify redirection to file: URLs, which makes it easier for remote attackers to obtain sensitive information or cause a denial of service (resource consumption) via a crafted URL, as demonstrated by the file:///etc/passwd and file:///dev/zero URLs.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-1521"
}, {
  "versionRange" : "[3.2.0,3.2.6]",
  "severity" : 7.5,
  "cveName" : "CVE-2019-16056",
  "description" : "An issue was discovered in Python through 2.7.16, 3.x through 3.5.7, 3.6.x through 3.6.9, and 3.7.x through 3.7.4. The email module wrongly parses email addresses that contain multiple @ characters. An application that uses the email module and implements some kind of checks on the From/To headers of a message could be tricked into accepting an email address that should be denied. An attack may be the same as in CVE-2019-11340; however, this CVE applies to Python more generally.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2019-16056"
}, {
  "versionRange" : "[3.2.0,3.2.3)",
  "severity" : 4.3,
  "cveName" : "CVE-2012-0876",
  "description" : "The XML parser (xmlparse.c) in expat before 2.1.0 computes hash values without restricting the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via an XML file with many identifiers with the same value.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-0876"
}, {
  "versionRange" : "[3.7.0,3.7.6]",
  "severity" : 5.5,
  "cveName" : "CVE-2020-8315",
  "description" : "In Python (CPython) 3.6 through 3.6.10, 3.7 through 3.7.6, and 3.8 through 3.8.1, an insecure dependency load upon launch on Windows 7 may result in an attacker's copy of api-ms-win-core-path-l1-1-0.dll being loaded and used instead of the system's copy. Windows 8 and later are unaffected.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2020-8315"
}, {
  "versionRange" : "[2.6.7,2.6.7]",
  "severity" : 6.4,
  "cveName" : "CVE-2011-1521",
  "description" : "The urllib and urllib2 modules in Python 2.x before 2.7.2 and 3.x before 3.2.1 process Location headers that specify redirection to file: URLs, which makes it easier for remote attackers to obtain sensitive information or cause a denial of service (resource consumption) via a crafted URL, as demonstrated by the file:///etc/passwd and file:///dev/zero URLs.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-1521"
}, {
  "versionRange" : "[2.7.1,2.7.1]",
  "severity" : 6.4,
  "cveName" : "CVE-2014-7185",
  "description" : "Integer overflow in bufferobject.c in Python before 2.7.8 allows context-dependent attackers to obtain sensitive information from process memory via a large size and offset in a \"buffer\" function.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-7185"
}, {
  "versionRange" : "[2.7.3,2.7.3]",
  "severity" : 4.3,
  "cveName" : "CVE-2013-7040",
  "description" : "Python 2.7 before 3.4 only uses the last eight bits of the prefix to randomize hash values, which causes it to compute hash values without restricting the ability to trigger hash collisions predictably and makes it easier for context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2012-1150.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-7040"
}, {
  "versionRange" : "[3.6.0,3.6.2)",
  "severity" : 7.5,
  "cveName" : "CVE-2017-9233",
  "description" : "XML External Entity vulnerability in libexpat 2.2.0 and earlier (Expat XML Parser Library) allows attackers to put the parser in an infinite loop using a malformed external entity definition from an external DTD.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2017-9233"
}, {
  "versionRange" : "[3.1.4,3.1.4]",
  "severity" : 7.5,
  "cveName" : "CVE-2014-1912",
  "description" : "Buffer overflow in the socket.recvfrom_into function in Modules/socketmodule.c in Python 2.5 before 2.7.7, 3.x before 3.3.4, and 3.4.x before 3.4rc1 allows remote attackers to execute arbitrary code via a crafted string.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-1912"
}, {
  "versionRange" : "[3.1.5,3.1.5]",
  "severity" : 5.9,
  "cveName" : "CVE-2013-7440",
  "description" : "The ssl.match_hostname function in CPython (aka Python) before 2.7.9 and 3.x before 3.3.3 does not properly handle wildcards in hostnames, which might allow man-in-the-middle attackers to spoof servers via a crafted certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-7440"
}, {
  "versionRange" : "[2.7.2,2.7.2]",
  "severity" : 4.3,
  "cveName" : "CVE-2013-7040",
  "description" : "Python 2.7 before 3.4 only uses the last eight bits of the prefix to randomize hash values, which causes it to compute hash values without restricting the ability to trigger hash collisions predictably and makes it easier for context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2012-1150.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-7040"
}, {
  "versionRange" : "[2.6.5,2.6.5]",
  "severity" : 5.0,
  "cveName" : "CVE-2012-0845",
  "description" : "SimpleXMLRPCServer.py in SimpleXMLRPCServer in Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 allows remote attackers to cause a denial of service (infinite loop and CPU consumption) via an XML-RPC POST request that contains a smaller amount of data than specified by the Content-Length header.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-0845"
}, {
  "versionRange" : "(,2.5.12)",
  "severity" : 7.5,
  "cveName" : "CVE-2008-3143",
  "description" : "Multiple integer overflows in Python before 2.5.2 might allow context-dependent attackers to have an unknown impact via vectors related to (1) Include/pymem.h; (2) _csv.c, (3) _struct.c, (4) arraymodule.c, (5) audioop.c, (6) binascii.c, (7) cPickle.c, (8) cStringIO.c, (9) cjkcodecs/multibytecodec.c, (10) datetimemodule.c, (11) md5.c, (12) rgbimgmodule.c, and (13) stropmodule.c in Modules/; (14) bufferobject.c, (15) listobject.c, and (16) obmalloc.c in Objects/; (17) Parser/node.c; and (18) asdl.c, (19) ast.c, (20) bltinmodule.c, and (21) compile.c in Python/, as addressed by \"checks for integer overflows, contributed by Google.\"",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2008-3143"
}, {
  "versionRange" : "[3.3.2,3.3.2]",
  "severity" : 4.3,
  "cveName" : "CVE-2013-2099",
  "description" : "Algorithmic complexity vulnerability in the ssl.match_hostname function in Python 3.2.x, 3.3.x, and earlier, and unspecified versions of python-backports-ssl_match_hostname as used for older Python versions, allows remote attackers to cause a denial of service (CPU consumption) via multiple wildcard characters in the common name in a certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-2099"
}, {
  "versionRange" : "[3.6.0,3.6.10]",
  "severity" : 5.5,
  "cveName" : "CVE-2020-8315",
  "description" : "In Python (CPython) 3.6 through 3.6.10, 3.7 through 3.7.6, and 3.8 through 3.8.1, an insecure dependency load upon launch on Windows 7 may result in an attacker's copy of api-ms-win-core-path-l1-1-0.dll being loaded and used instead of the system's copy. Windows 8 and later are unaffected.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2020-8315"
}, {
  "versionRange" : "[3.9.0,3.9.2)",
  "severity" : 5.9,
  "cveName" : "CVE-2021-23336",
  "description" : "The package python/cpython from 0 and before 3.6.13, from 3.7.0 and before 3.7.10, from 3.8.0 and before 3.8.8, from 3.9.0 and before 3.9.2 are vulnerable to Web Cache Poisoning via urllib.parse.parse_qsl and urllib.parse.parse_qs by using a vector called parameter cloaking. When the attacker can separate query parameters using a semicolon (;), they can cause a difference in the interpretation of the request between the proxy (running with default configuration) and the server. This can result in malicious requests being cached as completely safe ones, as the proxy would usually not see the semicolon as a separator, and therefore would not include it in a cache key of an unkeyed parameter.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2021-23336"
}, {
  "versionRange" : "[2.4.3,2.4.3]",
  "severity" : 6.4,
  "cveName" : "CVE-2011-1521",
  "description" : "The urllib and urllib2 modules in Python 2.x before 2.7.2 and 3.x before 3.2.1 process Location headers that specify redirection to file: URLs, which makes it easier for remote attackers to obtain sensitive information or cause a denial of service (resource consumption) via a crafted URL, as demonstrated by the file:///etc/passwd and file:///dev/zero URLs.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-1521"
}, {
  "versionRange" : "[2.7.2,2.7.2]",
  "severity" : 5.0,
  "cveName" : "CVE-2012-1150",
  "description" : "Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 computes hash values without restricting the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-1150"
}, {
  "versionRange" : "[3.1.4,3.1.4]",
  "severity" : 6.5,
  "cveName" : "CVE-2016-0772",
  "description" : "The smtplib library in CPython (aka Python) before 2.7.12, 3.x before 3.4.5, and 3.5.x before 3.5.2 does not return an error when StartTLS fails, which might allow man-in-the-middle attackers to bypass the TLS protections by leveraging a network position between the client and the registry to block the StartTLS command, aka a \"StartTLS stripping attack.\"",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-0772"
}, {
  "versionRange" : "[3.7.0,3.7.11)",
  "severity" : 5.3,
  "cveName" : "CVE-2021-4189",
  "description" : "A flaw was found in Python, specifically in the FTP (File Transfer Protocol) client library in PASV (passive) mode. The issue is how the FTP client trusts the host from the PASV response by default. This flaw allows an attacker to set up a malicious FTP server that can trick FTP clients into connecting back to a given IP address and port. This vulnerability could lead to FTP client scanning ports, which otherwise would not have been possible.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2021-4189"
}, {
  "versionRange" : "[3.8.0,3.8.14)",
  "severity" : 7.4,
  "cveName" : "CVE-2021-28861",
  "description" : "Python 3.x through 3.10 has an open redirection vulnerability in lib/http/server.py due to no protection against multiple (/) at the beginning of URI path which may leads to information disclosure. NOTE: this is disputed by a third party because the http.server.html documentation page states \"Warning: http.server is not recommended for production. It only implements basic security checks.\"",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2021-28861"
}, {
  "versionRange" : "[3.2.2,3.2.2]",
  "severity" : 6.1,
  "cveName" : "CVE-2016-5699",
  "description" : "CRLF injection vulnerability in the HTTPConnection.putheader function in urllib2 and urllib in CPython (aka Python) before 2.7.10 and 3.x before 3.4.4 allows remote attackers to inject arbitrary HTTP headers via CRLF sequences in a URL.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-5699"
}, {
  "versionRange" : "[2.7.1,2.7.1]",
  "severity" : 4.3,
  "cveName" : "CVE-2013-7040",
  "description" : "Python 2.7 before 3.4 only uses the last eight bits of the prefix to randomize hash values, which causes it to compute hash values without restricting the ability to trigger hash collisions predictably and makes it easier for context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2012-1150.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-7040"
}, {
  "versionRange" : "[1.5.2,2.4.6)",
  "severity" : 7.5,
  "cveName" : "CVE-2008-4864",
  "description" : "Multiple integer overflows in imageop.c in the imageop module in Python 1.5.2 through 2.5.1 allow context-dependent attackers to break out of the Python VM and execute arbitrary code via large integer values in certain arguments to the crop function, leading to a buffer overflow, a different vulnerability than CVE-2007-4965 and CVE-2008-1679.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2008-4864"
}, {
  "versionRange" : "[3.8.0,3.8.7)",
  "severity" : 9.8,
  "cveName" : "CVE-2020-27619",
  "description" : "In Python 3 through 3.9.0, the Lib/test/multibytecodec_support.py CJK codec tests call eval() on content retrieved via HTTP.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2020-27619"
}, {
  "versionRange" : "[2.6.6,2.6.6]",
  "severity" : 4.3,
  "cveName" : "CVE-2013-4238",
  "description" : "The ssl.match_hostname function in the SSL module in Python 2.6 through 3.4 does not properly handle a '\\0' character in a domain name in the Subject Alternative Name field of an X.509 certificate, which allows man-in-the-middle attackers to spoof arbitrary SSL servers via a crafted certificate issued by a legitimate Certification Authority, a related issue to CVE-2009-2408.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-4238"
}, {
  "versionRange" : "(,2.2.2)",
  "severity" : 4.6,
  "cveName" : "CVE-2002-1119",
  "description" : "os._execvpe from os.py in Python 2.2.1 and earlier creates temporary files with predictable names, which could allow local users to execute arbitrary code via a symlink attack.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2002-1119"
}, {
  "versionRange" : "[2.2.2,2.2.2]",
  "severity" : 5.0,
  "cveName" : "CVE-2012-1150",
  "description" : "Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 computes hash values without restricting the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-1150"
}, {
  "versionRange" : "[3.2.6,3.2.6]",
  "severity" : 6.5,
  "cveName" : "CVE-2016-0772",
  "description" : "The smtplib library in CPython (aka Python) before 2.7.12, 3.x before 3.4.5, and 3.5.x before 3.5.2 does not return an error when StartTLS fails, which might allow man-in-the-middle attackers to bypass the TLS protections by leveraging a network position between the client and the registry to block the StartTLS command, aka a \"StartTLS stripping attack.\"",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-0772"
}, {
  "versionRange" : "[3.2.0,3.2.6)",
  "severity" : 9.8,
  "cveName" : "CVE-2014-4650",
  "description" : "The CGIHTTPServer module in Python 2.7.5 and 3.3.4 does not properly handle URLs in which URL encoding is used for path separators, which allows remote attackers to read script source code or conduct directory traversal attacks and execute unintended code via a crafted character sequence, as demonstrated by a %2f separator.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-4650"
}, {
  "versionRange" : "[3.7.0,3.8.17)",
  "severity" : 6.8,
  "cveName" : "CVE-2007-4559",
  "description" : "Directory traversal vulnerability in the (1) extract and (2) extractall functions in the tarfile module in Python allows user-assisted remote attackers to overwrite arbitrary files via a .. (dot dot) sequence in filenames in a TAR archive, a related issue to CVE-2001-1267.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2007-4559"
}, {
  "versionRange" : "[3.2.4,3.2.4]",
  "severity" : 5.9,
  "cveName" : "CVE-2013-7440",
  "description" : "The ssl.match_hostname function in CPython (aka Python) before 2.7.9 and 3.x before 3.3.3 does not properly handle wildcards in hostnames, which might allow man-in-the-middle attackers to spoof servers via a crafted certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-7440"
}, {
  "versionRange" : "[3.4.4,3.4.4]",
  "severity" : 6.5,
  "cveName" : "CVE-2016-0772",
  "description" : "The smtplib library in CPython (aka Python) before 2.7.12, 3.x before 3.4.5, and 3.5.x before 3.5.2 does not return an error when StartTLS fails, which might allow man-in-the-middle attackers to bypass the TLS protections by leveraging a network position between the client and the registry to block the StartTLS command, aka a \"StartTLS stripping attack.\"",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-0772"
}, {
  "versionRange" : "[2.7.0,2.7.7)",
  "severity" : 5.9,
  "cveName" : "CVE-2014-4616",
  "description" : "Array index error in the scanstring function in the _json module in Python 2.7 through 3.5 and simplejson before 2.6.1 allows context-dependent attackers to read arbitrary process memory via a negative index value in the idx argument to the raw_decode function.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-4616"
}, {
  "versionRange" : "[3.4.3,3.4.3]",
  "severity" : 9.8,
  "cveName" : "CVE-2016-5636",
  "description" : "Integer overflow in the get_data function in zipimport.c in CPython (aka Python) before 2.7.12, 3.x before 3.4.5, and 3.5.x before 3.5.2 allows remote attackers to have unspecified impact via a negative data size value, which triggers a heap-based buffer overflow.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-5636"
}, {
  "versionRange" : "[3.5.0,3.5.7)",
  "severity" : 9.8,
  "cveName" : "CVE-2019-9636",
  "description" : "Python 2.7.x through 2.7.16 and 3.x through 3.7.2 is affected by: Improper Handling of Unicode Encoding (with an incorrect netloc) during NFKC normalization. The impact is: Information disclosure (credentials, cookies, etc. that are cached against a given hostname). The components are: urllib.parse.urlsplit, urllib.parse.urlparse. The attack vector is: A specially crafted URL could be incorrectly parsed to locate cookies or authentication data and send that information to a different host than when parsed correctly. This is fixed in: v2.7.17, v2.7.17rc1, v2.7.18, v2.7.18rc1; v3.5.10, v3.5.10rc1, v3.5.7, v3.5.8, v3.5.8rc1, v3.5.8rc2, v3.5.9; v3.6.10, v3.6.10rc1, v3.6.11, v3.6.11rc1, v3.6.12, v3.6.9, v3.6.9rc1; v3.7.3, v3.7.3rc1, v3.7.4, v3.7.4rc1, v3.7.4rc2, v3.7.5, v3.7.5rc1, v3.7.6, v3.7.6rc1, v3.7.7, v3.7.7rc1, v3.7.8, v3.7.8rc1, v3.7.9.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2019-9636"
}, {
  "versionRange" : "[3.2.4,3.2.4]",
  "severity" : 9.8,
  "cveName" : "CVE-2016-5636",
  "description" : "Integer overflow in the get_data function in zipimport.c in CPython (aka Python) before 2.7.12, 3.x before 3.4.5, and 3.5.x before 3.5.2 allows remote attackers to have unspecified impact via a negative data size value, which triggers a heap-based buffer overflow.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-5636"
}, {
  "versionRange" : "[2.4.6,2.4.6]",
  "severity" : 5.0,
  "cveName" : "CVE-2012-1150",
  "description" : "Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 computes hash values without restricting the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-1150"
}, {
  "versionRange" : "[3.2.2,3.2.2]",
  "severity" : 9.8,
  "cveName" : "CVE-2016-5636",
  "description" : "Integer overflow in the get_data function in zipimport.c in CPython (aka Python) before 2.7.12, 3.x before 3.4.5, and 3.5.x before 3.5.2 allows remote attackers to have unspecified impact via a negative data size value, which triggers a heap-based buffer overflow.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-5636"
}, {
  "versionRange" : "[3.3.0,3.3.3)",
  "severity" : 6.4,
  "cveName" : "CVE-2012-2135",
  "description" : "The utf-16 decoder in Python 3.1 through 3.3 does not update the aligned_end variable after calling the unicode_decode_call_errorhandler function, which allows remote attackers to obtain sensitive information (process memory) or cause a denial of service (memory corruption and crash) via unspecified vectors.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-2135"
}, {
  "versionRange" : "[2.2.3,2.2.3]",
  "severity" : 5.0,
  "cveName" : "CVE-2012-1150",
  "description" : "Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 computes hash values without restricting the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-1150"
}, {
  "versionRange" : "[2.5.0,2.5.3)",
  "severity" : 7.5,
  "cveName" : "CVE-2008-4864",
  "description" : "Multiple integer overflows in imageop.c in the imageop module in Python 1.5.2 through 2.5.1 allow context-dependent attackers to break out of the Python VM and execute arbitrary code via large integer values in certain arguments to the crop function, leading to a buffer overflow, a different vulnerability than CVE-2007-4965 and CVE-2008-1679.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2008-4864"
}, {
  "versionRange" : "[3.1.3,3.1.3]",
  "severity" : 5.0,
  "cveName" : "CVE-2012-1150",
  "description" : "Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 computes hash values without restricting the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-1150"
}, {
  "versionRange" : "[3.2.6,3.2.6]",
  "severity" : 9.8,
  "cveName" : "CVE-2016-5636",
  "description" : "Integer overflow in the get_data function in zipimport.c in CPython (aka Python) before 2.7.12, 3.x before 3.4.5, and 3.5.x before 3.5.2 allows remote attackers to have unspecified impact via a negative data size value, which triggers a heap-based buffer overflow.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-5636"
}, {
  "versionRange" : "[2.3.5,2.3.5]",
  "severity" : 5.0,
  "cveName" : "CVE-2012-0845",
  "description" : "SimpleXMLRPCServer.py in SimpleXMLRPCServer in Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 allows remote attackers to cause a denial of service (infinite loop and CPU consumption) via an XML-RPC POST request that contains a smaller amount of data than specified by the Content-Length header.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-0845"
}, {
  "versionRange" : "[2.7.3,2.7.3]",
  "severity" : 4.3,
  "cveName" : "CVE-2013-4238",
  "description" : "The ssl.match_hostname function in the SSL module in Python 2.6 through 3.4 does not properly handle a '\\0' character in a domain name in the Subject Alternative Name field of an X.509 certificate, which allows man-in-the-middle attackers to spoof arbitrary SSL servers via a crafted certificate issued by a legitimate Certification Authority, a related issue to CVE-2009-2408.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-4238"
}, {
  "versionRange" : "[3.0.0,3.4.10)",
  "severity" : 9.8,
  "cveName" : "CVE-2019-9636",
  "description" : "Python 2.7.x through 2.7.16 and 3.x through 3.7.2 is affected by: Improper Handling of Unicode Encoding (with an incorrect netloc) during NFKC normalization. The impact is: Information disclosure (credentials, cookies, etc. that are cached against a given hostname). The components are: urllib.parse.urlsplit, urllib.parse.urlparse. The attack vector is: A specially crafted URL could be incorrectly parsed to locate cookies or authentication data and send that information to a different host than when parsed correctly. This is fixed in: v2.7.17, v2.7.17rc1, v2.7.18, v2.7.18rc1; v3.5.10, v3.5.10rc1, v3.5.7, v3.5.8, v3.5.8rc1, v3.5.8rc2, v3.5.9; v3.6.10, v3.6.10rc1, v3.6.11, v3.6.11rc1, v3.6.12, v3.6.9, v3.6.9rc1; v3.7.3, v3.7.3rc1, v3.7.4, v3.7.4rc1, v3.7.4rc2, v3.7.5, v3.7.5rc1, v3.7.6, v3.7.6rc1, v3.7.7, v3.7.7rc1, v3.7.8, v3.7.8rc1, v3.7.9.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2019-9636"
}, {
  "versionRange" : "[3.6.0,3.6.5)",
  "severity" : 6.7,
  "cveName" : "CVE-2018-1000117",
  "description" : "Python Software Foundation CPython version From 3.2 until 3.6.4 on Windows contains a Buffer Overflow vulnerability in os.symlink() function on Windows that can result in Arbitrary code execution, likely escalation of privilege. This attack appears to be exploitable via a python script that creates a symlink with an attacker controlled name or location. This vulnerability appears to have been fixed in 3.7.0 and 3.6.5.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2018-1000117"
}, {
  "versionRange" : "[2.6.3,2.6.3]",
  "severity" : 1.9,
  "cveName" : "CVE-2011-4944",
  "description" : "Python 2.6 through 3.2 creates ~/.pypirc with world-readable permissions before changing them after data has been written, which introduces a race condition that allows local users to obtain a username and password by reading this file.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-4944"
}, {
  "versionRange" : "[3.1.5,3.1.5]",
  "severity" : 6.1,
  "cveName" : "CVE-2016-5699",
  "description" : "CRLF injection vulnerability in the HTTPConnection.putheader function in urllib2 and urllib in CPython (aka Python) before 2.7.10 and 3.x before 3.4.4 allows remote attackers to inject arbitrary HTTP headers via CRLF sequences in a URL.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-5699"
}, {
  "versionRange" : "[3.6.0,3.6.14)",
  "severity" : 5.3,
  "cveName" : "CVE-2021-4189",
  "description" : "A flaw was found in Python, specifically in the FTP (File Transfer Protocol) client library in PASV (passive) mode. The issue is how the FTP client trusts the host from the PASV response by default. This flaw allows an attacker to set up a malicious FTP server that can trick FTP clients into connecting back to a given IP address and port. This vulnerability could lead to FTP client scanning ports, which otherwise would not have been possible.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2021-4189"
}, {
  "versionRange" : "[3.0.1,3.0.1]",
  "severity" : 4.3,
  "cveName" : "CVE-2013-4238",
  "description" : "The ssl.match_hostname function in the SSL module in Python 2.6 through 3.4 does not properly handle a '\\0' character in a domain name in the Subject Alternative Name field of an X.509 certificate, which allows man-in-the-middle attackers to spoof arbitrary SSL servers via a crafted certificate issued by a legitimate Certification Authority, a related issue to CVE-2009-2408.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-4238"
}, {
  "versionRange" : "[3.9.0,3.9.14)",
  "severity" : 7.4,
  "cveName" : "CVE-2021-28861",
  "description" : "Python 3.x through 3.10 has an open redirection vulnerability in lib/http/server.py due to no protection against multiple (/) at the beginning of URI path which may leads to information disclosure. NOTE: this is disputed by a third party because the http.server.html documentation page states \"Warning: http.server is not recommended for production. It only implements basic security checks.\"",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2021-28861"
}, {
  "versionRange" : "[3.2.1,3.2.1]",
  "severity" : 6.5,
  "cveName" : "CVE-2016-0772",
  "description" : "The smtplib library in CPython (aka Python) before 2.7.12, 3.x before 3.4.5, and 3.5.x before 3.5.2 does not return an error when StartTLS fails, which might allow man-in-the-middle attackers to bypass the TLS protections by leveraging a network position between the client and the registry to block the StartTLS command, aka a \"StartTLS stripping attack.\"",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-0772"
}, {
  "versionRange" : "[3.7.0,3.7.7)",
  "severity" : 7.5,
  "cveName" : "CVE-2022-48560",
  "description" : "A use-after-free exists in Python through 3.9 via heappushpop in heapq.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2022-48560"
}, {
  "versionRange" : "[3.9.0,3.9.7)",
  "severity" : 6.8,
  "cveName" : "CVE-2013-0340",
  "description" : "expat 2.1.0 and earlier does not properly handle entities expansion unless an application developer uses the XML_SetEntityDeclHandler function, which allows remote attackers to cause a denial of service (resource consumption), send HTTP requests to intranet servers, or read arbitrary files via a crafted XML document, aka an XML External Entity (XXE) issue.  NOTE: it could be argued that because expat already provides the ability to disable external entity expansion, the responsibility for resolving this issue lies with application developers; according to this argument, this entry should be REJECTed, and each affected application would need its own CVE.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-0340"
}, {
  "versionRange" : "[3.8.0,3.8.5)",
  "severity" : 9.8,
  "cveName" : "CVE-2020-15801",
  "description" : "In Python 3.8.4, sys.path restrictions specified in a python38._pth file are ignored, allowing code to be loaded from arbitrary locations. The <executable-name>._pth file (e.g., the python._pth file) is not affected.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2020-15801"
}, {
  "versionRange" : "[3.8.0,3.8.7]",
  "severity" : 9.8,
  "cveName" : "CVE-2021-3177",
  "description" : "Python 3.x through 3.9.1 has a buffer overflow in PyCArg_repr in _ctypes/callproc.c, which may lead to remote code execution in certain Python applications that accept floating-point numbers as untrusted input, as demonstrated by a 1e300 argument to c_double.from_param. This occurs because sprintf is used unsafely.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2021-3177"
}, {
  "versionRange" : "(,3.8.18)",
  "severity" : 5.3,
  "cveName" : "CVE-2023-40217",
  "description" : "An issue was discovered in Python before 3.8.18, 3.9.x before 3.9.18, 3.10.x before 3.10.13, and 3.11.x before 3.11.5. It primarily affects servers (such as HTTP servers) that use TLS client authentication. If a TLS server-side socket is created, receives data into the socket buffer, and then is closed quickly, there is a brief window where the SSLSocket instance will detect the socket as \"not connected\" and won't initiate a handshake, but buffered data will still be readable from the socket buffer. This data will not be authenticated if the server-side TLS peer is expecting client certificate authentication, and is indistinguishable from valid TLS stream data. Data is limited in size to the amount that will fit in the buffer. (The TLS connection cannot directly be used for data exfiltration because the vulnerable code path requires that the connection be closed on initialization of the SSLSocket.)",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2023-40217"
}, {
  "versionRange" : "[3.4.0,3.4.2)",
  "severity" : 7.4,
  "cveName" : "CVE-2014-0224",
  "description" : "OpenSSL before 0.9.8za, 1.0.0 before 1.0.0m, and 1.0.1 before 1.0.1h does not properly restrict processing of ChangeCipherSpec messages, which allows man-in-the-middle attackers to trigger use of a zero-length master key in certain OpenSSL-to-OpenSSL communications, and consequently hijack sessions or obtain sensitive information, via a crafted TLS handshake, aka the \"CCS Injection\" vulnerability.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-0224"
}, {
  "versionRange" : "[2.3.1,2.3.1]",
  "severity" : 2.6,
  "cveName" : "CVE-2011-4940",
  "description" : "The list_directory function in Lib/SimpleHTTPServer.py in SimpleHTTPServer in Python before 2.5.6c1, 2.6.x before 2.6.7 rc2, and 2.7.x before 2.7.2 does not place a charset parameter in the Content-Type HTTP header, which makes it easier for remote attackers to conduct cross-site scripting (XSS) attacks against Internet Explorer 7 via UTF-7 encoding.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-4940"
}, {
  "versionRange" : "[3.1.0,3.1.3)",
  "severity" : 5.0,
  "cveName" : "CVE-2010-2089",
  "description" : "The audioop module in Python 2.7 and 3.2 does not verify the relationships between size arguments and byte string lengths, which allows context-dependent attackers to cause a denial of service (memory corruption and application crash) via crafted arguments, as demonstrated by a call to audioop.reverse with a one-byte string, a different vulnerability than CVE-2010-1634.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2010-2089"
}, {
  "versionRange" : "[2.1.3,2.1.3]",
  "severity" : 5.0,
  "cveName" : "CVE-2012-1150",
  "description" : "Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 computes hash values without restricting the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-1150"
}, {
  "versionRange" : "[2.6.4,2.6.4]",
  "severity" : 4.3,
  "cveName" : "CVE-2013-4238",
  "description" : "The ssl.match_hostname function in the SSL module in Python 2.6 through 3.4 does not properly handle a '\\0' character in a domain name in the Subject Alternative Name field of an X.509 certificate, which allows man-in-the-middle attackers to spoof arbitrary SSL servers via a crafted certificate issued by a legitimate Certification Authority, a related issue to CVE-2009-2408.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-4238"
}, {
  "versionRange" : "[2.7.1,2.7.1]",
  "severity" : 5.0,
  "cveName" : "CVE-2012-0845",
  "description" : "SimpleXMLRPCServer.py in SimpleXMLRPCServer in Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 allows remote attackers to cause a denial of service (infinite loop and CPU consumption) via an XML-RPC POST request that contains a smaller amount of data than specified by the Content-Length header.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-0845"
}, {
  "versionRange" : "(,3.6.13)",
  "severity" : 6.5,
  "cveName" : "CVE-2022-48564",
  "description" : "read_ints in plistlib.py in Python through 3.9.1 is vulnerable to a potential DoS attack via CPU and RAM exhaustion when processing malformed Apple Property List files in binary format.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2022-48564"
}, {
  "versionRange" : "[3.10.0,3.10.9)",
  "severity" : 7.8,
  "cveName" : "CVE-2022-42919",
  "description" : "Python 3.9.x before 3.9.16 and 3.10.x before 3.10.9 on Linux allows local privilege escalation in a non-default configuration. The Python multiprocessing library, when used with the forkserver start method on Linux, allows pickles to be deserialized from any user in the same machine local network namespace, which in many system configurations means any user on the same machine. Pickles can execute arbitrary code. Thus, this allows for local user privilege escalation to the user that any forkserver process is running as. Setting multiprocessing.util.abstract_sockets_supported to False is a workaround. The forkserver start method for multiprocessing is not the default start method. This issue is Linux specific because only Linux supports abstract namespace sockets. CPython before 3.9 does not make use of Linux abstract namespace sockets by default. Support for users manually specifying an abstract namespace socket was added as a bugfix in 3.7.8 and 3.8.3, but users would need to make specific uncommon API calls in order to do that in CPython before 3.9.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2022-42919"
}, {
  "versionRange" : "[3.5.0,3.5.3)",
  "severity" : 6.1,
  "cveName" : "CVE-2016-1000110",
  "description" : "The CGIHandler class in Python before 2.7.12 does not protect against the HTTP_PROXY variable name clash in a CGI script, which could allow a remote attacker to redirect HTTP requests.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-1000110"
}, {
  "versionRange" : "[3.9.0,3.9.1)",
  "severity" : 9.8,
  "cveName" : "CVE-2022-48565",
  "description" : "An XML External Entity (XXE) issue was discovered in Python through 3.9.1. The plistlib module no longer accepts entity declarations in XML plist files to avoid XML vulnerabilities.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2022-48565"
}, {
  "versionRange" : "[3.4.0,3.7.1)",
  "severity" : 7.5,
  "cveName" : "CVE-2018-20406",
  "description" : "Modules/_pickle.c in Python before 3.7.1 has an integer overflow via a large LONG_BINPUT value that is mishandled during a \"resize to twice the size\" attempt. This issue might cause memory exhaustion, but is only relevant if the pickle format is used for serializing tens or hundreds of gigabytes of data. This issue is fixed in: v3.4.10, v3.4.10rc1; v3.5.10, v3.5.10rc1, v3.5.7, v3.5.7rc1, v3.5.8, v3.5.8rc1, v3.5.8rc2, v3.5.9; v3.6.10, v3.6.10rc1, v3.6.11, v3.6.11rc1, v3.6.12, v3.6.7, v3.6.7rc1, v3.6.7rc2, v3.6.8, v3.6.8rc1, v3.6.9, v3.6.9rc1; v3.7.1, v3.7.1rc1, v3.7.1rc2, v3.7.2, v3.7.2rc1, v3.7.3, v3.7.3rc1, v3.7.4, v3.7.4rc1, v3.7.4rc2, v3.7.5, v3.7.5rc1, v3.7.6, v3.7.6rc1, v3.7.7, v3.7.7rc1, v3.7.8, v3.7.8rc1, v3.7.9.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2018-20406"
}, {
  "versionRange" : "[3.9.0,3.9.1]",
  "severity" : 9.8,
  "cveName" : "CVE-2021-3177",
  "description" : "Python 3.x through 3.9.1 has a buffer overflow in PyCArg_repr in _ctypes/callproc.c, which may lead to remote code execution in certain Python applications that accept floating-point numbers as untrusted input, as demonstrated by a 1e300 argument to c_double.from_param. This occurs because sprintf is used unsafely.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2021-3177"
}, {
  "versionRange" : "[2.7.1,2.7.1]",
  "severity" : 5.0,
  "cveName" : "CVE-2012-1150",
  "description" : "Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 computes hash values without restricting the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-1150"
}, {
  "versionRange" : "[2.7.2,2.7.2]",
  "severity" : 2.6,
  "cveName" : "CVE-2011-4940",
  "description" : "The list_directory function in Lib/SimpleHTTPServer.py in SimpleHTTPServer in Python before 2.5.6c1, 2.6.x before 2.6.7 rc2, and 2.7.x before 2.7.2 does not place a charset parameter in the Content-Type HTTP header, which makes it easier for remote attackers to conduct cross-site scripting (XSS) attacks against Internet Explorer 7 via UTF-7 encoding.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-4940"
}, {
  "versionRange" : "[3.6.0,3.6.2)",
  "severity" : 9.8,
  "cveName" : "CVE-2016-0718",
  "description" : "Expat allows context-dependent attackers to cause a denial of service (crash) or possibly execute arbitrary code via a malformed input document, which triggers a buffer overflow.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-0718"
}, {
  "versionRange" : "[3.8.0,3.8.0]",
  "severity" : 7.5,
  "cveName" : "CVE-2019-17514",
  "description" : "library/glob.html in the Python 2 and 3 documentation before 2016 has potentially misleading information about whether sorting occurs, as demonstrated by irreproducible cancer-research results. NOTE: the effects of this documentation cross application domains, and thus it is likely that security-relevant code elsewhere is affected. This issue is not a Python implementation bug, and there are no reports that NMR researchers were specifically relying on library/glob.html. In other words, because the older documentation stated \"finds all the pathnames matching a specified pattern according to the rules used by the Unix shell,\" one might have incorrectly inferred that the sorting that occurs in a Unix shell also occurred for glob.glob. There is a workaround in newer versions of Willoughby nmr-data_compilation-p2.py and nmr-data_compilation-p3.py, which call sort() directly.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2019-17514"
}, {
  "versionRange" : "(,3.6.11)",
  "severity" : 7.5,
  "cveName" : "CVE-2022-48560",
  "description" : "A use-after-free exists in Python through 3.9 via heappushpop in heapq.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2022-48560"
}, {
  "versionRange" : "(,2.7.16]",
  "severity" : 7.5,
  "cveName" : "CVE-2019-16056",
  "description" : "An issue was discovered in Python through 2.7.16, 3.x through 3.5.7, 3.6.x through 3.6.9, and 3.7.x through 3.7.4. The email module wrongly parses email addresses that contain multiple @ characters. An application that uses the email module and implements some kind of checks on the From/To headers of a message could be tricked into accepting an email address that should be denied. An attack may be the same as in CVE-2019-11340; however, this CVE applies to Python more generally.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2019-16056"
}, {
  "versionRange" : "[3.5.1,3.5.1]",
  "severity" : 6.5,
  "cveName" : "CVE-2016-0772",
  "description" : "The smtplib library in CPython (aka Python) before 2.7.12, 3.x before 3.4.5, and 3.5.x before 3.5.2 does not return an error when StartTLS fails, which might allow man-in-the-middle attackers to bypass the TLS protections by leveraging a network position between the client and the registry to block the StartTLS command, aka a \"StartTLS stripping attack.\"",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-0772"
}, {
  "versionRange" : "(,2.7.15)",
  "severity" : 7.5,
  "cveName" : "CVE-2018-1061",
  "description" : "python before versions 2.7.15, 3.4.9, 3.5.6rc1, 3.6.5rc1 and 3.7.0 is vulnerable to catastrophic backtracking in the difflib.IS_LINE_JUNK method.  An attacker could use this flaw to cause denial of service.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2018-1061"
}, {
  "versionRange" : "[3.9.0,3.9.11)",
  "severity" : 6.5,
  "cveName" : "CVE-2016-3189",
  "description" : "Use-after-free vulnerability in bzip2recover in bzip2 1.0.6 allows remote attackers to cause a denial of service (crash) via a crafted bzip2 file, related to block ends set to before the start of the block.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-3189"
}, {
  "versionRange" : "[3.0.1,3.0.1]",
  "severity" : 1.9,
  "cveName" : "CVE-2011-4944",
  "description" : "Python 2.6 through 3.2 creates ~/.pypirc with world-readable permissions before changing them after data has been written, which introduces a race condition that allows local users to obtain a username and password by reading this file.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-4944"
}, {
  "versionRange" : "[3.3.3,3.3.3]",
  "severity" : 6.5,
  "cveName" : "CVE-2016-0772",
  "description" : "The smtplib library in CPython (aka Python) before 2.7.12, 3.x before 3.4.5, and 3.5.x before 3.5.2 does not return an error when StartTLS fails, which might allow man-in-the-middle attackers to bypass the TLS protections by leveraging a network position between the client and the registry to block the StartTLS command, aka a \"StartTLS stripping attack.\"",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-0772"
}, {
  "versionRange" : "[3.1.5,3.1.5]",
  "severity" : 6.5,
  "cveName" : "CVE-2016-0772",
  "description" : "The smtplib library in CPython (aka Python) before 2.7.12, 3.x before 3.4.5, and 3.5.x before 3.5.2 does not return an error when StartTLS fails, which might allow man-in-the-middle attackers to bypass the TLS protections by leveraging a network position between the client and the registry to block the StartTLS command, aka a \"StartTLS stripping attack.\"",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-0772"
}, {
  "versionRange" : "[3.3.1,3.3.1]",
  "severity" : 5.8,
  "cveName" : "CVE-2014-9365",
  "description" : "The HTTP clients in the (1) httplib, (2) urllib, (3) urllib2, and (4) xmlrpclib libraries in CPython (aka Python) 2.x before 2.7.9 and 3.x before 3.4.3, when accessing an HTTPS URL, do not (a) check the certificate against a trust store or verify that the server hostname matches a domain name in the subject's (b) Common Name or (c) subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-9365"
}, {
  "versionRange" : "[3.1.5,3.1.5]",
  "severity" : 5.8,
  "cveName" : "CVE-2014-9365",
  "description" : "The HTTP clients in the (1) httplib, (2) urllib, (3) urllib2, and (4) xmlrpclib libraries in CPython (aka Python) 2.x before 2.7.9 and 3.x before 3.4.3, when accessing an HTTPS URL, do not (a) check the certificate against a trust store or verify that the server hostname matches a domain name in the subject's (b) Common Name or (c) subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-9365"
}, {
  "versionRange" : "(,3.6.14)",
  "severity" : 7.5,
  "cveName" : "CVE-2022-0391",
  "description" : "A flaw was found in Python, specifically within the urllib.parse module. This module helps break Uniform Resource Locator (URL) strings into components. The issue involves how the urlparse method does not sanitize input and allows characters like '\\r' and '\\n' in the URL path. This flaw allows an attacker to input a crafted URL, leading to injection attacks. This flaw affects Python versions prior to 3.10.0b1, 3.9.5, 3.8.11, 3.7.11 and 3.6.14.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2022-0391"
}, {
  "versionRange" : "[2.7.0,2.7.15)",
  "severity" : 7.5,
  "cveName" : "CVE-2017-9233",
  "description" : "XML External Entity vulnerability in libexpat 2.2.0 and earlier (Expat XML Parser Library) allows attackers to put the parser in an infinite loop using a malformed external entity definition from an external DTD.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2017-9233"
}, {
  "versionRange" : "[3.1.3,3.1.3]",
  "severity" : 1.9,
  "cveName" : "CVE-2011-4944",
  "description" : "Python 2.6 through 3.2 creates ~/.pypirc with world-readable permissions before changing them after data has been written, which introduces a race condition that allows local users to obtain a username and password by reading this file.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-4944"
}, {
  "versionRange" : "[2.3.1,2.3.1]",
  "severity" : 5.8,
  "cveName" : "CVE-2014-9365",
  "description" : "The HTTP clients in the (1) httplib, (2) urllib, (3) urllib2, and (4) xmlrpclib libraries in CPython (aka Python) 2.x before 2.7.9 and 3.x before 3.4.3, when accessing an HTTPS URL, do not (a) check the certificate against a trust store or verify that the server hostname matches a domain name in the subject's (b) Common Name or (c) subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-9365"
}, {
  "versionRange" : "[3.2.5,3.2.5]",
  "severity" : 5.9,
  "cveName" : "CVE-2013-7440",
  "description" : "The ssl.match_hostname function in CPython (aka Python) before 2.7.9 and 3.x before 3.3.3 does not properly handle wildcards in hostnames, which might allow man-in-the-middle attackers to spoof servers via a crafted certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-7440"
}, {
  "versionRange" : "[3.10.0,3.10.8)",
  "severity" : 7.6,
  "cveName" : "CVE-2015-20107",
  "description" : "In Python (aka CPython) up to 3.10.8, the mailcap module does not add escape characters into commands discovered in the system mailcap file. This may allow attackers to inject shell commands into applications that call mailcap.findmatch with untrusted input (if they lack validation of user-provided filenames or arguments). The fix is also back-ported to 3.7, 3.8, 3.9",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2015-20107"
}, {
  "versionRange" : "[3.8.0,3.8.12)",
  "severity" : 6.8,
  "cveName" : "CVE-2013-0340",
  "description" : "expat 2.1.0 and earlier does not properly handle entities expansion unless an application developer uses the XML_SetEntityDeclHandler function, which allows remote attackers to cause a denial of service (resource consumption), send HTTP requests to intranet servers, or read arbitrary files via a crafted XML document, aka an XML External Entity (XXE) issue.  NOTE: it could be argued that because expat already provides the ability to disable external entity expansion, the responsibility for resolving this issue lies with application developers; according to this argument, this entry should be REJECTed, and each affected application would need its own CVE.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-0340"
}, {
  "versionRange" : "[2.6.7,2.6.7]",
  "severity" : 5.8,
  "cveName" : "CVE-2014-9365",
  "description" : "The HTTP clients in the (1) httplib, (2) urllib, (3) urllib2, and (4) xmlrpclib libraries in CPython (aka Python) 2.x before 2.7.9 and 3.x before 3.4.3, when accessing an HTTPS URL, do not (a) check the certificate against a trust store or verify that the server hostname matches a domain name in the subject's (b) Common Name or (c) subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-9365"
}, {
  "versionRange" : "[3.9.0,3.9.10]",
  "severity" : 7.0,
  "cveName" : "CVE-2022-26488",
  "description" : "In Python before 3.10.3 on Windows, local users can gain privileges because the search path is inadequately secured. The installer may allow a local attacker to add user-writable directories to the system search path. To exploit, an administrator must have installed Python for all users and enabled PATH entries. A non-administrative user can trigger a repair that incorrectly adds user-writable paths into PATH, enabling search-path hijacking of other users and system services. This affects Python (CPython) through 3.7.12, 3.8.x through 3.8.12, 3.9.x through 3.9.10, and 3.10.x through 3.10.2.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2022-26488"
}, {
  "versionRange" : "[3.0.0,3.5.0)",
  "severity" : 7.8,
  "cveName" : "CVE-2019-13404",
  "description" : "The MSI installer for Python through 2.7.16 on Windows defaults to the C:\\Python27 directory, which makes it easier for local users to deploy Trojan horse code. (This also affects old 3.x releases before 3.5.) NOTE: the vendor's position is that it is the user's responsibility to ensure C:\\Python27 access control or choose a different directory, because backwards compatibility requires that C:\\Python27 remain the default for 2.7.x",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2019-13404"
}, {
  "versionRange" : "(,3.7.15]",
  "severity" : 7.5,
  "cveName" : "CVE-2022-45061",
  "description" : "An issue was discovered in Python before 3.11.1. An unnecessary quadratic algorithm exists in one path when processing some inputs to the IDNA (RFC 3490) decoder, such that a crafted, unreasonably long name being presented to the decoder could lead to a CPU denial of service. Hostnames are often supplied by remote servers that could be controlled by a malicious actor; in such a scenario, they could trigger excessive CPU consumption on the client attempting to make use of an attacker-supplied supposed hostname. For example, the attack payload could be placed in the Location header of an HTTP response with status code 302. A fix is planned in 3.11.1, 3.10.9, 3.9.16, 3.8.16, and 3.7.16.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2022-45061"
}, {
  "versionRange" : "[3.10.0,3.10.0]",
  "severity" : 7.5,
  "cveName" : "CVE-2022-0391",
  "description" : "A flaw was found in Python, specifically within the urllib.parse module. This module helps break Uniform Resource Locator (URL) strings into components. The issue involves how the urlparse method does not sanitize input and allows characters like '\\r' and '\\n' in the URL path. This flaw allows an attacker to input a crafted URL, leading to injection attacks. This flaw affects Python versions prior to 3.10.0b1, 3.9.5, 3.8.11, 3.7.11 and 3.6.14.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2022-0391"
}, {
  "versionRange" : "[3.4.0,3.4.3)",
  "severity" : 7.5,
  "cveName" : "CVE-2013-1753",
  "description" : "The gzip_decode function in the xmlrpc client library in Python 3.4 and earlier allows remote attackers to cause a denial of service (memory consumption) via a crafted HTTP request.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-1753"
}, {
  "versionRange" : "[3.7.0,3.7.13)",
  "severity" : 9.8,
  "cveName" : "CVE-2019-12900",
  "description" : "BZ2_decompress in decompress.c in bzip2 through 1.0.6 has an out-of-bounds write when there are many selectors.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2019-12900"
}, {
  "versionRange" : "[2.7.5,2.7.5]",
  "severity" : 6.4,
  "cveName" : "CVE-2014-7185",
  "description" : "Integer overflow in bufferobject.c in Python before 2.7.8 allows context-dependent attackers to obtain sensitive information from process memory via a large size and offset in a \"buffer\" function.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-7185"
}, {
  "versionRange" : "[2.1.3,2.1.3]",
  "severity" : 5.8,
  "cveName" : "CVE-2014-9365",
  "description" : "The HTTP clients in the (1) httplib, (2) urllib, (3) urllib2, and (4) xmlrpclib libraries in CPython (aka Python) 2.x before 2.7.9 and 3.x before 3.4.3, when accessing an HTTPS URL, do not (a) check the certificate against a trust store or verify that the server hostname matches a domain name in the subject's (b) Common Name or (c) subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-9365"
}, {
  "versionRange" : "[2.5.6,2.5.6]",
  "severity" : 5.0,
  "cveName" : "CVE-2012-1150",
  "description" : "Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 computes hash values without restricting the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-1150"
}, {
  "versionRange" : "[3.4.0,3.4.6)",
  "severity" : 6.1,
  "cveName" : "CVE-2016-1000110",
  "description" : "The CGIHandler class in Python before 2.7.12 does not protect against the HTTP_PROXY variable name clash in a CGI script, which could allow a remote attacker to redirect HTTP requests.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-1000110"
}, {
  "versionRange" : "[2.5.1,2.5.1]",
  "severity" : 2.6,
  "cveName" : "CVE-2011-4940",
  "description" : "The list_directory function in Lib/SimpleHTTPServer.py in SimpleHTTPServer in Python before 2.5.6c1, 2.6.x before 2.6.7 rc2, and 2.7.x before 2.7.2 does not place a charset parameter in the Content-Type HTTP header, which makes it easier for remote attackers to conduct cross-site scripting (XSS) attacks against Internet Explorer 7 via UTF-7 encoding.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-4940"
}, {
  "versionRange" : "[3.1.3,3.1.3]",
  "severity" : 5.8,
  "cveName" : "CVE-2014-9365",
  "description" : "The HTTP clients in the (1) httplib, (2) urllib, (3) urllib2, and (4) xmlrpclib libraries in CPython (aka Python) 2.x before 2.7.9 and 3.x before 3.4.3, when accessing an HTTPS URL, do not (a) check the certificate against a trust store or verify that the server hostname matches a domain name in the subject's (b) Common Name or (c) subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-9365"
}, {
  "versionRange" : "[3.2.1,3.2.1]",
  "severity" : 7.5,
  "cveName" : "CVE-2014-1912",
  "description" : "Buffer overflow in the socket.recvfrom_into function in Modules/socketmodule.c in Python 2.5 before 2.7.7, 3.x before 3.3.4, and 3.4.x before 3.4rc1 allows remote attackers to execute arbitrary code via a crafted string.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-1912"
}, {
  "versionRange" : "[3.6.0,3.6.6]",
  "severity" : 7.5,
  "cveName" : "CVE-2018-14647",
  "description" : "Python's elementtree C accelerator failed to initialise Expat's hash salt during initialization. This could make it easy to conduct denial of service attacks against Expat by constructing an XML document that would cause pathological hash collisions in Expat's internal data structures, consuming large amounts CPU and RAM. The vulnerability exists in Python versions 3.7.0, 3.6.0 through 3.6.6, 3.5.0 through 3.5.6, 3.4.0 through 3.4.9, 2.7.0 through 2.7.15.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2018-14647"
}, {
  "versionRange" : "[2.1.1,2.1.1]",
  "severity" : 6.4,
  "cveName" : "CVE-2011-1521",
  "description" : "The urllib and urllib2 modules in Python 2.x before 2.7.2 and 3.x before 3.2.1 process Location headers that specify redirection to file: URLs, which makes it easier for remote attackers to obtain sensitive information or cause a denial of service (resource consumption) via a crafted URL, as demonstrated by the file:///etc/passwd and file:///dev/zero URLs.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-1521"
}, {
  "versionRange" : "(,2.7.18]",
  "severity" : 5.3,
  "cveName" : "CVE-2023-27043",
  "description" : "The email module of Python through 3.11.3 incorrectly parses e-mail addresses that contain a special character. The wrong portion of an RFC2822 header is identified as the value of the addr-spec. In some applications, an attacker can bypass a protection mechanism in which application access is granted only after verifying receipt of e-mail to a specific domain (e.g., only @company.example.com addresses may be used for signup). This occurs in email/_parseaddr.py in recent versions of Python.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2023-27043"
}, {
  "versionRange" : "[2.1.1,2.1.1]",
  "severity" : 5.8,
  "cveName" : "CVE-2014-9365",
  "description" : "The HTTP clients in the (1) httplib, (2) urllib, (3) urllib2, and (4) xmlrpclib libraries in CPython (aka Python) 2.x before 2.7.9 and 3.x before 3.4.3, when accessing an HTTPS URL, do not (a) check the certificate against a trust store or verify that the server hostname matches a domain name in the subject's (b) Common Name or (c) subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-9365"
}, {
  "versionRange" : "[3.5.0,3.5.10)",
  "severity" : 7.5,
  "cveName" : "CVE-2019-20907",
  "description" : "In Lib/tarfile.py in Python through 3.8.3, an attacker is able to craft a TAR archive leading to an infinite loop when opened by tarfile.open, because _proc_pax lacks header validation.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2019-20907"
}, {
  "versionRange" : "[2.1.3,2.1.3]",
  "severity" : 2.6,
  "cveName" : "CVE-2011-4940",
  "description" : "The list_directory function in Lib/SimpleHTTPServer.py in SimpleHTTPServer in Python before 2.5.6c1, 2.6.x before 2.6.7 rc2, and 2.7.x before 2.7.2 does not place a charset parameter in the Content-Type HTTP header, which makes it easier for remote attackers to conduct cross-site scripting (XSS) attacks against Internet Explorer 7 via UTF-7 encoding.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-4940"
}, {
  "versionRange" : "[2.5.4,2.5.4]",
  "severity" : 2.6,
  "cveName" : "CVE-2011-4940",
  "description" : "The list_directory function in Lib/SimpleHTTPServer.py in SimpleHTTPServer in Python before 2.5.6c1, 2.6.x before 2.6.7 rc2, and 2.7.x before 2.7.2 does not place a charset parameter in the Content-Type HTTP header, which makes it easier for remote attackers to conduct cross-site scripting (XSS) attacks against Internet Explorer 7 via UTF-7 encoding.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-4940"
}, {
  "versionRange" : "[3.1.1,3.1.1]",
  "severity" : 4.3,
  "cveName" : "CVE-2013-7040",
  "description" : "Python 2.7 before 3.4 only uses the last eight bits of the prefix to randomize hash values, which causes it to compute hash values without restricting the ability to trigger hash collisions predictably and makes it easier for context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2012-1150.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-7040"
}, {
  "versionRange" : "(,2.7.11]",
  "severity" : 9.8,
  "cveName" : "CVE-2016-5636",
  "description" : "Integer overflow in the get_data function in zipimport.c in CPython (aka Python) before 2.7.12, 3.x before 3.4.5, and 3.5.x before 3.5.2 allows remote attackers to have unspecified impact via a negative data size value, which triggers a heap-based buffer overflow.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-5636"
}, {
  "versionRange" : "[3.3.2,3.3.2]",
  "severity" : 5.9,
  "cveName" : "CVE-2013-7440",
  "description" : "The ssl.match_hostname function in CPython (aka Python) before 2.7.9 and 3.x before 3.3.3 does not properly handle wildcards in hostnames, which might allow man-in-the-middle attackers to spoof servers via a crafted certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-7440"
}, {
  "versionRange" : "[3.9.0,3.9.16)",
  "severity" : 9.8,
  "cveName" : "CVE-2022-37454",
  "description" : "The Keccak XKCP SHA-3 reference implementation before fdc6fef has an integer overflow and resultant buffer overflow that allows attackers to execute arbitrary code or eliminate expected cryptographic properties. This occurs in the sponge function interface.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2022-37454"
}, {
  "versionRange" : "[2.7.0,2.7.13)",
  "severity" : 7.5,
  "cveName" : "CVE-2016-2183",
  "description" : "The DES and Triple DES ciphers, as used in the TLS, SSH, and IPSec protocols and other protocols and products, have a birthday bound of approximately four billion blocks, which makes it easier for remote attackers to obtain cleartext data via a birthday attack against a long-duration encrypted session, as demonstrated by an HTTPS session using Triple DES in CBC mode, aka a \"Sweet32\" attack.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-2183"
}, {
  "versionRange" : "[2.2.2,2.2.2]",
  "severity" : 6.4,
  "cveName" : "CVE-2011-1521",
  "description" : "The urllib and urllib2 modules in Python 2.x before 2.7.2 and 3.x before 3.2.1 process Location headers that specify redirection to file: URLs, which makes it easier for remote attackers to obtain sensitive information or cause a denial of service (resource consumption) via a crafted URL, as demonstrated by the file:///etc/passwd and file:///dev/zero URLs.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-1521"
}, {
  "versionRange" : "[3.4.0,3.4.8)",
  "severity" : 9.8,
  "cveName" : "CVE-2017-1000158",
  "description" : "CPython (aka Python) up to 2.7.13 is vulnerable to an integer overflow in the PyString_DecodeEscape function in stringobject.c, resulting in heap-based buffer overflow (and possible arbitrary code execution)",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2017-1000158"
}, {
  "versionRange" : "[3.1.4,3.1.4]",
  "severity" : 5.9,
  "cveName" : "CVE-2013-7440",
  "description" : "The ssl.match_hostname function in CPython (aka Python) before 2.7.9 and 3.x before 3.3.3 does not properly handle wildcards in hostnames, which might allow man-in-the-middle attackers to spoof servers via a crafted certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-7440"
}, {
  "versionRange" : "[2.4.4,2.4.4]",
  "severity" : 6.4,
  "cveName" : "CVE-2011-1521",
  "description" : "The urllib and urllib2 modules in Python 2.x before 2.7.2 and 3.x before 3.2.1 process Location headers that specify redirection to file: URLs, which makes it easier for remote attackers to obtain sensitive information or cause a denial of service (resource consumption) via a crafted URL, as demonstrated by the file:///etc/passwd and file:///dev/zero URLs.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-1521"
}, {
  "versionRange" : "[3.8.0,3.8.5)",
  "severity" : 7.5,
  "cveName" : "CVE-2019-20907",
  "description" : "In Lib/tarfile.py in Python through 3.8.3, an attacker is able to craft a TAR archive leading to an infinite loop when opened by tarfile.open, because _proc_pax lacks header validation.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2019-20907"
}, {
  "versionRange" : "[3.1.1,3.1.1]",
  "severity" : 5.8,
  "cveName" : "CVE-2014-9365",
  "description" : "The HTTP clients in the (1) httplib, (2) urllib, (3) urllib2, and (4) xmlrpclib libraries in CPython (aka Python) 2.x before 2.7.9 and 3.x before 3.4.3, when accessing an HTTPS URL, do not (a) check the certificate against a trust store or verify that the server hostname matches a domain name in the subject's (b) Common Name or (c) subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-9365"
}, {
  "versionRange" : "[3.2.4,3.2.4]",
  "severity" : 7.5,
  "cveName" : "CVE-2014-1912",
  "description" : "Buffer overflow in the socket.recvfrom_into function in Modules/socketmodule.c in Python 2.5 before 2.7.7, 3.x before 3.3.4, and 3.4.x before 3.4rc1 allows remote attackers to execute arbitrary code via a crafted string.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-1912"
}, {
  "versionRange" : "[3.2.5,3.2.5]",
  "severity" : 7.5,
  "cveName" : "CVE-2014-1912",
  "description" : "Buffer overflow in the socket.recvfrom_into function in Modules/socketmodule.c in Python 2.5 before 2.7.7, 3.x before 3.3.4, and 3.4.x before 3.4rc1 allows remote attackers to execute arbitrary code via a crafted string.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-1912"
}, {
  "versionRange" : "[3.3.3,3.3.3]",
  "severity" : 6.1,
  "cveName" : "CVE-2016-5699",
  "description" : "CRLF injection vulnerability in the HTTPConnection.putheader function in urllib2 and urllib in CPython (aka Python) before 2.7.10 and 3.x before 3.4.4 allows remote attackers to inject arbitrary HTTP headers via CRLF sequences in a URL.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-5699"
}, {
  "versionRange" : "[2.6.1,2.6.1]",
  "severity" : 5.8,
  "cveName" : "CVE-2014-9365",
  "description" : "The HTTP clients in the (1) httplib, (2) urllib, (3) urllib2, and (4) xmlrpclib libraries in CPython (aka Python) 2.x before 2.7.9 and 3.x before 3.4.3, when accessing an HTTPS URL, do not (a) check the certificate against a trust store or verify that the server hostname matches a domain name in the subject's (b) Common Name or (c) subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-9365"
}, {
  "versionRange" : "[2.5.3,2.5.3]",
  "severity" : 5.8,
  "cveName" : "CVE-2014-9365",
  "description" : "The HTTP clients in the (1) httplib, (2) urllib, (3) urllib2, and (4) xmlrpclib libraries in CPython (aka Python) 2.x before 2.7.9 and 3.x before 3.4.3, when accessing an HTTPS URL, do not (a) check the certificate against a trust store or verify that the server hostname matches a domain name in the subject's (b) Common Name or (c) subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-9365"
}, {
  "versionRange" : "[3.3.3,3.3.3]",
  "severity" : 9.8,
  "cveName" : "CVE-2016-5636",
  "description" : "Integer overflow in the get_data function in zipimport.c in CPython (aka Python) before 2.7.12, 3.x before 3.4.5, and 3.5.x before 3.5.2 allows remote attackers to have unspecified impact via a negative data size value, which triggers a heap-based buffer overflow.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-5636"
}, {
  "versionRange" : "(,2.5.1]",
  "severity" : 5.8,
  "cveName" : "CVE-2007-4965",
  "description" : "Multiple integer overflows in the imageop module in Python 2.5.1 and earlier allow context-dependent attackers to cause a denial of service (application crash) and possibly obtain sensitive information (memory contents) via crafted arguments to (1) the tovideo method, and unspecified other vectors related to (2) imageop.c, (3) rbgimgmodule.c, and other files, which trigger heap-based buffer overflows.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2007-4965"
}, {
  "versionRange" : "[3.3.2,3.3.2]",
  "severity" : 9.8,
  "cveName" : "CVE-2016-5636",
  "description" : "Integer overflow in the get_data function in zipimport.c in CPython (aka Python) before 2.7.12, 3.x before 3.4.5, and 3.5.x before 3.5.2 allows remote attackers to have unspecified impact via a negative data size value, which triggers a heap-based buffer overflow.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-5636"
}, {
  "versionRange" : "[3.1.0,3.1.3)",
  "severity" : 5.0,
  "cveName" : "CVE-2010-1634",
  "description" : "Multiple integer overflows in audioop.c in the audioop module in Python 2.6, 2.7, 3.1, and 3.2 allow context-dependent attackers to cause a denial of service (application crash) via a large fragment, as demonstrated by a call to audioop.lin2lin with a long string in the first argument, leading to a buffer overflow.  NOTE: this vulnerability exists because of an incorrect fix for CVE-2008-3143.5.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2010-1634"
}, {
  "versionRange" : "[3.9.0,3.9.3)",
  "severity" : 5.7,
  "cveName" : "CVE-2021-3426",
  "description" : "There's a flaw in Python 3's pydoc. A local or adjacent attacker who discovers or is able to convince another local or adjacent user to start a pydoc server could access the server and use it to disclose sensitive information belonging to the other user that they would not normally be able to access. The highest risk of this flaw is to data confidentiality. This flaw affects Python versions before 3.8.9, Python versions before 3.9.3 and Python versions before 3.10.0a7.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2021-3426"
}, {
  "versionRange" : "[3.2.1,3.2.1]",
  "severity" : 4.3,
  "cveName" : "CVE-2013-7040",
  "description" : "Python 2.7 before 3.4 only uses the last eight bits of the prefix to randomize hash values, which causes it to compute hash values without restricting the ability to trigger hash collisions predictably and makes it easier for context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2012-1150.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-7040"
}, {
  "versionRange" : "[3.8.0,3.8.10)",
  "severity" : 6.5,
  "cveName" : "CVE-2021-3733",
  "description" : "There's a flaw in urllib's AbstractBasicAuthHandler class. An attacker who controls a malicious HTTP server that an HTTP client (such as web browser) connects to, could trigger a Regular Expression Denial of Service (ReDOS) during an authentication request with a specially crafted payload that is sent by the server to the client. The greatest threat that this flaw poses is to application availability.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2021-3733"
}, {
  "versionRange" : "[3.9.0,3.9.0]",
  "severity" : 7.8,
  "cveName" : "CVE-2020-15523",
  "description" : "In Python 3.6 through 3.6.10, 3.7 through 3.7.8, 3.8 through 3.8.4rc1, and 3.9 through 3.9.0b4 on Windows, a Trojan horse python3.dll might be used in cases where CPython is embedded in a native application. This occurs because python3X.dll may use an invalid search path for python3.dll loading (after Py_SetPath has been used). NOTE: this issue CANNOT occur when using python.exe from a standard (non-embedded) Python installation on Windows.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2020-15523"
}, {
  "versionRange" : "[2.4.4,2.4.4]",
  "severity" : 5.8,
  "cveName" : "CVE-2014-9365",
  "description" : "The HTTP clients in the (1) httplib, (2) urllib, (3) urllib2, and (4) xmlrpclib libraries in CPython (aka Python) 2.x before 2.7.9 and 3.x before 3.4.3, when accessing an HTTPS URL, do not (a) check the certificate against a trust store or verify that the server hostname matches a domain name in the subject's (b) Common Name or (c) subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-9365"
}, {
  "versionRange" : "[2.2.0,2.2.2)",
  "severity" : 7.5,
  "cveName" : "CVE-2004-0150",
  "description" : "Buffer overflow in the getaddrinfo function in Python 2.2 before 2.2.2, when IPv6 support is disabled, allows remote attackers to execute arbitrary code via an IPv6 address that is obtained using DNS.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2004-0150"
}, {
  "versionRange" : "[2.6.5,2.6.5]",
  "severity" : 5.0,
  "cveName" : "CVE-2012-1150",
  "description" : "Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 computes hash values without restricting the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-1150"
}, {
  "versionRange" : "[3.11.0,3.11.0]",
  "severity" : 7.5,
  "cveName" : "CVE-2022-45061",
  "description" : "An issue was discovered in Python before 3.11.1. An unnecessary quadratic algorithm exists in one path when processing some inputs to the IDNA (RFC 3490) decoder, such that a crafted, unreasonably long name being presented to the decoder could lead to a CPU denial of service. Hostnames are often supplied by remote servers that could be controlled by a malicious actor; in such a scenario, they could trigger excessive CPU consumption on the client attempting to make use of an attacker-supplied supposed hostname. For example, the attack payload could be placed in the Location header of an HTTP response with status code 302. A fix is planned in 3.11.1, 3.10.9, 3.9.16, 3.8.16, and 3.7.16.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2022-45061"
}, {
  "versionRange" : "[3.7.0,3.7.9)",
  "severity" : 7.8,
  "cveName" : "CVE-2020-15523",
  "description" : "In Python 3.6 through 3.6.10, 3.7 through 3.7.8, 3.8 through 3.8.4rc1, and 3.9 through 3.9.0b4 on Windows, a Trojan horse python3.dll might be used in cases where CPython is embedded in a native application. This occurs because python3X.dll may use an invalid search path for python3.dll loading (after Py_SetPath has been used). NOTE: this issue CANNOT occur when using python.exe from a standard (non-embedded) Python installation on Windows.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2020-15523"
}, {
  "versionRange" : "[2.4.6,2.4.6]",
  "severity" : 5.8,
  "cveName" : "CVE-2014-9365",
  "description" : "The HTTP clients in the (1) httplib, (2) urllib, (3) urllib2, and (4) xmlrpclib libraries in CPython (aka Python) 2.x before 2.7.9 and 3.x before 3.4.3, when accessing an HTTPS URL, do not (a) check the certificate against a trust store or verify that the server hostname matches a domain name in the subject's (b) Common Name or (c) subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-9365"
}, {
  "versionRange" : "[2.5.1,2.5.1]",
  "severity" : 5.8,
  "cveName" : "CVE-2014-9365",
  "description" : "The HTTP clients in the (1) httplib, (2) urllib, (3) urllib2, and (4) xmlrpclib libraries in CPython (aka Python) 2.x before 2.7.9 and 3.x before 3.4.3, when accessing an HTTPS URL, do not (a) check the certificate against a trust store or verify that the server hostname matches a domain name in the subject's (b) Common Name or (c) subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-9365"
}, {
  "versionRange" : "(,2.5.2]",
  "severity" : 7.5,
  "cveName" : "CVE-2008-2316",
  "description" : "Integer overflow in _hashopenssl.c in the hashlib module in Python 2.5.2 and earlier might allow context-dependent attackers to defeat cryptographic digests, related to \"partial hashlib hashing of data exceeding 4GB.\"",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2008-2316"
}, {
  "versionRange" : "[2.2.3,2.2.3]",
  "severity" : 5.0,
  "cveName" : "CVE-2012-0845",
  "description" : "SimpleXMLRPCServer.py in SimpleXMLRPCServer in Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 allows remote attackers to cause a denial of service (infinite loop and CPU consumption) via an XML-RPC POST request that contains a smaller amount of data than specified by the Content-Length header.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-0845"
}, {
  "versionRange" : "[2.6.3,2.6.3]",
  "severity" : 5.8,
  "cveName" : "CVE-2014-9365",
  "description" : "The HTTP clients in the (1) httplib, (2) urllib, (3) urllib2, and (4) xmlrpclib libraries in CPython (aka Python) 2.x before 2.7.9 and 3.x before 3.4.3, when accessing an HTTPS URL, do not (a) check the certificate against a trust store or verify that the server hostname matches a domain name in the subject's (b) Common Name or (c) subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-9365"
}, {
  "versionRange" : "[3.2.6,3.2.6]",
  "severity" : 6.1,
  "cveName" : "CVE-2016-5699",
  "description" : "CRLF injection vulnerability in the HTTPConnection.putheader function in urllib2 and urllib in CPython (aka Python) before 2.7.10 and 3.x before 3.4.4 allows remote attackers to inject arbitrary HTTP headers via CRLF sequences in a URL.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-5699"
}, {
  "versionRange" : "(,3.6.16)",
  "severity" : 6.8,
  "cveName" : "CVE-2007-4559",
  "description" : "Directory traversal vulnerability in the (1) extract and (2) extractall functions in the tarfile module in Python allows user-assisted remote attackers to overwrite arbitrary files via a .. (dot dot) sequence in filenames in a TAR archive, a related issue to CVE-2001-1267.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2007-4559"
}, {
  "versionRange" : "[3.5.0,3.5.2)",
  "severity" : 6.8,
  "cveName" : "CVE-2015-1283",
  "description" : "Multiple integer overflows in the XML_GetBuffer function in Expat through 2.1.0, as used in Google Chrome before 44.0.2403.89 and other products, allow remote attackers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact via crafted XML data, a related issue to CVE-2015-2716.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2015-1283"
}, {
  "versionRange" : "[3.7.0,3.7.9)",
  "severity" : 7.2,
  "cveName" : "CVE-2020-26116",
  "description" : "http.client in Python 3.x before 3.5.10, 3.6.x before 3.6.12, 3.7.x before 3.7.9, and 3.8.x before 3.8.5 allows CRLF injection if the attacker controls the HTTP request method, as demonstrated by inserting CR and LF control characters in the first argument of HTTPConnection.request.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2020-26116"
}, {
  "versionRange" : "[2.1.2,2.1.2]",
  "severity" : 5.0,
  "cveName" : "CVE-2012-1150",
  "description" : "Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 computes hash values without restricting the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-1150"
}, {
  "versionRange" : "[2.3.4,2.3.4]",
  "severity" : 5.8,
  "cveName" : "CVE-2014-9365",
  "description" : "The HTTP clients in the (1) httplib, (2) urllib, (3) urllib2, and (4) xmlrpclib libraries in CPython (aka Python) 2.x before 2.7.9 and 3.x before 3.4.3, when accessing an HTTPS URL, do not (a) check the certificate against a trust store or verify that the server hostname matches a domain name in the subject's (b) Common Name or (c) subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-9365"
}, {
  "versionRange" : "[2.7.2,2.7.2]",
  "severity" : 5.8,
  "cveName" : "CVE-2014-9365",
  "description" : "The HTTP clients in the (1) httplib, (2) urllib, (3) urllib2, and (4) xmlrpclib libraries in CPython (aka Python) 2.x before 2.7.9 and 3.x before 3.4.3, when accessing an HTTPS URL, do not (a) check the certificate against a trust store or verify that the server hostname matches a domain name in the subject's (b) Common Name or (c) subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-9365"
}, {
  "versionRange" : "[3.11.0,3.11.4)",
  "severity" : 7.5,
  "cveName" : "CVE-2023-24329",
  "description" : "An issue in the urllib.parse component of Python before 3.11.4 allows attackers to bypass blocklisting methods by supplying a URL that starts with blank characters.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2023-24329"
}, {
  "versionRange" : "[2.4.1,2.4.1]",
  "severity" : 5.0,
  "cveName" : "CVE-2012-0845",
  "description" : "SimpleXMLRPCServer.py in SimpleXMLRPCServer in Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 allows remote attackers to cause a denial of service (infinite loop and CPU consumption) via an XML-RPC POST request that contains a smaller amount of data than specified by the Content-Length header.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-0845"
}, {
  "versionRange" : "[3.9.0,3.9.5)",
  "severity" : 7.5,
  "cveName" : "CVE-2022-0391",
  "description" : "A flaw was found in Python, specifically within the urllib.parse module. This module helps break Uniform Resource Locator (URL) strings into components. The issue involves how the urlparse method does not sanitize input and allows characters like '\\r' and '\\n' in the URL path. This flaw allows an attacker to input a crafted URL, leading to injection attacks. This flaw affects Python versions prior to 3.10.0b1, 3.9.5, 3.8.11, 3.7.11 and 3.6.14.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2022-0391"
}, {
  "versionRange" : "[2.4.0,2.4.4)",
  "severity" : 7.5,
  "cveName" : "CVE-2006-4980",
  "description" : "Buffer overflow in the repr function in Python 2.3 through 2.6 before 20060822 allows context-dependent attackers to cause a denial of service and possibly execute arbitrary code via crafted wide character UTF-32/UCS-4 strings to certain scripts.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2006-4980"
}, {
  "versionRange" : "[2.4.2,2.4.2]",
  "severity" : 5.8,
  "cveName" : "CVE-2014-9365",
  "description" : "The HTTP clients in the (1) httplib, (2) urllib, (3) urllib2, and (4) xmlrpclib libraries in CPython (aka Python) 2.x before 2.7.9 and 3.x before 3.4.3, when accessing an HTTPS URL, do not (a) check the certificate against a trust store or verify that the server hostname matches a domain name in the subject's (b) Common Name or (c) subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-9365"
}, {
  "versionRange" : "[2.7.0,2.7.17)",
  "severity" : 9.8,
  "cveName" : "CVE-2019-10160",
  "description" : "A security regression of CVE-2019-9636 was discovered in python since commit d537ab0ff9767ef024f26246899728f0116b1ec3 affecting versions 2.7, 3.5, 3.6, 3.7 and from v3.8.0a4 through v3.8.0b1, which still allows an attacker to exploit CVE-2019-9636 by abusing the user and password parts of a URL. When an application parses user-supplied URLs to store cookies, authentication credentials, or other kind of information, it is possible for an attacker to provide specially crafted URLs to make the application locate host-related information (e.g. cookies, authentication data) and send them to a different host than where it should, unlike if the URLs had been correctly parsed. The result of an attack may vary based on the application.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2019-10160"
}, {
  "versionRange" : "[3.10.0,3.10.8]",
  "severity" : 7.5,
  "cveName" : "CVE-2022-45061",
  "description" : "An issue was discovered in Python before 3.11.1. An unnecessary quadratic algorithm exists in one path when processing some inputs to the IDNA (RFC 3490) decoder, such that a crafted, unreasonably long name being presented to the decoder could lead to a CPU denial of service. Hostnames are often supplied by remote servers that could be controlled by a malicious actor; in such a scenario, they could trigger excessive CPU consumption on the client attempting to make use of an attacker-supplied supposed hostname. For example, the attack payload could be placed in the Location header of an HTTP response with status code 302. A fix is planned in 3.11.1, 3.10.9, 3.9.16, 3.8.16, and 3.7.16.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2022-45061"
}, {
  "versionRange" : "[3.0.0,3.4.9)",
  "severity" : 7.5,
  "cveName" : "CVE-2018-1060",
  "description" : "python before versions 2.7.15, 3.4.9, 3.5.6rc1, 3.6.5rc1 and 3.7.0 is vulnerable to catastrophic backtracking in pop3lib's apop() method. An attacker could use this flaw to cause denial of service.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2018-1060"
}, {
  "versionRange" : "[3.4.0,3.4.5)",
  "severity" : 6.8,
  "cveName" : "CVE-2015-1283",
  "description" : "Multiple integer overflows in the XML_GetBuffer function in Expat through 2.1.0, as used in Google Chrome before 44.0.2403.89 and other products, allow remote attackers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact via crafted XML data, a related issue to CVE-2015-2716.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2015-1283"
}, {
  "versionRange" : "[3.9.0,3.9.6)",
  "severity" : 7.5,
  "cveName" : "CVE-2021-3737",
  "description" : "A flaw was found in python. An improperly handled HTTP response in the HTTP client code of python may allow a remote attacker, who controls the HTTP server, to make the client script enter an infinite loop, consuming CPU time. The highest threat from this vulnerability is to system availability.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2021-3737"
}, {
  "versionRange" : "[2.7.0,2.7.4)",
  "severity" : 6.4,
  "cveName" : "CVE-2012-2135",
  "description" : "The utf-16 decoder in Python 3.1 through 3.3 does not update the aligned_end variable after calling the unicode_decode_call_errorhandler function, which allows remote attackers to obtain sensitive information (process memory) or cause a denial of service (memory corruption and crash) via unspecified vectors.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-2135"
}, {
  "versionRange" : "[2.6.5,2.6.5]",
  "severity" : 5.8,
  "cveName" : "CVE-2014-9365",
  "description" : "The HTTP clients in the (1) httplib, (2) urllib, (3) urllib2, and (4) xmlrpclib libraries in CPython (aka Python) 2.x before 2.7.9 and 3.x before 3.4.3, when accessing an HTTPS URL, do not (a) check the certificate against a trust store or verify that the server hostname matches a domain name in the subject's (b) Common Name or (c) subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-9365"
}, {
  "versionRange" : "[2.2.3,2.2.3]",
  "severity" : 2.6,
  "cveName" : "CVE-2011-4940",
  "description" : "The list_directory function in Lib/SimpleHTTPServer.py in SimpleHTTPServer in Python before 2.5.6c1, 2.6.x before 2.6.7 rc2, and 2.7.x before 2.7.2 does not place a charset parameter in the Content-Type HTTP header, which makes it easier for remote attackers to conduct cross-site scripting (XSS) attacks against Internet Explorer 7 via UTF-7 encoding.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-4940"
}, {
  "versionRange" : "[2.7.4,2.7.4]",
  "severity" : 5.8,
  "cveName" : "CVE-2014-9365",
  "description" : "The HTTP clients in the (1) httplib, (2) urllib, (3) urllib2, and (4) xmlrpclib libraries in CPython (aka Python) 2.x before 2.7.9 and 3.x before 3.4.3, when accessing an HTTPS URL, do not (a) check the certificate against a trust store or verify that the server hostname matches a domain name in the subject's (b) Common Name or (c) subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-9365"
}, {
  "versionRange" : "[3.3.6,3.3.6]",
  "severity" : 3.3,
  "cveName" : "CVE-2014-2667",
  "description" : "Race condition in the _get_masked_mode function in Lib/os.py in Python 3.2 through 3.5, when exist_ok is set to true and multiple threads are used, might allow local users to bypass intended file permissions by leveraging a separate application vulnerability before the umask has been set to the expected value.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-2667"
}, {
  "versionRange" : "[2.3.2,2.3.2]",
  "severity" : 5.8,
  "cveName" : "CVE-2014-9365",
  "description" : "The HTTP clients in the (1) httplib, (2) urllib, (3) urllib2, and (4) xmlrpclib libraries in CPython (aka Python) 2.x before 2.7.9 and 3.x before 3.4.3, when accessing an HTTPS URL, do not (a) check the certificate against a trust store or verify that the server hostname matches a domain name in the subject's (b) Common Name or (c) subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-9365"
}, {
  "versionRange" : "[3.3.3,3.3.3]",
  "severity" : 5.8,
  "cveName" : "CVE-2014-9365",
  "description" : "The HTTP clients in the (1) httplib, (2) urllib, (3) urllib2, and (4) xmlrpclib libraries in CPython (aka Python) 2.x before 2.7.9 and 3.x before 3.4.3, when accessing an HTTPS URL, do not (a) check the certificate against a trust store or verify that the server hostname matches a domain name in the subject's (b) Common Name or (c) subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-9365"
}, {
  "versionRange" : "[3.7.0,3.7.15]",
  "severity" : 7.6,
  "cveName" : "CVE-2015-20107",
  "description" : "In Python (aka CPython) up to 3.10.8, the mailcap module does not add escape characters into commands discovered in the system mailcap file. This may allow attackers to inject shell commands into applications that call mailcap.findmatch with untrusted input (if they lack validation of user-provided filenames or arguments). The fix is also back-ported to 3.7, 3.8, 3.9",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2015-20107"
}, {
  "versionRange" : "[2.2.3,2.2.3]",
  "severity" : 10.0,
  "cveName" : "CVE-2008-5031",
  "description" : "Multiple integer overflows in Python 2.2.3 through 2.5.1, and 2.6, allow context-dependent attackers to have an unknown impact via a large integer value in the tabsize argument to the expandtabs method, as implemented by (1) the string_expandtabs function in Objects/stringobject.c and (2) the unicode_expandtabs function in Objects/unicodeobject.c.  NOTE: this vulnerability reportedly exists because of an incomplete fix for CVE-2008-2315.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2008-5031"
}, {
  "versionRange" : "[2.1.3,2.1.3]",
  "severity" : 6.4,
  "cveName" : "CVE-2011-1521",
  "description" : "The urllib and urllib2 modules in Python 2.x before 2.7.2 and 3.x before 3.2.1 process Location headers that specify redirection to file: URLs, which makes it easier for remote attackers to obtain sensitive information or cause a denial of service (resource consumption) via a crafted URL, as demonstrated by the file:///etc/passwd and file:///dev/zero URLs.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-1521"
}, {
  "versionRange" : "[3.4.1,3.4.1]",
  "severity" : 5.8,
  "cveName" : "CVE-2014-9365",
  "description" : "The HTTP clients in the (1) httplib, (2) urllib, (3) urllib2, and (4) xmlrpclib libraries in CPython (aka Python) 2.x before 2.7.9 and 3.x before 3.4.3, when accessing an HTTPS URL, do not (a) check the certificate against a trust store or verify that the server hostname matches a domain name in the subject's (b) Common Name or (c) subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-9365"
}, {
  "versionRange" : "[2.2.3,2.2.3]",
  "severity" : 5.8,
  "cveName" : "CVE-2014-9365",
  "description" : "The HTTP clients in the (1) httplib, (2) urllib, (3) urllib2, and (4) xmlrpclib libraries in CPython (aka Python) 2.x before 2.7.9 and 3.x before 3.4.3, when accessing an HTTPS URL, do not (a) check the certificate against a trust store or verify that the server hostname matches a domain name in the subject's (b) Common Name or (c) subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-9365"
}, {
  "versionRange" : "[3.0,3.5.10)",
  "severity" : 6.1,
  "cveName" : "CVE-2019-18348",
  "description" : "An issue was discovered in urllib2 in Python 2.x through 2.7.17 and urllib in Python 3.x through 3.8.0. CRLF injection is possible if the attacker controls a url parameter, as demonstrated by the first argument to urllib.request.urlopen with \\r\\n (specifically in the host component of a URL) followed by an HTTP header. This is similar to the CVE-2019-9740 query string issue and the CVE-2019-9947 path string issue. (This is not exploitable when glibc has CVE-2016-10739 fixed.). This is fixed in: v2.7.18, v2.7.18rc1; v3.5.10, v3.5.10rc1; v3.6.11, v3.6.11rc1, v3.6.12; v3.7.8, v3.7.8rc1, v3.7.9; v3.8.3, v3.8.3rc1, v3.8.4, v3.8.4rc1, v3.8.5, v3.8.6, v3.8.6rc1.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2019-18348"
}, {
  "versionRange" : "[3.2.4,3.2.4]",
  "severity" : 5.8,
  "cveName" : "CVE-2014-9365",
  "description" : "The HTTP clients in the (1) httplib, (2) urllib, (3) urllib2, and (4) xmlrpclib libraries in CPython (aka Python) 2.x before 2.7.9 and 3.x before 3.4.3, when accessing an HTTPS URL, do not (a) check the certificate against a trust store or verify that the server hostname matches a domain name in the subject's (b) Common Name or (c) subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-9365"
}, {
  "versionRange" : "[2.7.0,2.7.3)",
  "severity" : 4.3,
  "cveName" : "CVE-2012-0876",
  "description" : "The XML parser (xmlparse.c) in expat before 2.1.0 computes hash values without restricting the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via an XML file with many identifiers with the same value.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-0876"
}, {
  "versionRange" : "[3.8.0,3.8.0]",
  "severity" : 9.8,
  "cveName" : "CVE-2019-10160",
  "description" : "A security regression of CVE-2019-9636 was discovered in python since commit d537ab0ff9767ef024f26246899728f0116b1ec3 affecting versions 2.7, 3.5, 3.6, 3.7 and from v3.8.0a4 through v3.8.0b1, which still allows an attacker to exploit CVE-2019-9636 by abusing the user and password parts of a URL. When an application parses user-supplied URLs to store cookies, authentication credentials, or other kind of information, it is possible for an attacker to provide specially crafted URLs to make the application locate host-related information (e.g. cookies, authentication data) and send them to a different host than where it should, unlike if the URLs had been correctly parsed. The result of an attack may vary based on the application.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2019-10160"
}, {
  "versionRange" : "[2.0,2.7.17)",
  "severity" : 9.1,
  "cveName" : "CVE-2019-9948",
  "description" : "urllib in Python 2.x through 2.7.16 supports the local_file: scheme, which makes it easier for remote attackers to bypass protection mechanisms that blacklist file: URIs, as demonstrated by triggering a urllib.urlopen('local_file:///etc/passwd') call.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2019-9948"
}, {
  "versionRange" : "(,3.6.4]",
  "severity" : 6.5,
  "cveName" : "CVE-2017-18207",
  "description" : "The Wave_read._read_fmt_chunk function in Lib/wave.py in Python through 3.6.4 does not ensure a nonzero channel value, which allows attackers to cause a denial of service (divide-by-zero and exception) via a crafted wav format audio file. NOTE: the vendor disputes this issue because Python applications \"need to be prepared to handle a wide variety of exceptions.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2017-18207"
}, {
  "versionRange" : "[3.2.1,3.2.1]",
  "severity" : 4.3,
  "cveName" : "CVE-2013-2099",
  "description" : "Algorithmic complexity vulnerability in the ssl.match_hostname function in Python 3.2.x, 3.3.x, and earlier, and unspecified versions of python-backports-ssl_match_hostname as used for older Python versions, allows remote attackers to cause a denial of service (CPU consumption) via multiple wildcard characters in the common name in a certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-2099"
}, {
  "versionRange" : "[3.7.0,3.7.4]",
  "severity" : 7.5,
  "cveName" : "CVE-2019-16056",
  "description" : "An issue was discovered in Python through 2.7.16, 3.x through 3.5.7, 3.6.x through 3.6.9, and 3.7.x through 3.7.4. The email module wrongly parses email addresses that contain multiple @ characters. An application that uses the email module and implements some kind of checks on the From/To headers of a message could be tricked into accepting an email address that should be denied. An attack may be the same as in CVE-2019-11340; however, this CVE applies to Python more generally.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2019-16056"
}, {
  "versionRange" : "(,2.4.6)",
  "severity" : 7.5,
  "cveName" : "CVE-2008-3142",
  "description" : "Multiple buffer overflows in Python 2.5.2 and earlier on 32bit platforms allow context-dependent attackers to cause a denial of service (crash) or have unspecified other impact via a long string that leads to incorrect memory allocation during Unicode string processing, related to the unicode_resize function and the PyMem_RESIZE macro.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2008-3142"
}, {
  "versionRange" : "[3.11.0,3.11.0]",
  "severity" : 7.5,
  "cveName" : "CVE-2020-10735",
  "description" : "A flaw was found in python. In algorithms with quadratic time complexity using non-binary bases, when using int(\"text\"), a system could take 50ms to parse an int string with 100,000 digits and 5s for 1,000,000 digits (float, decimal, int.from_bytes(), and int() for binary bases 2, 4, 8, 16, and 32 are not affected). The highest threat from this vulnerability is to system availability.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2020-10735"
}, {
  "versionRange" : "[3.2.6,3.2.6]",
  "severity" : 5.9,
  "cveName" : "CVE-2013-7440",
  "description" : "The ssl.match_hostname function in CPython (aka Python) before 2.7.9 and 3.x before 3.3.3 does not properly handle wildcards in hostnames, which might allow man-in-the-middle attackers to spoof servers via a crafted certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-7440"
}, {
  "versionRange" : "[3.2.4,3.2.4]",
  "severity" : 4.3,
  "cveName" : "CVE-2013-2099",
  "description" : "Algorithmic complexity vulnerability in the ssl.match_hostname function in Python 3.2.x, 3.3.x, and earlier, and unspecified versions of python-backports-ssl_match_hostname as used for older Python versions, allows remote attackers to cause a denial of service (CPU consumption) via multiple wildcard characters in the common name in a certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-2099"
}, {
  "versionRange" : "[3.7.0,3.7.4)",
  "severity" : 6.1,
  "cveName" : "CVE-2019-9740",
  "description" : "An issue was discovered in urllib2 in Python 2.x through 2.7.16 and urllib in Python 3.x through 3.7.3. CRLF injection is possible if the attacker controls a url parameter, as demonstrated by the first argument to urllib.request.urlopen with \\r\\n (specifically in the query string after a ? character) followed by an HTTP header or a Redis command. This is fixed in: v2.7.17, v2.7.17rc1, v2.7.18, v2.7.18rc1; v3.5.10, v3.5.10rc1, v3.5.8, v3.5.8rc1, v3.5.8rc2, v3.5.9; v3.6.10, v3.6.10rc1, v3.6.11, v3.6.11rc1, v3.6.12, v3.6.9, v3.6.9rc1; v3.7.4, v3.7.4rc1, v3.7.4rc2, v3.7.5, v3.7.5rc1, v3.7.6, v3.7.6rc1, v3.7.7, v3.7.7rc1, v3.7.8, v3.7.8rc1, v3.7.9.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2019-9740"
}, {
  "versionRange" : "[3.1.3,3.1.3]",
  "severity" : 4.3,
  "cveName" : "CVE-2013-4238",
  "description" : "The ssl.match_hostname function in the SSL module in Python 2.6 through 3.4 does not properly handle a '\\0' character in a domain name in the Subject Alternative Name field of an X.509 certificate, which allows man-in-the-middle attackers to spoof arbitrary SSL servers via a crafted certificate issued by a legitimate Certification Authority, a related issue to CVE-2009-2408.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-4238"
}, {
  "versionRange" : "[3.5.0,3.5.7]",
  "severity" : 7.5,
  "cveName" : "CVE-2019-16056",
  "description" : "An issue was discovered in Python through 2.7.16, 3.x through 3.5.7, 3.6.x through 3.6.9, and 3.7.x through 3.7.4. The email module wrongly parses email addresses that contain multiple @ characters. An application that uses the email module and implements some kind of checks on the From/To headers of a message could be tricked into accepting an email address that should be denied. An attack may be the same as in CVE-2019-11340; however, this CVE applies to Python more generally.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2019-16056"
}, {
  "versionRange" : "[2.7.0,2.7.17]",
  "severity" : 6.5,
  "cveName" : "CVE-2020-8492",
  "description" : "Python 2.7 through 2.7.17, 3.5 through 3.5.9, 3.6 through 3.6.10, 3.7 through 3.7.6, and 3.8 through 3.8.1 allows an HTTP server to conduct Regular Expression Denial of Service (ReDoS) attacks against a client because of urllib.request.AbstractBasicAuthHandler catastrophic backtracking.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2020-8492"
}, {
  "versionRange" : "[3.3.5,3.3.5]",
  "severity" : 6.1,
  "cveName" : "CVE-2016-5699",
  "description" : "CRLF injection vulnerability in the HTTPConnection.putheader function in urllib2 and urllib in CPython (aka Python) before 2.7.10 and 3.x before 3.4.4 allows remote attackers to inject arbitrary HTTP headers via CRLF sequences in a URL.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-5699"
}, {
  "versionRange" : "[3.6.0,3.6.12]",
  "severity" : 9.8,
  "cveName" : "CVE-2021-3177",
  "description" : "Python 3.x through 3.9.1 has a buffer overflow in PyCArg_repr in _ctypes/callproc.c, which may lead to remote code execution in certain Python applications that accept floating-point numbers as untrusted input, as demonstrated by a 1e300 argument to c_double.from_param. This occurs because sprintf is used unsafely.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2021-3177"
}, {
  "versionRange" : "[2.3.2,2.3.2]",
  "severity" : 6.4,
  "cveName" : "CVE-2011-1521",
  "description" : "The urllib and urllib2 modules in Python 2.x before 2.7.2 and 3.x before 3.2.1 process Location headers that specify redirection to file: URLs, which makes it easier for remote attackers to obtain sensitive information or cause a denial of service (resource consumption) via a crafted URL, as demonstrated by the file:///etc/passwd and file:///dev/zero URLs.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-1521"
}, {
  "versionRange" : "[3.10.0,3.10.12)",
  "severity" : 6.8,
  "cveName" : "CVE-2007-4559",
  "description" : "Directory traversal vulnerability in the (1) extract and (2) extractall functions in the tarfile module in Python allows user-assisted remote attackers to overwrite arbitrary files via a .. (dot dot) sequence in filenames in a TAR archive, a related issue to CVE-2001-1267.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2007-4559"
}, {
  "versionRange" : "[3.0,3.11]",
  "severity" : 5.3,
  "cveName" : "CVE-2023-27043",
  "description" : "The email module of Python through 3.11.3 incorrectly parses e-mail addresses that contain a special character. The wrong portion of an RFC2822 header is identified as the value of the addr-spec. In some applications, an attacker can bypass a protection mechanism in which application access is granted only after verifying receipt of e-mail to a specific domain (e.g., only @company.example.com addresses may be used for signup). This occurs in email/_parseaddr.py in recent versions of Python.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2023-27043"
}, {
  "versionRange" : "[3.8.0,3.8.12]",
  "severity" : 7.0,
  "cveName" : "CVE-2022-26488",
  "description" : "In Python before 3.10.3 on Windows, local users can gain privileges because the search path is inadequately secured. The installer may allow a local attacker to add user-writable directories to the system search path. To exploit, an administrator must have installed Python for all users and enabled PATH entries. A non-administrative user can trigger a repair that incorrectly adds user-writable paths into PATH, enabling search-path hijacking of other users and system services. This affects Python (CPython) through 3.7.12, 3.8.x through 3.8.12, 3.9.x through 3.9.10, and 3.10.x through 3.10.2.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2022-26488"
}, {
  "versionRange" : "[3.2.6,3.2.6]",
  "severity" : 5.8,
  "cveName" : "CVE-2014-9365",
  "description" : "The HTTP clients in the (1) httplib, (2) urllib, (3) urllib2, and (4) xmlrpclib libraries in CPython (aka Python) 2.x before 2.7.9 and 3.x before 3.4.3, when accessing an HTTPS URL, do not (a) check the certificate against a trust store or verify that the server hostname matches a domain name in the subject's (b) Common Name or (c) subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-9365"
}, {
  "versionRange" : "[3.3.0,3.3.0]",
  "severity" : 6.1,
  "cveName" : "CVE-2016-5699",
  "description" : "CRLF injection vulnerability in the HTTPConnection.putheader function in urllib2 and urllib in CPython (aka Python) before 2.7.10 and 3.x before 3.4.4 allows remote attackers to inject arbitrary HTTP headers via CRLF sequences in a URL.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-5699"
}, {
  "versionRange" : "[2.4.3,2.4.3]",
  "severity" : 2.6,
  "cveName" : "CVE-2011-4940",
  "description" : "The list_directory function in Lib/SimpleHTTPServer.py in SimpleHTTPServer in Python before 2.5.6c1, 2.6.x before 2.6.7 rc2, and 2.7.x before 2.7.2 does not place a charset parameter in the Content-Type HTTP header, which makes it easier for remote attackers to conduct cross-site scripting (XSS) attacks against Internet Explorer 7 via UTF-7 encoding.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-4940"
}, {
  "versionRange" : "[3.3.1,3.3.1]",
  "severity" : 5.9,
  "cveName" : "CVE-2013-7440",
  "description" : "The ssl.match_hostname function in CPython (aka Python) before 2.7.9 and 3.x before 3.3.3 does not properly handle wildcards in hostnames, which might allow man-in-the-middle attackers to spoof servers via a crafted certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-7440"
}, {
  "versionRange" : "[3.3.2,3.3.2]",
  "severity" : 7.5,
  "cveName" : "CVE-2014-1912",
  "description" : "Buffer overflow in the socket.recvfrom_into function in Modules/socketmodule.c in Python 2.5 before 2.7.7, 3.x before 3.3.4, and 3.4.x before 3.4rc1 allows remote attackers to execute arbitrary code via a crafted string.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-1912"
}, {
  "versionRange" : "[3.3.5,3.3.5]",
  "severity" : 5.8,
  "cveName" : "CVE-2014-9365",
  "description" : "The HTTP clients in the (1) httplib, (2) urllib, (3) urllib2, and (4) xmlrpclib libraries in CPython (aka Python) 2.x before 2.7.9 and 3.x before 3.4.3, when accessing an HTTPS URL, do not (a) check the certificate against a trust store or verify that the server hostname matches a domain name in the subject's (b) Common Name or (c) subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-9365"
}, {
  "versionRange" : "[3.7.0,3.7.10)",
  "severity" : 9.8,
  "cveName" : "CVE-2020-27619",
  "description" : "In Python 3 through 3.9.0, the Lib/test/multibytecodec_support.py CJK codec tests call eval() on content retrieved via HTTP.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2020-27619"
}, {
  "versionRange" : "(,2.3.6)",
  "severity" : 7.5,
  "cveName" : "CVE-2006-4980",
  "description" : "Buffer overflow in the repr function in Python 2.3 through 2.6 before 20060822 allows context-dependent attackers to cause a denial of service and possibly execute arbitrary code via crafted wide character UTF-32/UCS-4 strings to certain scripts.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2006-4980"
}, {
  "versionRange" : "[3.0.1,3.0.1]",
  "severity" : 9.8,
  "cveName" : "CVE-2016-5636",
  "description" : "Integer overflow in the get_data function in zipimport.c in CPython (aka Python) before 2.7.12, 3.x before 3.4.5, and 3.5.x before 3.5.2 allows remote attackers to have unspecified impact via a negative data size value, which triggers a heap-based buffer overflow.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-5636"
}, {
  "versionRange" : "[3.6.0,3.6.15)",
  "severity" : 6.8,
  "cveName" : "CVE-2013-0340",
  "description" : "expat 2.1.0 and earlier does not properly handle entities expansion unless an application developer uses the XML_SetEntityDeclHandler function, which allows remote attackers to cause a denial of service (resource consumption), send HTTP requests to intranet servers, or read arbitrary files via a crafted XML document, aka an XML External Entity (XXE) issue.  NOTE: it could be argued that because expat already provides the ability to disable external entity expansion, the responsibility for resolving this issue lies with application developers; according to this argument, this entry should be REJECTed, and each affected application would need its own CVE.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-0340"
}, {
  "versionRange" : "(,3.6.13)",
  "severity" : 5.9,
  "cveName" : "CVE-2022-48566",
  "description" : "An issue was discovered in compare_digest in Lib/hmac.py in Python through 3.9.1. Constant-time-defeating optimisations were possible in the accumulator variable in hmac.compare_digest.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2022-48566"
}, {
  "versionRange" : "[2.3.3,2.3.3]",
  "severity" : 5.0,
  "cveName" : "CVE-2012-0845",
  "description" : "SimpleXMLRPCServer.py in SimpleXMLRPCServer in Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 allows remote attackers to cause a denial of service (infinite loop and CPU consumption) via an XML-RPC POST request that contains a smaller amount of data than specified by the Content-Length header.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-0845"
}, {
  "versionRange" : "[3.1.1,3.1.1]",
  "severity" : 5.0,
  "cveName" : "CVE-2012-0845",
  "description" : "SimpleXMLRPCServer.py in SimpleXMLRPCServer in Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 allows remote attackers to cause a denial of service (infinite loop and CPU consumption) via an XML-RPC POST request that contains a smaller amount of data than specified by the Content-Length header.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-0845"
}, {
  "versionRange" : "[3.2.2,3.2.2]",
  "severity" : 3.3,
  "cveName" : "CVE-2014-2667",
  "description" : "Race condition in the _get_masked_mode function in Lib/os.py in Python 3.2 through 3.5, when exist_ok is set to true and multiple threads are used, might allow local users to bypass intended file permissions by leveraging a separate application vulnerability before the umask has been set to the expected value.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-2667"
}, {
  "versionRange" : "[3.1.2,3.1.2]",
  "severity" : 5.0,
  "cveName" : "CVE-2012-1150",
  "description" : "Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 computes hash values without restricting the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-1150"
}, {
  "versionRange" : "[3.8.0,3.8.4)",
  "severity" : 7.8,
  "cveName" : "CVE-2020-15523",
  "description" : "In Python 3.6 through 3.6.10, 3.7 through 3.7.8, 3.8 through 3.8.4rc1, and 3.9 through 3.9.0b4 on Windows, a Trojan horse python3.dll might be used in cases where CPython is embedded in a native application. This occurs because python3X.dll may use an invalid search path for python3.dll loading (after Py_SetPath has been used). NOTE: this issue CANNOT occur when using python.exe from a standard (non-embedded) Python installation on Windows.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2020-15523"
}, {
  "versionRange" : "[3.7.0,3.7.14)",
  "severity" : 7.5,
  "cveName" : "CVE-2020-10735",
  "description" : "A flaw was found in python. In algorithms with quadratic time complexity using non-binary bases, when using int(\"text\"), a system could take 50ms to parse an int string with 100,000 digits and 5s for 1,000,000 digits (float, decimal, int.from_bytes(), and int() for binary bases 2, 4, 8, 16, and 32 are not affected). The highest threat from this vulnerability is to system availability.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2020-10735"
}, {
  "versionRange" : "[2.5.1,2.5.1]",
  "severity" : 6.4,
  "cveName" : "CVE-2011-1521",
  "description" : "The urllib and urllib2 modules in Python 2.x before 2.7.2 and 3.x before 3.2.1 process Location headers that specify redirection to file: URLs, which makes it easier for remote attackers to obtain sensitive information or cause a denial of service (resource consumption) via a crafted URL, as demonstrated by the file:///etc/passwd and file:///dev/zero URLs.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-1521"
}, {
  "versionRange" : "[3.7.0,3.7.13)",
  "severity" : 6.5,
  "cveName" : "CVE-2016-3189",
  "description" : "Use-after-free vulnerability in bzip2recover in bzip2 1.0.6 allows remote attackers to cause a denial of service (crash) via a crafted bzip2 file, related to block ends set to before the start of the block.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-3189"
}, {
  "versionRange" : "[2.6.5,2.6.5]",
  "severity" : 1.9,
  "cveName" : "CVE-2011-4944",
  "description" : "Python 2.6 through 3.2 creates ~/.pypirc with world-readable permissions before changing them after data has been written, which introduces a race condition that allows local users to obtain a username and password by reading this file.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-4944"
}, {
  "versionRange" : "(,2.7.15)",
  "severity" : 9.8,
  "cveName" : "CVE-2017-1000158",
  "description" : "CPython (aka Python) up to 2.7.13 is vulnerable to an integer overflow in the PyString_DecodeEscape function in stringobject.c, resulting in heap-based buffer overflow (and possible arbitrary code execution)",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2017-1000158"
}, {
  "versionRange" : "[3.4.0,3.4.2)",
  "severity" : 9.8,
  "cveName" : "CVE-2014-4650",
  "description" : "The CGIHTTPServer module in Python 2.7.5 and 3.3.4 does not properly handle URLs in which URL encoding is used for path separators, which allows remote attackers to read script source code or conduct directory traversal attacks and execute unintended code via a crafted character sequence, as demonstrated by a %2f separator.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-4650"
}, {
  "versionRange" : "[3.3.0,3.3.7)",
  "severity" : 7.5,
  "cveName" : "CVE-2017-9233",
  "description" : "XML External Entity vulnerability in libexpat 2.2.0 and earlier (Expat XML Parser Library) allows attackers to put the parser in an infinite loop using a malformed external entity definition from an external DTD.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2017-9233"
}, {
  "versionRange" : "[3.2.5,3.2.5]",
  "severity" : 9.8,
  "cveName" : "CVE-2016-5636",
  "description" : "Integer overflow in the get_data function in zipimport.c in CPython (aka Python) before 2.7.12, 3.x before 3.4.5, and 3.5.x before 3.5.2 allows remote attackers to have unspecified impact via a negative data size value, which triggers a heap-based buffer overflow.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-5636"
}, {
  "versionRange" : "[2.6.3,2.6.3]",
  "severity" : 2.6,
  "cveName" : "CVE-2011-4940",
  "description" : "The list_directory function in Lib/SimpleHTTPServer.py in SimpleHTTPServer in Python before 2.5.6c1, 2.6.x before 2.6.7 rc2, and 2.7.x before 2.7.2 does not place a charset parameter in the Content-Type HTTP header, which makes it easier for remote attackers to conduct cross-site scripting (XSS) attacks against Internet Explorer 7 via UTF-7 encoding.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-4940"
}, {
  "versionRange" : "[3.0.1,3.0.1]",
  "severity" : 5.8,
  "cveName" : "CVE-2014-9365",
  "description" : "The HTTP clients in the (1) httplib, (2) urllib, (3) urllib2, and (4) xmlrpclib libraries in CPython (aka Python) 2.x before 2.7.9 and 3.x before 3.4.3, when accessing an HTTPS URL, do not (a) check the certificate against a trust store or verify that the server hostname matches a domain name in the subject's (b) Common Name or (c) subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-9365"
}, {
  "versionRange" : "[2.0.1,2.0.1]",
  "severity" : 6.4,
  "cveName" : "CVE-2011-1521",
  "description" : "The urllib and urllib2 modules in Python 2.x before 2.7.2 and 3.x before 3.2.1 process Location headers that specify redirection to file: URLs, which makes it easier for remote attackers to obtain sensitive information or cause a denial of service (resource consumption) via a crafted URL, as demonstrated by the file:///etc/passwd and file:///dev/zero URLs.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-1521"
}, {
  "versionRange" : "[3.7.3,3.7.15]",
  "severity" : 7.8,
  "cveName" : "CVE-2022-42919",
  "description" : "Python 3.9.x before 3.9.16 and 3.10.x before 3.10.9 on Linux allows local privilege escalation in a non-default configuration. The Python multiprocessing library, when used with the forkserver start method on Linux, allows pickles to be deserialized from any user in the same machine local network namespace, which in many system configurations means any user on the same machine. Pickles can execute arbitrary code. Thus, this allows for local user privilege escalation to the user that any forkserver process is running as. Setting multiprocessing.util.abstract_sockets_supported to False is a workaround. The forkserver start method for multiprocessing is not the default start method. This issue is Linux specific because only Linux supports abstract namespace sockets. CPython before 3.9 does not make use of Linux abstract namespace sockets by default. Support for users manually specifying an abstract namespace socket was added as a bugfix in 3.7.8 and 3.8.3, but users would need to make specific uncommon API calls in order to do that in CPython before 3.9.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2022-42919"
}, {
  "versionRange" : "[2.7.1,2.7.1]",
  "severity" : 1.9,
  "cveName" : "CVE-2011-4944",
  "description" : "Python 2.6 through 3.2 creates ~/.pypirc with world-readable permissions before changing them after data has been written, which introduces a race condition that allows local users to obtain a username and password by reading this file.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-4944"
}, {
  "versionRange" : "[3.3.1,3.3.1]",
  "severity" : 7.5,
  "cveName" : "CVE-2014-1912",
  "description" : "Buffer overflow in the socket.recvfrom_into function in Modules/socketmodule.c in Python 2.5 before 2.7.7, 3.x before 3.3.4, and 3.4.x before 3.4rc1 allows remote attackers to execute arbitrary code via a crafted string.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-1912"
}, {
  "versionRange" : "[2.2.3,2.2.3]",
  "severity" : 6.4,
  "cveName" : "CVE-2011-1521",
  "description" : "The urllib and urllib2 modules in Python 2.x before 2.7.2 and 3.x before 3.2.1 process Location headers that specify redirection to file: URLs, which makes it easier for remote attackers to obtain sensitive information or cause a denial of service (resource consumption) via a crafted URL, as demonstrated by the file:///etc/passwd and file:///dev/zero URLs.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-1521"
}, {
  "versionRange" : "[2.5.4,2.5.4]",
  "severity" : 6.4,
  "cveName" : "CVE-2011-1521",
  "description" : "The urllib and urllib2 modules in Python 2.x before 2.7.2 and 3.x before 3.2.1 process Location headers that specify redirection to file: URLs, which makes it easier for remote attackers to obtain sensitive information or cause a denial of service (resource consumption) via a crafted URL, as demonstrated by the file:///etc/passwd and file:///dev/zero URLs.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-1521"
}, {
  "versionRange" : "[3.3,3.3]",
  "severity" : 4.3,
  "cveName" : "CVE-2013-4238",
  "description" : "The ssl.match_hostname function in the SSL module in Python 2.6 through 3.4 does not properly handle a '\\0' character in a domain name in the Subject Alternative Name field of an X.509 certificate, which allows man-in-the-middle attackers to spoof arbitrary SSL servers via a crafted certificate issued by a legitimate Certification Authority, a related issue to CVE-2009-2408.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-4238"
}, {
  "versionRange" : "[3.3.0,3.3.7]",
  "severity" : 7.5,
  "cveName" : "CVE-2019-16056",
  "description" : "An issue was discovered in Python through 2.7.16, 3.x through 3.5.7, 3.6.x through 3.6.9, and 3.7.x through 3.7.4. The email module wrongly parses email addresses that contain multiple @ characters. An application that uses the email module and implements some kind of checks on the From/To headers of a message could be tricked into accepting an email address that should be denied. An attack may be the same as in CVE-2019-11340; however, this CVE applies to Python more generally.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2019-16056"
}, {
  "versionRange" : "[3.3.6,3.3.6]",
  "severity" : 6.5,
  "cveName" : "CVE-2016-0772",
  "description" : "The smtplib library in CPython (aka Python) before 2.7.12, 3.x before 3.4.5, and 3.5.x before 3.5.2 does not return an error when StartTLS fails, which might allow man-in-the-middle attackers to bypass the TLS protections by leveraging a network position between the client and the registry to block the StartTLS command, aka a \"StartTLS stripping attack.\"",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-0772"
}, {
  "versionRange" : "[2.6.4,2.6.4]",
  "severity" : 5.0,
  "cveName" : "CVE-2012-1150",
  "description" : "Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 computes hash values without restricting the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-1150"
}, {
  "versionRange" : "[3.9.0,3.9.1)",
  "severity" : 5.9,
  "cveName" : "CVE-2022-48566",
  "description" : "An issue was discovered in compare_digest in Lib/hmac.py in Python through 3.9.1. Constant-time-defeating optimisations were possible in the accumulator variable in hmac.compare_digest.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2022-48566"
}, {
  "versionRange" : "[3.3.0,3.3.6)",
  "severity" : 9.8,
  "cveName" : "CVE-2014-4650",
  "description" : "The CGIHTTPServer module in Python 2.7.5 and 3.3.4 does not properly handle URLs in which URL encoding is used for path separators, which allows remote attackers to read script source code or conduct directory traversal attacks and execute unintended code via a crafted character sequence, as demonstrated by a %2f separator.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-4650"
}, {
  "versionRange" : "[3.1.2,3.1.2]",
  "severity" : 6.5,
  "cveName" : "CVE-2016-0772",
  "description" : "The smtplib library in CPython (aka Python) before 2.7.12, 3.x before 3.4.5, and 3.5.x before 3.5.2 does not return an error when StartTLS fails, which might allow man-in-the-middle attackers to bypass the TLS protections by leveraging a network position between the client and the registry to block the StartTLS command, aka a \"StartTLS stripping attack.\"",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-0772"
}, {
  "versionRange" : "[3.10.0,3.10.5)",
  "severity" : 7.5,
  "cveName" : "CVE-2018-25032",
  "description" : "zlib before 1.2.12 allows memory corruption when deflating (i.e., when compressing) if the input has many distant matches.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2018-25032"
}, {
  "versionRange" : "[3.8.0,3.8.9)",
  "severity" : 5.3,
  "cveName" : "CVE-2021-4189",
  "description" : "A flaw was found in Python, specifically in the FTP (File Transfer Protocol) client library in PASV (passive) mode. The issue is how the FTP client trusts the host from the PASV response by default. This flaw allows an attacker to set up a malicious FTP server that can trick FTP clients into connecting back to a given IP address and port. This vulnerability could lead to FTP client scanning ports, which otherwise would not have been possible.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2021-4189"
}, {
  "versionRange" : "[2.7.0,2.7.17)",
  "severity" : 7.5,
  "cveName" : "CVE-2019-15903",
  "description" : "In libexpat before 2.2.8, crafted XML input could fool the parser into changing from DTD parsing to document parsing too early; a consecutive call to XML_GetCurrentLineNumber (or XML_GetCurrentColumnNumber) then resulted in a heap-based buffer over-read.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2019-15903"
}, {
  "versionRange" : "[3.3.0,3.3.7)",
  "severity" : 9.8,
  "cveName" : "CVE-2016-0718",
  "description" : "Expat allows context-dependent attackers to cause a denial of service (crash) or possibly execute arbitrary code via a malformed input document, which triggers a buffer overflow.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-0718"
}, {
  "versionRange" : "[3.4.0,3.4.7)",
  "severity" : 7.5,
  "cveName" : "CVE-2017-9233",
  "description" : "XML External Entity vulnerability in libexpat 2.2.0 and earlier (Expat XML Parser Library) allows attackers to put the parser in an infinite loop using a malformed external entity definition from an external DTD.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2017-9233"
}, {
  "versionRange" : "[3.9.0,3.9.17)",
  "severity" : 7.5,
  "cveName" : "CVE-2023-24329",
  "description" : "An issue in the urllib.parse component of Python before 3.11.4 allows attackers to bypass blocklisting methods by supplying a URL that starts with blank characters.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2023-24329"
}, {
  "versionRange" : "[3.9.0,3.9.15]",
  "severity" : 7.6,
  "cveName" : "CVE-2015-20107",
  "description" : "In Python (aka CPython) up to 3.10.8, the mailcap module does not add escape characters into commands discovered in the system mailcap file. This may allow attackers to inject shell commands into applications that call mailcap.findmatch with untrusted input (if they lack validation of user-provided filenames or arguments). The fix is also back-ported to 3.7, 3.8, 3.9",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2015-20107"
}, {
  "versionRange" : "[3.3.0,3.3.0]",
  "severity" : 3.3,
  "cveName" : "CVE-2014-2667",
  "description" : "Race condition in the _get_masked_mode function in Lib/os.py in Python 3.2 through 3.5, when exist_ok is set to true and multiple threads are used, might allow local users to bypass intended file permissions by leveraging a separate application vulnerability before the umask has been set to the expected value.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-2667"
}, {
  "versionRange" : "[3.7.0,3.7.10)",
  "severity" : 9.8,
  "cveName" : "CVE-2022-48565",
  "description" : "An XML External Entity (XXE) issue was discovered in Python through 3.9.1. The plistlib module no longer accepts entity declarations in XML plist files to avoid XML vulnerabilities.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2022-48565"
}, {
  "versionRange" : "(,2.5.3)",
  "severity" : 6.8,
  "cveName" : "CVE-2008-1679",
  "description" : "Multiple integer overflows in imageop.c in Python before 2.5.3 allow context-dependent attackers to cause a denial of service (crash) and possibly execute arbitrary code via crafted images that trigger heap-based buffer overflows.  NOTE: this issue is due to an incomplete fix for CVE-2007-4965.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2008-1679"
}, {
  "versionRange" : "[3.10.0,3.10.6)",
  "severity" : 7.4,
  "cveName" : "CVE-2021-28861",
  "description" : "Python 3.x through 3.10 has an open redirection vulnerability in lib/http/server.py due to no protection against multiple (/) at the beginning of URI path which may leads to information disclosure. NOTE: this is disputed by a third party because the http.server.html documentation page states \"Warning: http.server is not recommended for production. It only implements basic security checks.\"",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2021-28861"
}, {
  "versionRange" : "(,3.7.12]",
  "severity" : 7.0,
  "cveName" : "CVE-2022-26488",
  "description" : "In Python before 3.10.3 on Windows, local users can gain privileges because the search path is inadequately secured. The installer may allow a local attacker to add user-writable directories to the system search path. To exploit, an administrator must have installed Python for all users and enabled PATH entries. A non-administrative user can trigger a repair that incorrectly adds user-writable paths into PATH, enabling search-path hijacking of other users and system services. This affects Python (CPython) through 3.7.12, 3.8.x through 3.8.12, 3.9.x through 3.9.10, and 3.10.x through 3.10.2.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2022-26488"
}, {
  "versionRange" : "[3.7.0,3.7.10)",
  "severity" : 5.9,
  "cveName" : "CVE-2022-48566",
  "description" : "An issue was discovered in compare_digest in Lib/hmac.py in Python through 3.9.1. Constant-time-defeating optimisations were possible in the accumulator variable in hmac.compare_digest.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2022-48566"
}, {
  "versionRange" : "[2.0.1,2.0.1]",
  "severity" : 5.0,
  "cveName" : "CVE-2012-1150",
  "description" : "Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 computes hash values without restricting the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-1150"
}, {
  "versionRange" : "[3.2.2,3.2.2]",
  "severity" : 4.3,
  "cveName" : "CVE-2013-2099",
  "description" : "Algorithmic complexity vulnerability in the ssl.match_hostname function in Python 3.2.x, 3.3.x, and earlier, and unspecified versions of python-backports-ssl_match_hostname as used for older Python versions, allows remote attackers to cause a denial of service (CPU consumption) via multiple wildcard characters in the common name in a certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-2099"
}, {
  "versionRange" : "[2.7.0,2.7.15)",
  "severity" : 8.1,
  "cveName" : "CVE-2016-4472",
  "description" : "The overflow protection in Expat is removed by compilers with certain optimization settings, which allows remote attackers to cause a denial of service (crash) or possibly execute arbitrary code via crafted XML data.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2015-1283 and CVE-2015-2716.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-4472"
}, {
  "versionRange" : "[3.0.0,3.5.10)",
  "severity" : 5.9,
  "cveName" : "CVE-2020-14422",
  "description" : "Lib/ipaddress.py in Python through 3.8.3 improperly computes hash values in the IPv4Interface and IPv6Interface classes, which might allow a remote attacker to cause a denial of service if an application is affected by the performance of a dictionary containing IPv4Interface or IPv6Interface objects, and this attacker can cause many dictionary entries to be created. This is fixed in: v3.5.10, v3.5.10rc1; v3.6.12; v3.7.9; v3.8.4, v3.8.4rc1, v3.8.5, v3.8.6, v3.8.6rc1; v3.9.0, v3.9.0b4, v3.9.0b5, v3.9.0rc1, v3.9.0rc2.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2020-14422"
}, {
  "versionRange" : "[2.6.6,2.6.6]",
  "severity" : 5.0,
  "cveName" : "CVE-2012-1150",
  "description" : "Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 computes hash values without restricting the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-1150"
}, {
  "versionRange" : "[3.2.3,3.2.3]",
  "severity" : 3.3,
  "cveName" : "CVE-2014-2667",
  "description" : "Race condition in the _get_masked_mode function in Lib/os.py in Python 3.2 through 3.5, when exist_ok is set to true and multiple threads are used, might allow local users to bypass intended file permissions by leveraging a separate application vulnerability before the umask has been set to the expected value.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-2667"
}, {
  "versionRange" : "[3.4.2,3.4.2]",
  "severity" : 6.5,
  "cveName" : "CVE-2016-0772",
  "description" : "The smtplib library in CPython (aka Python) before 2.7.12, 3.x before 3.4.5, and 3.5.x before 3.5.2 does not return an error when StartTLS fails, which might allow man-in-the-middle attackers to bypass the TLS protections by leveraging a network position between the client and the registry to block the StartTLS command, aka a \"StartTLS stripping attack.\"",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-0772"
}, {
  "versionRange" : "[2.3.5,2.3.5]",
  "severity" : 6.4,
  "cveName" : "CVE-2011-1521",
  "description" : "The urllib and urllib2 modules in Python 2.x before 2.7.2 and 3.x before 3.2.1 process Location headers that specify redirection to file: URLs, which makes it easier for remote attackers to obtain sensitive information or cause a denial of service (resource consumption) via a crafted URL, as demonstrated by the file:///etc/passwd and file:///dev/zero URLs.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-1521"
}, {
  "versionRange" : "[2.4.2,2.4.2]",
  "severity" : 6.4,
  "cveName" : "CVE-2011-1521",
  "description" : "The urllib and urllib2 modules in Python 2.x before 2.7.2 and 3.x before 3.2.1 process Location headers that specify redirection to file: URLs, which makes it easier for remote attackers to obtain sensitive information or cause a denial of service (resource consumption) via a crafted URL, as demonstrated by the file:///etc/passwd and file:///dev/zero URLs.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-1521"
}, {
  "versionRange" : "[3.5.0,3.5.6]",
  "severity" : 7.5,
  "cveName" : "CVE-2018-14647",
  "description" : "Python's elementtree C accelerator failed to initialise Expat's hash salt during initialization. This could make it easy to conduct denial of service attacks against Expat by constructing an XML document that would cause pathological hash collisions in Expat's internal data structures, consuming large amounts CPU and RAM. The vulnerability exists in Python versions 3.7.0, 3.6.0 through 3.6.6, 3.5.0 through 3.5.6, 3.4.0 through 3.4.9, 2.7.0 through 2.7.15.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2018-14647"
}, {
  "versionRange" : "[3.8.0,3.8.1]",
  "severity" : 5.5,
  "cveName" : "CVE-2020-8315",
  "description" : "In Python (CPython) 3.6 through 3.6.10, 3.7 through 3.7.6, and 3.8 through 3.8.1, an insecure dependency load upon launch on Windows 7 may result in an attacker's copy of api-ms-win-core-path-l1-1-0.dll being loaded and used instead of the system's copy. Windows 8 and later are unaffected.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2020-8315"
}, {
  "versionRange" : "[3.2.5,3.2.5]",
  "severity" : 4.3,
  "cveName" : "CVE-2013-7040",
  "description" : "Python 2.7 before 3.4 only uses the last eight bits of the prefix to randomize hash values, which causes it to compute hash values without restricting the ability to trigger hash collisions predictably and makes it easier for context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2012-1150.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-7040"
}, {
  "versionRange" : "[3.9.0,3.9.15]",
  "severity" : 7.5,
  "cveName" : "CVE-2022-45061",
  "description" : "An issue was discovered in Python before 3.11.1. An unnecessary quadratic algorithm exists in one path when processing some inputs to the IDNA (RFC 3490) decoder, such that a crafted, unreasonably long name being presented to the decoder could lead to a CPU denial of service. Hostnames are often supplied by remote servers that could be controlled by a malicious actor; in such a scenario, they could trigger excessive CPU consumption on the client attempting to make use of an attacker-supplied supposed hostname. For example, the attack payload could be placed in the Location header of an HTTP response with status code 302. A fix is planned in 3.11.1, 3.10.9, 3.9.16, 3.8.16, and 3.7.16.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2022-45061"
}, {
  "versionRange" : "[2.5.1,2.5.1]",
  "severity" : 10.0,
  "cveName" : "CVE-2008-5031",
  "description" : "Multiple integer overflows in Python 2.2.3 through 2.5.1, and 2.6, allow context-dependent attackers to have an unknown impact via a large integer value in the tabsize argument to the expandtabs method, as implemented by (1) the string_expandtabs function in Objects/stringobject.c and (2) the unicode_expandtabs function in Objects/unicodeobject.c.  NOTE: this vulnerability reportedly exists because of an incomplete fix for CVE-2008-2315.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2008-5031"
}, {
  "versionRange" : "(,3.6.13)",
  "severity" : 9.8,
  "cveName" : "CVE-2022-48565",
  "description" : "An XML External Entity (XXE) issue was discovered in Python through 3.9.1. The plistlib module no longer accepts entity declarations in XML plist files to avoid XML vulnerabilities.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2022-48565"
}, {
  "versionRange" : "[2.7.6,2.7.6]",
  "severity" : 5.8,
  "cveName" : "CVE-2014-9365",
  "description" : "The HTTP clients in the (1) httplib, (2) urllib, (3) urllib2, and (4) xmlrpclib libraries in CPython (aka Python) 2.x before 2.7.9 and 3.x before 3.4.3, when accessing an HTTPS URL, do not (a) check the certificate against a trust store or verify that the server hostname matches a domain name in the subject's (b) Common Name or (c) subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-9365"
}, {
  "versionRange" : "[3.2.4,3.2.4]",
  "severity" : 6.1,
  "cveName" : "CVE-2016-5699",
  "description" : "CRLF injection vulnerability in the HTTPConnection.putheader function in urllib2 and urllib in CPython (aka Python) before 2.7.10 and 3.x before 3.4.4 allows remote attackers to inject arbitrary HTTP headers via CRLF sequences in a URL.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-5699"
}, {
  "versionRange" : "[3.6.0,3.6.9)",
  "severity" : 9.8,
  "cveName" : "CVE-2019-9636",
  "description" : "Python 2.7.x through 2.7.16 and 3.x through 3.7.2 is affected by: Improper Handling of Unicode Encoding (with an incorrect netloc) during NFKC normalization. The impact is: Information disclosure (credentials, cookies, etc. that are cached against a given hostname). The components are: urllib.parse.urlsplit, urllib.parse.urlparse. The attack vector is: A specially crafted URL could be incorrectly parsed to locate cookies or authentication data and send that information to a different host than when parsed correctly. This is fixed in: v2.7.17, v2.7.17rc1, v2.7.18, v2.7.18rc1; v3.5.10, v3.5.10rc1, v3.5.7, v3.5.8, v3.5.8rc1, v3.5.8rc2, v3.5.9; v3.6.10, v3.6.10rc1, v3.6.11, v3.6.11rc1, v3.6.12, v3.6.9, v3.6.9rc1; v3.7.3, v3.7.3rc1, v3.7.4, v3.7.4rc1, v3.7.4rc2, v3.7.5, v3.7.5rc1, v3.7.6, v3.7.6rc1, v3.7.7, v3.7.7rc1, v3.7.8, v3.7.8rc1, v3.7.9.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2019-9636"
}, {
  "versionRange" : "[3.4.2,3.4.2]",
  "severity" : 3.3,
  "cveName" : "CVE-2014-2667",
  "description" : "Race condition in the _get_masked_mode function in Lib/os.py in Python 3.2 through 3.5, when exist_ok is set to true and multiple threads are used, might allow local users to bypass intended file permissions by leveraging a separate application vulnerability before the umask has been set to the expected value.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-2667"
}, {
  "versionRange" : "[2.6.5,2.6.5]",
  "severity" : 4.3,
  "cveName" : "CVE-2013-4238",
  "description" : "The ssl.match_hostname function in the SSL module in Python 2.6 through 3.4 does not properly handle a '\\0' character in a domain name in the Subject Alternative Name field of an X.509 certificate, which allows man-in-the-middle attackers to spoof arbitrary SSL servers via a crafted certificate issued by a legitimate Certification Authority, a related issue to CVE-2009-2408.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-4238"
}, {
  "versionRange" : "[2.5.0,2.5.2]",
  "severity" : 7.5,
  "cveName" : "CVE-2008-1721",
  "description" : "Integer signedness error in the zlib extension module in Python 2.5.2 and earlier allows remote attackers to execute arbitrary code via a negative signed integer, which triggers insufficient memory allocation and a buffer overflow.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2008-1721"
}, {
  "versionRange" : "[2.6.7,2.6.7]",
  "severity" : 1.9,
  "cveName" : "CVE-2011-4944",
  "description" : "Python 2.6 through 3.2 creates ~/.pypirc with world-readable permissions before changing them after data has been written, which introduces a race condition that allows local users to obtain a username and password by reading this file.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-4944"
}, {
  "versionRange" : "[3.2.4,3.2.4]",
  "severity" : 4.3,
  "cveName" : "CVE-2013-7040",
  "description" : "Python 2.7 before 3.4 only uses the last eight bits of the prefix to randomize hash values, which causes it to compute hash values without restricting the ability to trigger hash collisions predictably and makes it easier for context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2012-1150.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-7040"
}, {
  "versionRange" : "[3.4.3,3.4.3]",
  "severity" : 6.5,
  "cveName" : "CVE-2016-0772",
  "description" : "The smtplib library in CPython (aka Python) before 2.7.12, 3.x before 3.4.5, and 3.5.x before 3.5.2 does not return an error when StartTLS fails, which might allow man-in-the-middle attackers to bypass the TLS protections by leveraging a network position between the client and the registry to block the StartTLS command, aka a \"StartTLS stripping attack.\"",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-0772"
}, {
  "versionRange" : "[3.5.0,3.5.4)",
  "severity" : 9.8,
  "cveName" : "CVE-2016-0718",
  "description" : "Expat allows context-dependent attackers to cause a denial of service (crash) or possibly execute arbitrary code via a malformed input document, which triggers a buffer overflow.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-0718"
}, {
  "versionRange" : "[2.3.4,2.3.4]",
  "severity" : 5.0,
  "cveName" : "CVE-2012-0845",
  "description" : "SimpleXMLRPCServer.py in SimpleXMLRPCServer in Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 allows remote attackers to cause a denial of service (infinite loop and CPU consumption) via an XML-RPC POST request that contains a smaller amount of data than specified by the Content-Length header.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-0845"
}, {
  "versionRange" : "[3.8.0,3.8.14)",
  "severity" : 7.5,
  "cveName" : "CVE-2020-10735",
  "description" : "A flaw was found in python. In algorithms with quadratic time complexity using non-binary bases, when using int(\"text\"), a system could take 50ms to parse an int string with 100,000 digits and 5s for 1,000,000 digits (float, decimal, int.from_bytes(), and int() for binary bases 2, 4, 8, 16, and 32 are not affected). The highest threat from this vulnerability is to system availability.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2020-10735"
}, {
  "versionRange" : "[3.2.2,3.2.2]",
  "severity" : 5.8,
  "cveName" : "CVE-2014-9365",
  "description" : "The HTTP clients in the (1) httplib, (2) urllib, (3) urllib2, and (4) xmlrpclib libraries in CPython (aka Python) 2.x before 2.7.9 and 3.x before 3.4.3, when accessing an HTTPS URL, do not (a) check the certificate against a trust store or verify that the server hostname matches a domain name in the subject's (b) Common Name or (c) subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-9365"
}, {
  "versionRange" : "(,3.6.14)",
  "severity" : 6.5,
  "cveName" : "CVE-2021-3733",
  "description" : "There's a flaw in urllib's AbstractBasicAuthHandler class. An attacker who controls a malicious HTTP server that an HTTP client (such as web browser) connects to, could trigger a Regular Expression Denial of Service (ReDOS) during an authentication request with a specially crafted payload that is sent by the server to the client. The greatest threat that this flaw poses is to application availability.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2021-3733"
}, {
  "versionRange" : "[3.6.0,3.6.9]",
  "severity" : 7.5,
  "cveName" : "CVE-2019-16056",
  "description" : "An issue was discovered in Python through 2.7.16, 3.x through 3.5.7, 3.6.x through 3.6.9, and 3.7.x through 3.7.4. The email module wrongly parses email addresses that contain multiple @ characters. An application that uses the email module and implements some kind of checks on the From/To headers of a message could be tricked into accepting an email address that should be denied. An attack may be the same as in CVE-2019-11340; however, this CVE applies to Python more generally.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2019-16056"
}, {
  "versionRange" : "[3.2.3,3.2.3]",
  "severity" : 4.3,
  "cveName" : "CVE-2013-7040",
  "description" : "Python 2.7 before 3.4 only uses the last eight bits of the prefix to randomize hash values, which causes it to compute hash values without restricting the ability to trigger hash collisions predictably and makes it easier for context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2012-1150.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-7040"
}, {
  "versionRange" : "(,2.5.6]",
  "severity" : 2.6,
  "cveName" : "CVE-2011-4940",
  "description" : "The list_directory function in Lib/SimpleHTTPServer.py in SimpleHTTPServer in Python before 2.5.6c1, 2.6.x before 2.6.7 rc2, and 2.7.x before 2.7.2 does not place a charset parameter in the Content-Type HTTP header, which makes it easier for remote attackers to conduct cross-site scripting (XSS) attacks against Internet Explorer 7 via UTF-7 encoding.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-4940"
}, {
  "versionRange" : "[2.5.0,2.5.6)",
  "severity" : 5.0,
  "cveName" : "CVE-2010-2089",
  "description" : "The audioop module in Python 2.7 and 3.2 does not verify the relationships between size arguments and byte string lengths, which allows context-dependent attackers to cause a denial of service (memory corruption and application crash) via crafted arguments, as demonstrated by a call to audioop.reverse with a one-byte string, a different vulnerability than CVE-2010-1634.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2010-2089"
}, {
  "versionRange" : "[2.6.1,2.6.1]",
  "severity" : 6.4,
  "cveName" : "CVE-2011-1521",
  "description" : "The urllib and urllib2 modules in Python 2.x before 2.7.2 and 3.x before 3.2.1 process Location headers that specify redirection to file: URLs, which makes it easier for remote attackers to obtain sensitive information or cause a denial of service (resource consumption) via a crafted URL, as demonstrated by the file:///etc/passwd and file:///dev/zero URLs.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-1521"
}, {
  "versionRange" : "[3.8.0,3.8.1]",
  "severity" : 6.5,
  "cveName" : "CVE-2020-8492",
  "description" : "Python 2.7 through 2.7.17, 3.5 through 3.5.9, 3.6 through 3.6.10, 3.7 through 3.7.6, and 3.8 through 3.8.1 allows an HTTP server to conduct Regular Expression Denial of Service (ReDoS) attacks against a client because of urllib.request.AbstractBasicAuthHandler catastrophic backtracking.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2020-8492"
}, {
  "versionRange" : "[2.2.1,2.2.1]",
  "severity" : 5.8,
  "cveName" : "CVE-2014-9365",
  "description" : "The HTTP clients in the (1) httplib, (2) urllib, (3) urllib2, and (4) xmlrpclib libraries in CPython (aka Python) 2.x before 2.7.9 and 3.x before 3.4.3, when accessing an HTTPS URL, do not (a) check the certificate against a trust store or verify that the server hostname matches a domain name in the subject's (b) Common Name or (c) subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-9365"
}, {
  "versionRange" : "[3.6.0,3.6.10)",
  "severity" : 6.1,
  "cveName" : "CVE-2019-16935",
  "description" : "The documentation XML-RPC server in Python through 2.7.16, 3.x through 3.6.9, and 3.7.x through 3.7.4 has XSS via the server_title field. This occurs in Lib/DocXMLRPCServer.py in Python 2.x, and in Lib/xmlrpc/server.py in Python 3.x. If set_server_title is called with untrusted input, arbitrary JavaScript can be delivered to clients that visit the http URL for this server.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2019-16935"
}, {
  "versionRange" : "[3.1.1,3.1.1]",
  "severity" : 6.1,
  "cveName" : "CVE-2016-5699",
  "description" : "CRLF injection vulnerability in the HTTPConnection.putheader function in urllib2 and urllib in CPython (aka Python) before 2.7.10 and 3.x before 3.4.4 allows remote attackers to inject arbitrary HTTP headers via CRLF sequences in a URL.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-5699"
}, {
  "versionRange" : "[3.3.0,3.3.7)",
  "severity" : 9.8,
  "cveName" : "CVE-2016-9063",
  "description" : "An integer overflow during the parsing of XML using the Expat library. This vulnerability affects Firefox < 50.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-9063"
}, {
  "versionRange" : "[2.6.6,2.6.6]",
  "severity" : 2.6,
  "cveName" : "CVE-2011-4940",
  "description" : "The list_directory function in Lib/SimpleHTTPServer.py in SimpleHTTPServer in Python before 2.5.6c1, 2.6.x before 2.6.7 rc2, and 2.7.x before 2.7.2 does not place a charset parameter in the Content-Type HTTP header, which makes it easier for remote attackers to conduct cross-site scripting (XSS) attacks against Internet Explorer 7 via UTF-7 encoding.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-4940"
}, {
  "versionRange" : "[3.3.0,3.3.6)",
  "severity" : 5.9,
  "cveName" : "CVE-2014-4616",
  "description" : "Array index error in the scanstring function in the _json module in Python 2.7 through 3.5 and simplejson before 2.6.1 allows context-dependent attackers to read arbitrary process memory via a negative index value in the idx argument to the raw_decode function.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-4616"
}, {
  "versionRange" : "[2.7.7,2.7.7]",
  "severity" : 4.3,
  "cveName" : "CVE-2013-7040",
  "description" : "Python 2.7 before 3.4 only uses the last eight bits of the prefix to randomize hash values, which causes it to compute hash values without restricting the ability to trigger hash collisions predictably and makes it easier for context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2012-1150.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-7040"
}, {
  "versionRange" : "[2.7.0,2.7.8)",
  "severity" : 7.4,
  "cveName" : "CVE-2014-0224",
  "description" : "OpenSSL before 0.9.8za, 1.0.0 before 1.0.0m, and 1.0.1 before 1.0.1h does not properly restrict processing of ChangeCipherSpec messages, which allows man-in-the-middle attackers to trigger use of a zero-length master key in certain OpenSSL-to-OpenSSL communications, and consequently hijack sessions or obtain sensitive information, via a crafted TLS handshake, aka the \"CCS Injection\" vulnerability.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-0224"
}, {
  "versionRange" : "[3.1.1,3.1.1]",
  "severity" : 9.8,
  "cveName" : "CVE-2016-5636",
  "description" : "Integer overflow in the get_data function in zipimport.c in CPython (aka Python) before 2.7.12, 3.x before 3.4.5, and 3.5.x before 3.5.2 allows remote attackers to have unspecified impact via a negative data size value, which triggers a heap-based buffer overflow.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-5636"
}, {
  "versionRange" : "[3.8.0,3.8.7)",
  "severity" : 6.5,
  "cveName" : "CVE-2022-48564",
  "description" : "read_ints in plistlib.py in Python through 3.9.1 is vulnerable to a potential DoS attack via CPU and RAM exhaustion when processing malformed Apple Property List files in binary format.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2022-48564"
}, {
  "versionRange" : "[3.5.0,3.5.8)",
  "severity" : 9.8,
  "cveName" : "CVE-2019-10160",
  "description" : "A security regression of CVE-2019-9636 was discovered in python since commit d537ab0ff9767ef024f26246899728f0116b1ec3 affecting versions 2.7, 3.5, 3.6, 3.7 and from v3.8.0a4 through v3.8.0b1, which still allows an attacker to exploit CVE-2019-9636 by abusing the user and password parts of a URL. When an application parses user-supplied URLs to store cookies, authentication credentials, or other kind of information, it is possible for an attacker to provide specially crafted URLs to make the application locate host-related information (e.g. cookies, authentication data) and send them to a different host than where it should, unlike if the URLs had been correctly parsed. The result of an attack may vary based on the application.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2019-10160"
}, {
  "versionRange" : "[2.5.0,2.5.6)",
  "severity" : 5.0,
  "cveName" : "CVE-2010-1634",
  "description" : "Multiple integer overflows in audioop.c in the audioop module in Python 2.6, 2.7, 3.1, and 3.2 allow context-dependent attackers to cause a denial of service (application crash) via a large fragment, as demonstrated by a call to audioop.lin2lin with a long string in the first argument, leading to a buffer overflow.  NOTE: this vulnerability exists because of an incorrect fix for CVE-2008-3143.5.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2010-1634"
}, {
  "versionRange" : "[3.1.2,3.1.2]",
  "severity" : 4.3,
  "cveName" : "CVE-2013-4238",
  "description" : "The ssl.match_hostname function in the SSL module in Python 2.6 through 3.4 does not properly handle a '\\0' character in a domain name in the Subject Alternative Name field of an X.509 certificate, which allows man-in-the-middle attackers to spoof arbitrary SSL servers via a crafted certificate issued by a legitimate Certification Authority, a related issue to CVE-2009-2408.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-4238"
}, {
  "versionRange" : "[3.12.0,3.12.0]",
  "severity" : 5.5,
  "cveName" : "CVE-2023-33595",
  "description" : "CPython v3.12.0 alpha 7 was discovered to contain a heap use-after-free via the function ascii_decode at /Objects/unicodeobject.c.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2023-33595"
}, {
  "versionRange" : "[3.5.0,3.5.8)",
  "severity" : 9.1,
  "cveName" : "CVE-2019-9948",
  "description" : "urllib in Python 2.x through 2.7.16 supports the local_file: scheme, which makes it easier for remote attackers to bypass protection mechanisms that blacklist file: URIs, as demonstrated by triggering a urllib.urlopen('local_file:///etc/passwd') call.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2019-9948"
}, {
  "versionRange" : "[2.6.3,2.6.3]",
  "severity" : 5.0,
  "cveName" : "CVE-2012-1150",
  "description" : "Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 computes hash values without restricting the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-1150"
}, {
  "versionRange" : "[2.7.8,2.7.8]",
  "severity" : 5.8,
  "cveName" : "CVE-2014-9365",
  "description" : "The HTTP clients in the (1) httplib, (2) urllib, (3) urllib2, and (4) xmlrpclib libraries in CPython (aka Python) 2.x before 2.7.9 and 3.x before 3.4.3, when accessing an HTTPS URL, do not (a) check the certificate against a trust store or verify that the server hostname matches a domain name in the subject's (b) Common Name or (c) subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-9365"
}, {
  "versionRange" : "[3.1.5,3.1.5]",
  "severity" : 9.8,
  "cveName" : "CVE-2016-5636",
  "description" : "Integer overflow in the get_data function in zipimport.c in CPython (aka Python) before 2.7.12, 3.x before 3.4.5, and 3.5.x before 3.5.2 allows remote attackers to have unspecified impact via a negative data size value, which triggers a heap-based buffer overflow.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-5636"
}, {
  "versionRange" : "[3.1.2,3.1.2]",
  "severity" : 6.4,
  "cveName" : "CVE-2011-1521",
  "description" : "The urllib and urllib2 modules in Python 2.x before 2.7.2 and 3.x before 3.2.1 process Location headers that specify redirection to file: URLs, which makes it easier for remote attackers to obtain sensitive information or cause a denial of service (resource consumption) via a crafted URL, as demonstrated by the file:///etc/passwd and file:///dev/zero URLs.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-1521"
}, {
  "versionRange" : "[2.6.4,2.6.4]",
  "severity" : 5.0,
  "cveName" : "CVE-2012-0845",
  "description" : "SimpleXMLRPCServer.py in SimpleXMLRPCServer in Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 allows remote attackers to cause a denial of service (infinite loop and CPU consumption) via an XML-RPC POST request that contains a smaller amount of data than specified by the Content-Length header.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-0845"
}, {
  "versionRange" : "[3.2.2,3.2.2]",
  "severity" : 4.3,
  "cveName" : "CVE-2013-7040",
  "description" : "Python 2.7 before 3.4 only uses the last eight bits of the prefix to randomize hash values, which causes it to compute hash values without restricting the ability to trigger hash collisions predictably and makes it easier for context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2012-1150.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-7040"
}, {
  "versionRange" : "[3.3.5,3.3.5]",
  "severity" : 3.3,
  "cveName" : "CVE-2014-2667",
  "description" : "Race condition in the _get_masked_mode function in Lib/os.py in Python 3.2 through 3.5, when exist_ok is set to true and multiple threads are used, might allow local users to bypass intended file permissions by leveraging a separate application vulnerability before the umask has been set to the expected value.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-2667"
}, {
  "versionRange" : "[3.3.6,3.3.6]",
  "severity" : 9.8,
  "cveName" : "CVE-2016-5636",
  "description" : "Integer overflow in the get_data function in zipimport.c in CPython (aka Python) before 2.7.12, 3.x before 3.4.5, and 3.5.x before 3.5.2 allows remote attackers to have unspecified impact via a negative data size value, which triggers a heap-based buffer overflow.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-5636"
}, {
  "versionRange" : "[3.10.0,3.10.9)",
  "severity" : 9.8,
  "cveName" : "CVE-2022-37454",
  "description" : "The Keccak XKCP SHA-3 reference implementation before fdc6fef has an integer overflow and resultant buffer overflow that allows attackers to execute arbitrary code or eliminate expected cryptographic properties. This occurs in the sponge function interface.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2022-37454"
}, {
  "versionRange" : "[3.7.0,3.7.0]",
  "severity" : 7.5,
  "cveName" : "CVE-2018-14647",
  "description" : "Python's elementtree C accelerator failed to initialise Expat's hash salt during initialization. This could make it easy to conduct denial of service attacks against Expat by constructing an XML document that would cause pathological hash collisions in Expat's internal data structures, consuming large amounts CPU and RAM. The vulnerability exists in Python versions 3.7.0, 3.6.0 through 3.6.6, 3.5.0 through 3.5.6, 3.4.0 through 3.4.9, 2.7.0 through 2.7.15.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2018-14647"
}, {
  "versionRange" : "[3.0.0,3.6.13)",
  "severity" : 9.8,
  "cveName" : "CVE-2020-27619",
  "description" : "In Python 3 through 3.9.0, the Lib/test/multibytecodec_support.py CJK codec tests call eval() on content retrieved via HTTP.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2020-27619"
}, {
  "versionRange" : "[2.4.6,2.4.6]",
  "severity" : 5.0,
  "cveName" : "CVE-2012-0845",
  "description" : "SimpleXMLRPCServer.py in SimpleXMLRPCServer in Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 allows remote attackers to cause a denial of service (infinite loop and CPU consumption) via an XML-RPC POST request that contains a smaller amount of data than specified by the Content-Length header.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-0845"
}, {
  "versionRange" : "[2.6.2,2.6.2]",
  "severity" : 5.0,
  "cveName" : "CVE-2012-1150",
  "description" : "Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 computes hash values without restricting the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-1150"
}, {
  "versionRange" : "[3.1.3,3.1.3]",
  "severity" : 6.5,
  "cveName" : "CVE-2016-0772",
  "description" : "The smtplib library in CPython (aka Python) before 2.7.12, 3.x before 3.4.5, and 3.5.x before 3.5.2 does not return an error when StartTLS fails, which might allow man-in-the-middle attackers to bypass the TLS protections by leveraging a network position between the client and the registry to block the StartTLS command, aka a \"StartTLS stripping attack.\"",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-0772"
}, {
  "versionRange" : "[3.2.3,3.2.3]",
  "severity" : 4.3,
  "cveName" : "CVE-2013-2099",
  "description" : "Algorithmic complexity vulnerability in the ssl.match_hostname function in Python 3.2.x, 3.3.x, and earlier, and unspecified versions of python-backports-ssl_match_hostname as used for older Python versions, allows remote attackers to cause a denial of service (CPU consumption) via multiple wildcard characters in the common name in a certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-2099"
}, {
  "versionRange" : "[3.4.1,3.4.1]",
  "severity" : 6.1,
  "cveName" : "CVE-2016-5699",
  "description" : "CRLF injection vulnerability in the HTTPConnection.putheader function in urllib2 and urllib in CPython (aka Python) before 2.7.10 and 3.x before 3.4.4 allows remote attackers to inject arbitrary HTTP headers via CRLF sequences in a URL.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-5699"
}, {
  "versionRange" : "[2.7.5,2.7.5]",
  "severity" : 7.5,
  "cveName" : "CVE-2014-1912",
  "description" : "Buffer overflow in the socket.recvfrom_into function in Modules/socketmodule.c in Python 2.5 before 2.7.7, 3.x before 3.3.4, and 3.4.x before 3.4rc1 allows remote attackers to execute arbitrary code via a crafted string.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-1912"
}, {
  "versionRange" : "[3.10.0,3.10.7)",
  "severity" : 7.5,
  "cveName" : "CVE-2020-10735",
  "description" : "A flaw was found in python. In algorithms with quadratic time complexity using non-binary bases, when using int(\"text\"), a system could take 50ms to parse an int string with 100,000 digits and 5s for 1,000,000 digits (float, decimal, int.from_bytes(), and int() for binary bases 2, 4, 8, 16, and 32 are not affected). The highest threat from this vulnerability is to system availability.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2020-10735"
}, {
  "versionRange" : "[2.6.7,2.6.7]",
  "severity" : 4.3,
  "cveName" : "CVE-2013-4238",
  "description" : "The ssl.match_hostname function in the SSL module in Python 2.6 through 3.4 does not properly handle a '\\0' character in a domain name in the Subject Alternative Name field of an X.509 certificate, which allows man-in-the-middle attackers to spoof arbitrary SSL servers via a crafted certificate issued by a legitimate Certification Authority, a related issue to CVE-2009-2408.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-4238"
}, {
  "versionRange" : "[3.0.0,3.4.10)",
  "severity" : 5.3,
  "cveName" : "CVE-2018-20852",
  "description" : "http.cookiejar.DefaultPolicy.domain_return_ok in Lib/http/cookiejar.py in Python before 3.7.3 does not correctly validate the domain: it can be tricked into sending existing cookies to the wrong server. An attacker may abuse this flaw by using a server with a hostname that has another valid hostname as a suffix (e.g., pythonicexample.com to steal cookies for example.com). When a program uses http.cookiejar.DefaultPolicy and tries to do an HTTP connection to an attacker-controlled server, existing cookies can be leaked to the attacker. This affects 2.x through 2.7.16, 3.x before 3.4.10, 3.5.x before 3.5.7, 3.6.x before 3.6.9, and 3.7.x before 3.7.3.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2018-20852"
}, {
  "versionRange" : "[3.10.0,3.10.0]",
  "severity" : 6.5,
  "cveName" : "CVE-2021-3733",
  "description" : "There's a flaw in urllib's AbstractBasicAuthHandler class. An attacker who controls a malicious HTTP server that an HTTP client (such as web browser) connects to, could trigger a Regular Expression Denial of Service (ReDOS) during an authentication request with a specially crafted payload that is sent by the server to the client. The greatest threat that this flaw poses is to application availability.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2021-3733"
}, {
  "versionRange" : "[3.8.0,3.8.17)",
  "severity" : 7.5,
  "cveName" : "CVE-2023-24329",
  "description" : "An issue in the urllib.parse component of Python before 3.11.4 allows attackers to bypass blocklisting methods by supplying a URL that starts with blank characters.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2023-24329"
}, {
  "versionRange" : "(,3.7.17)",
  "severity" : 7.5,
  "cveName" : "CVE-2023-24329",
  "description" : "An issue in the urllib.parse component of Python before 3.11.4 allows attackers to bypass blocklisting methods by supplying a URL that starts with blank characters.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2023-24329"
}, {
  "versionRange" : "[3.5.1,3.5.1]",
  "severity" : 9.8,
  "cveName" : "CVE-2016-5636",
  "description" : "Integer overflow in the get_data function in zipimport.c in CPython (aka Python) before 2.7.12, 3.x before 3.4.5, and 3.5.x before 3.5.2 allows remote attackers to have unspecified impact via a negative data size value, which triggers a heap-based buffer overflow.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-5636"
}, {
  "versionRange" : "[2.5.4,2.5.4]",
  "severity" : 7.5,
  "cveName" : "CVE-2014-1912",
  "description" : "Buffer overflow in the socket.recvfrom_into function in Modules/socketmodule.c in Python 2.5 before 2.7.7, 3.x before 3.3.4, and 3.4.x before 3.4rc1 allows remote attackers to execute arbitrary code via a crafted string.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-1912"
}, {
  "versionRange" : "[2.3.2,2.3.2]",
  "severity" : 5.0,
  "cveName" : "CVE-2012-0845",
  "description" : "SimpleXMLRPCServer.py in SimpleXMLRPCServer in Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 allows remote attackers to cause a denial of service (infinite loop and CPU consumption) via an XML-RPC POST request that contains a smaller amount of data than specified by the Content-Length header.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-0845"
}, {
  "versionRange" : "[2.6.6,2.6.6]",
  "severity" : 1.9,
  "cveName" : "CVE-2011-4944",
  "description" : "Python 2.6 through 3.2 creates ~/.pypirc with world-readable permissions before changing them after data has been written, which introduces a race condition that allows local users to obtain a username and password by reading this file.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-4944"
}, {
  "versionRange" : "[3.6.0,3.6.13)",
  "severity" : 5.7,
  "cveName" : "CVE-2021-3426",
  "description" : "There's a flaw in Python 3's pydoc. A local or adjacent attacker who discovers or is able to convince another local or adjacent user to start a pydoc server could access the server and use it to disclose sensitive information belonging to the other user that they would not normally be able to access. The highest risk of this flaw is to data confidentiality. This flaw affects Python versions before 3.8.9, Python versions before 3.9.3 and Python versions before 3.10.0a7.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2021-3426"
}, {
  "versionRange" : "[3.2.3,3.2.3]",
  "severity" : 6.5,
  "cveName" : "CVE-2016-0772",
  "description" : "The smtplib library in CPython (aka Python) before 2.7.12, 3.x before 3.4.5, and 3.5.x before 3.5.2 does not return an error when StartTLS fails, which might allow man-in-the-middle attackers to bypass the TLS protections by leveraging a network position between the client and the registry to block the StartTLS command, aka a \"StartTLS stripping attack.\"",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-0772"
}, {
  "versionRange" : "[3.3.2,3.3.2]",
  "severity" : 3.3,
  "cveName" : "CVE-2014-2667",
  "description" : "Race condition in the _get_masked_mode function in Lib/os.py in Python 3.2 through 3.5, when exist_ok is set to true and multiple threads are used, might allow local users to bypass intended file permissions by leveraging a separate application vulnerability before the umask has been set to the expected value.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-2667"
}, {
  "versionRange" : "[2.7.1,2.7.1]",
  "severity" : 7.5,
  "cveName" : "CVE-2014-1912",
  "description" : "Buffer overflow in the socket.recvfrom_into function in Modules/socketmodule.c in Python 2.5 before 2.7.7, 3.x before 3.3.4, and 3.4.x before 3.4rc1 allows remote attackers to execute arbitrary code via a crafted string.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-1912"
}, {
  "versionRange" : "[3.4.1,3.4.1]",
  "severity" : 6.5,
  "cveName" : "CVE-2016-0772",
  "description" : "The smtplib library in CPython (aka Python) before 2.7.12, 3.x before 3.4.5, and 3.5.x before 3.5.2 does not return an error when StartTLS fails, which might allow man-in-the-middle attackers to bypass the TLS protections by leveraging a network position between the client and the registry to block the StartTLS command, aka a \"StartTLS stripping attack.\"",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-0772"
}, {
  "versionRange" : "[3.8.0,3.8.7)",
  "severity" : 9.8,
  "cveName" : "CVE-2022-48565",
  "description" : "An XML External Entity (XXE) issue was discovered in Python through 3.9.1. The plistlib module no longer accepts entity declarations in XML plist files to avoid XML vulnerabilities.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2022-48565"
}, {
  "versionRange" : "[3.10.0,3.10.3)",
  "severity" : 6.5,
  "cveName" : "CVE-2016-3189",
  "description" : "Use-after-free vulnerability in bzip2recover in bzip2 1.0.6 allows remote attackers to cause a denial of service (crash) via a crafted bzip2 file, related to block ends set to before the start of the block.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-3189"
}, {
  "versionRange" : "[3.2.5,3.2.5]",
  "severity" : 3.3,
  "cveName" : "CVE-2014-2667",
  "description" : "Race condition in the _get_masked_mode function in Lib/os.py in Python 3.2 through 3.5, when exist_ok is set to true and multiple threads are used, might allow local users to bypass intended file permissions by leveraging a separate application vulnerability before the umask has been set to the expected value.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-2667"
}, {
  "versionRange" : "[3.7.0,3.7.0]",
  "severity" : 7.5,
  "cveName" : "CVE-2018-1061",
  "description" : "python before versions 2.7.15, 3.4.9, 3.5.6rc1, 3.6.5rc1 and 3.7.0 is vulnerable to catastrophic backtracking in the difflib.IS_LINE_JUNK method.  An attacker could use this flaw to cause denial of service.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2018-1061"
}, {
  "versionRange" : "[2.4.0,2.4.6)",
  "severity" : 7.5,
  "cveName" : "CVE-2008-1721",
  "description" : "Integer signedness error in the zlib extension module in Python 2.5.2 and earlier allows remote attackers to execute arbitrary code via a negative signed integer, which triggers insufficient memory allocation and a buffer overflow.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2008-1721"
}, {
  "versionRange" : "[3.8.0,3.8.5)",
  "severity" : 7.2,
  "cveName" : "CVE-2020-26116",
  "description" : "http.client in Python 3.x before 3.5.10, 3.6.x before 3.6.12, 3.7.x before 3.7.9, and 3.8.x before 3.8.5 allows CRLF injection if the attacker controls the HTTP request method, as demonstrated by inserting CR and LF control characters in the first argument of HTTPConnection.request.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2020-26116"
}, {
  "versionRange" : "[3.3,3.3]",
  "severity" : 5.9,
  "cveName" : "CVE-2013-7440",
  "description" : "The ssl.match_hostname function in CPython (aka Python) before 2.7.9 and 3.x before 3.3.3 does not properly handle wildcards in hostnames, which might allow man-in-the-middle attackers to spoof servers via a crafted certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-7440"
}, {
  "versionRange" : "[3.1.1,3.1.1]",
  "severity" : 6.5,
  "cveName" : "CVE-2016-0772",
  "description" : "The smtplib library in CPython (aka Python) before 2.7.12, 3.x before 3.4.5, and 3.5.x before 3.5.2 does not return an error when StartTLS fails, which might allow man-in-the-middle attackers to bypass the TLS protections by leveraging a network position between the client and the registry to block the StartTLS command, aka a \"StartTLS stripping attack.\"",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-0772"
}, {
  "versionRange" : "[2.1.2,2.1.2]",
  "severity" : 5.0,
  "cveName" : "CVE-2012-0845",
  "description" : "SimpleXMLRPCServer.py in SimpleXMLRPCServer in Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 allows remote attackers to cause a denial of service (infinite loop and CPU consumption) via an XML-RPC POST request that contains a smaller amount of data than specified by the Content-Length header.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-0845"
}, {
  "versionRange" : "[2.2.2,2.2.2]",
  "severity" : 5.0,
  "cveName" : "CVE-2012-0845",
  "description" : "SimpleXMLRPCServer.py in SimpleXMLRPCServer in Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 allows remote attackers to cause a denial of service (infinite loop and CPU consumption) via an XML-RPC POST request that contains a smaller amount of data than specified by the Content-Length header.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-0845"
}, {
  "versionRange" : "(,2.7.16]",
  "severity" : 7.8,
  "cveName" : "CVE-2019-13404",
  "description" : "The MSI installer for Python through 2.7.16 on Windows defaults to the C:\\Python27 directory, which makes it easier for local users to deploy Trojan horse code. (This also affects old 3.x releases before 3.5.) NOTE: the vendor's position is that it is the user's responsibility to ensure C:\\Python27 access control or choose a different directory, because backwards compatibility requires that C:\\Python27 remain the default for 2.7.x",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2019-13404"
}, {
  "versionRange" : "(,2.7]",
  "severity" : 5.0,
  "cveName" : "CVE-2010-3492",
  "description" : "The asyncore module in Python before 3.2 does not properly handle unsuccessful calls to the accept function, and does not have accompanying documentation describing how daemon applications should handle unsuccessful calls to the accept function, which makes it easier for remote attackers to conduct denial of service attacks that terminate these applications via network connections.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2010-3492"
}, {
  "versionRange" : "[2.7.4,2.7.4]",
  "severity" : 6.4,
  "cveName" : "CVE-2014-7185",
  "description" : "Integer overflow in bufferobject.c in Python before 2.7.8 allows context-dependent attackers to obtain sensitive information from process memory via a large size and offset in a \"buffer\" function.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-7185"
}, {
  "versionRange" : "[3.8.0,3.8.12)",
  "severity" : 9.8,
  "cveName" : "CVE-2021-29921",
  "description" : "In Python before 3,9,5, the ipaddress library mishandles leading zero characters in the octets of an IP address string. This (in some situations) allows attackers to bypass access control that is based on IP addresses.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2021-29921"
}, {
  "versionRange" : "[3.6.0,3.6.9)",
  "severity" : 5.3,
  "cveName" : "CVE-2018-20852",
  "description" : "http.cookiejar.DefaultPolicy.domain_return_ok in Lib/http/cookiejar.py in Python before 3.7.3 does not correctly validate the domain: it can be tricked into sending existing cookies to the wrong server. An attacker may abuse this flaw by using a server with a hostname that has another valid hostname as a suffix (e.g., pythonicexample.com to steal cookies for example.com). When a program uses http.cookiejar.DefaultPolicy and tries to do an HTTP connection to an attacker-controlled server, existing cookies can be leaked to the attacker. This affects 2.x through 2.7.16, 3.x before 3.4.10, 3.5.x before 3.5.7, 3.6.x before 3.6.9, and 3.7.x before 3.7.3.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2018-20852"
}, {
  "versionRange" : "[2.6.4,2.6.4]",
  "severity" : 2.6,
  "cveName" : "CVE-2011-4940",
  "description" : "The list_directory function in Lib/SimpleHTTPServer.py in SimpleHTTPServer in Python before 2.5.6c1, 2.6.x before 2.6.7 rc2, and 2.7.x before 2.7.2 does not place a charset parameter in the Content-Type HTTP header, which makes it easier for remote attackers to conduct cross-site scripting (XSS) attacks against Internet Explorer 7 via UTF-7 encoding.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-4940"
}, {
  "versionRange" : "[3.7.0,3.7.0]",
  "severity" : 6.7,
  "cveName" : "CVE-2018-1000117",
  "description" : "Python Software Foundation CPython version From 3.2 until 3.6.4 on Windows contains a Buffer Overflow vulnerability in os.symlink() function on Windows that can result in Arbitrary code execution, likely escalation of privilege. This attack appears to be exploitable via a python script that creates a symlink with an attacker controlled name or location. This vulnerability appears to have been fixed in 3.7.0 and 3.6.5.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2018-1000117"
}, {
  "versionRange" : "[3.7.0,3.7.9)",
  "severity" : 9.8,
  "cveName" : "CVE-2020-15801",
  "description" : "In Python 3.8.4, sys.path restrictions specified in a python38._pth file are ignored, allowing code to be loaded from arbitrary locations. The <executable-name>._pth file (e.g., the python._pth file) is not affected.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2020-15801"
}, {
  "versionRange" : "[2.7.0,2.7.13)",
  "severity" : 6.1,
  "cveName" : "CVE-2016-1000110",
  "description" : "The CGIHandler class in Python before 2.7.12 does not protect against the HTTP_PROXY variable name clash in a CGI script, which could allow a remote attacker to redirect HTTP requests.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-1000110"
}, {
  "versionRange" : "(,2.7.8]",
  "severity" : 5.9,
  "cveName" : "CVE-2013-7440",
  "description" : "The ssl.match_hostname function in CPython (aka Python) before 2.7.9 and 3.x before 3.3.3 does not properly handle wildcards in hostnames, which might allow man-in-the-middle attackers to spoof servers via a crafted certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-7440"
}, {
  "versionRange" : "[2.2.1,2.2.1]",
  "severity" : 6.4,
  "cveName" : "CVE-2011-1521",
  "description" : "The urllib and urllib2 modules in Python 2.x before 2.7.2 and 3.x before 3.2.1 process Location headers that specify redirection to file: URLs, which makes it easier for remote attackers to obtain sensitive information or cause a denial of service (resource consumption) via a crafted URL, as demonstrated by the file:///etc/passwd and file:///dev/zero URLs.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-1521"
}, {
  "versionRange" : "[2.7.0,2.7.16)",
  "severity" : 9.8,
  "cveName" : "CVE-2018-1000802",
  "description" : "Python Software Foundation Python (CPython) version 2.7 contains a CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection') vulnerability in shutil module (make_archive function) that can result in Denial of service, Information gain via injection of arbitrary files on the system or entire drive. This attack appear to be exploitable via Passage of unfiltered user input to the function. This vulnerability appears to have been fixed in after commit add531a1e55b0a739b0f42582f1c9747e5649ace.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2018-1000802"
}, {
  "versionRange" : "[3.9.0,3.9.0]",
  "severity" : 7.5,
  "cveName" : "CVE-2022-48560",
  "description" : "A use-after-free exists in Python through 3.9 via heappushpop in heapq.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2022-48560"
}, {
  "versionRange" : "[3.6.0,3.6.10]",
  "severity" : 6.5,
  "cveName" : "CVE-2020-8492",
  "description" : "Python 2.7 through 2.7.17, 3.5 through 3.5.9, 3.6 through 3.6.10, 3.7 through 3.7.6, and 3.8 through 3.8.1 allows an HTTP server to conduct Regular Expression Denial of Service (ReDoS) attacks against a client because of urllib.request.AbstractBasicAuthHandler catastrophic backtracking.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2020-8492"
}, {
  "versionRange" : "[3.6.0,3.6.0]",
  "severity" : 7.5,
  "cveName" : "CVE-2019-17514",
  "description" : "library/glob.html in the Python 2 and 3 documentation before 2016 has potentially misleading information about whether sorting occurs, as demonstrated by irreproducible cancer-research results. NOTE: the effects of this documentation cross application domains, and thus it is likely that security-relevant code elsewhere is affected. This issue is not a Python implementation bug, and there are no reports that NMR researchers were specifically relying on library/glob.html. In other words, because the older documentation stated \"finds all the pathnames matching a specified pattern according to the rules used by the Unix shell,\" one might have incorrectly inferred that the sorting that occurs in a Unix shell also occurred for glob.glob. There is a workaround in newer versions of Willoughby nmr-data_compilation-p2.py and nmr-data_compilation-p3.py, which call sort() directly.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2019-17514"
}, {
  "versionRange" : "[3.11.0,3.11.0]",
  "severity" : 7.0,
  "cveName" : "CVE-2022-26488",
  "description" : "In Python before 3.10.3 on Windows, local users can gain privileges because the search path is inadequately secured. The installer may allow a local attacker to add user-writable directories to the system search path. To exploit, an administrator must have installed Python for all users and enabled PATH entries. A non-administrative user can trigger a repair that incorrectly adds user-writable paths into PATH, enabling search-path hijacking of other users and system services. This affects Python (CPython) through 3.7.12, 3.8.x through 3.8.12, 3.9.x through 3.9.10, and 3.10.x through 3.10.2.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2022-26488"
}, {
  "versionRange" : "[3.4.3,3.4.3]",
  "severity" : 6.1,
  "cveName" : "CVE-2016-5699",
  "description" : "CRLF injection vulnerability in the HTTPConnection.putheader function in urllib2 and urllib in CPython (aka Python) before 2.7.10 and 3.x before 3.4.4 allows remote attackers to inject arbitrary HTTP headers via CRLF sequences in a URL.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-5699"
}, {
  "versionRange" : "[2.4.3,2.4.3]",
  "severity" : 5.0,
  "cveName" : "CVE-2012-1150",
  "description" : "Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 computes hash values without restricting the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-1150"
}, {
  "versionRange" : "[3.6.0,3.6.9)",
  "severity" : 9.1,
  "cveName" : "CVE-2019-9948",
  "description" : "urllib in Python 2.x through 2.7.16 supports the local_file: scheme, which makes it easier for remote attackers to bypass protection mechanisms that blacklist file: URIs, as demonstrated by triggering a urllib.urlopen('local_file:///etc/passwd') call.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2019-9948"
}, {
  "versionRange" : "[3.9.0,3.9.14)",
  "severity" : 7.5,
  "cveName" : "CVE-2020-10735",
  "description" : "A flaw was found in python. In algorithms with quadratic time complexity using non-binary bases, when using int(\"text\"), a system could take 50ms to parse an int string with 100,000 digits and 5s for 1,000,000 digits (float, decimal, int.from_bytes(), and int() for binary bases 2, 4, 8, 16, and 32 are not affected). The highest threat from this vulnerability is to system availability.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2020-10735"
}, {
  "versionRange" : "[3.11.0,3.11.5)",
  "severity" : 5.3,
  "cveName" : "CVE-2023-40217",
  "description" : "An issue was discovered in Python before 3.8.18, 3.9.x before 3.9.18, 3.10.x before 3.10.13, and 3.11.x before 3.11.5. It primarily affects servers (such as HTTP servers) that use TLS client authentication. If a TLS server-side socket is created, receives data into the socket buffer, and then is closed quickly, there is a brief window where the SSLSocket instance will detect the socket as \"not connected\" and won't initiate a handshake, but buffered data will still be readable from the socket buffer. This data will not be authenticated if the server-side TLS peer is expecting client certificate authentication, and is indistinguishable from valid TLS stream data. Data is limited in size to the amount that will fit in the buffer. (The TLS connection cannot directly be used for data exfiltration because the vulnerable code path requires that the connection be closed on initialization of the SSLSocket.)",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2023-40217"
}, {
  "versionRange" : "[2.4.6,2.4.6]",
  "severity" : 10.0,
  "cveName" : "CVE-2008-5031",
  "description" : "Multiple integer overflows in Python 2.2.3 through 2.5.1, and 2.6, allow context-dependent attackers to have an unknown impact via a large integer value in the tabsize argument to the expandtabs method, as implemented by (1) the string_expandtabs function in Objects/stringobject.c and (2) the unicode_expandtabs function in Objects/unicodeobject.c.  NOTE: this vulnerability reportedly exists because of an incomplete fix for CVE-2008-2315.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2008-5031"
}, {
  "versionRange" : "[2.3.7,2.3.7]",
  "severity" : 2.6,
  "cveName" : "CVE-2011-4940",
  "description" : "The list_directory function in Lib/SimpleHTTPServer.py in SimpleHTTPServer in Python before 2.5.6c1, 2.6.x before 2.6.7 rc2, and 2.7.x before 2.7.2 does not place a charset parameter in the Content-Type HTTP header, which makes it easier for remote attackers to conduct cross-site scripting (XSS) attacks against Internet Explorer 7 via UTF-7 encoding.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-4940"
}, {
  "versionRange" : "[2.2.1,2.2.1]",
  "severity" : 2.6,
  "cveName" : "CVE-2011-4940",
  "description" : "The list_directory function in Lib/SimpleHTTPServer.py in SimpleHTTPServer in Python before 2.5.6c1, 2.6.x before 2.6.7 rc2, and 2.7.x before 2.7.2 does not place a charset parameter in the Content-Type HTTP header, which makes it easier for remote attackers to conduct cross-site scripting (XSS) attacks against Internet Explorer 7 via UTF-7 encoding.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-4940"
}, {
  "versionRange" : "[3.4.0,3.4.0]",
  "severity" : 3.3,
  "cveName" : "CVE-2014-2667",
  "description" : "Race condition in the _get_masked_mode function in Lib/os.py in Python 3.2 through 3.5, when exist_ok is set to true and multiple threads are used, might allow local users to bypass intended file permissions by leveraging a separate application vulnerability before the umask has been set to the expected value.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-2667"
}, {
  "versionRange" : "[3.8.0,3.8.3)",
  "severity" : 6.1,
  "cveName" : "CVE-2019-18348",
  "description" : "An issue was discovered in urllib2 in Python 2.x through 2.7.17 and urllib in Python 3.x through 3.8.0. CRLF injection is possible if the attacker controls a url parameter, as demonstrated by the first argument to urllib.request.urlopen with \\r\\n (specifically in the host component of a URL) followed by an HTTP header. This is similar to the CVE-2019-9740 query string issue and the CVE-2019-9947 path string issue. (This is not exploitable when glibc has CVE-2016-10739 fixed.). This is fixed in: v2.7.18, v2.7.18rc1; v3.5.10, v3.5.10rc1; v3.6.11, v3.6.11rc1, v3.6.12; v3.7.8, v3.7.8rc1, v3.7.9; v3.8.3, v3.8.3rc1, v3.8.4, v3.8.4rc1, v3.8.5, v3.8.6, v3.8.6rc1.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2019-18348"
}, {
  "versionRange" : "[3.9.0,3.9.18)",
  "severity" : 5.3,
  "cveName" : "CVE-2023-40217",
  "description" : "An issue was discovered in Python before 3.8.18, 3.9.x before 3.9.18, 3.10.x before 3.10.13, and 3.11.x before 3.11.5. It primarily affects servers (such as HTTP servers) that use TLS client authentication. If a TLS server-side socket is created, receives data into the socket buffer, and then is closed quickly, there is a brief window where the SSLSocket instance will detect the socket as \"not connected\" and won't initiate a handshake, but buffered data will still be readable from the socket buffer. This data will not be authenticated if the server-side TLS peer is expecting client certificate authentication, and is indistinguishable from valid TLS stream data. Data is limited in size to the amount that will fit in the buffer. (The TLS connection cannot directly be used for data exfiltration because the vulnerable code path requires that the connection be closed on initialization of the SSLSocket.)",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2023-40217"
}, {
  "versionRange" : "[3.9.0,3.9.16)",
  "severity" : 7.8,
  "cveName" : "CVE-2022-42919",
  "description" : "Python 3.9.x before 3.9.16 and 3.10.x before 3.10.9 on Linux allows local privilege escalation in a non-default configuration. The Python multiprocessing library, when used with the forkserver start method on Linux, allows pickles to be deserialized from any user in the same machine local network namespace, which in many system configurations means any user on the same machine. Pickles can execute arbitrary code. Thus, this allows for local user privilege escalation to the user that any forkserver process is running as. Setting multiprocessing.util.abstract_sockets_supported to False is a workaround. The forkserver start method for multiprocessing is not the default start method. This issue is Linux specific because only Linux supports abstract namespace sockets. CPython before 3.9 does not make use of Linux abstract namespace sockets by default. Support for users manually specifying an abstract namespace socket was added as a bugfix in 3.7.8 and 3.8.3, but users would need to make specific uncommon API calls in order to do that in CPython before 3.9.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2022-42919"
}, {
  "versionRange" : "[3.1.3,3.1.3]",
  "severity" : 6.1,
  "cveName" : "CVE-2016-5699",
  "description" : "CRLF injection vulnerability in the HTTPConnection.putheader function in urllib2 and urllib in CPython (aka Python) before 2.7.10 and 3.x before 3.4.4 allows remote attackers to inject arbitrary HTTP headers via CRLF sequences in a URL.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-5699"
}, {
  "versionRange" : "[3.7.0,3.7.5)",
  "severity" : 6.1,
  "cveName" : "CVE-2019-16935",
  "description" : "The documentation XML-RPC server in Python through 2.7.16, 3.x through 3.6.9, and 3.7.x through 3.7.4 has XSS via the server_title field. This occurs in Lib/DocXMLRPCServer.py in Python 2.x, and in Lib/xmlrpc/server.py in Python 3.x. If set_server_title is called with untrusted input, arbitrary JavaScript can be delivered to clients that visit the http URL for this server.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2019-16935"
}, {
  "versionRange" : "[3.3.3,3.3.3]",
  "severity" : 7.5,
  "cveName" : "CVE-2014-1912",
  "description" : "Buffer overflow in the socket.recvfrom_into function in Modules/socketmodule.c in Python 2.5 before 2.7.7, 3.x before 3.3.4, and 3.4.x before 3.4rc1 allows remote attackers to execute arbitrary code via a crafted string.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-1912"
}, {
  "versionRange" : "[2.7.0,2.7.9)",
  "severity" : 7.5,
  "cveName" : "CVE-2013-1753",
  "description" : "The gzip_decode function in the xmlrpc client library in Python 3.4 and earlier allows remote attackers to cause a denial of service (memory consumption) via a crafted HTTP request.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-1753"
}, {
  "versionRange" : "[3.4,3.4]",
  "severity" : 4.3,
  "cveName" : "CVE-2013-4238",
  "description" : "The ssl.match_hostname function in the SSL module in Python 2.6 through 3.4 does not properly handle a '\\0' character in a domain name in the Subject Alternative Name field of an X.509 certificate, which allows man-in-the-middle attackers to spoof arbitrary SSL servers via a crafted certificate issued by a legitimate Certification Authority, a related issue to CVE-2009-2408.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-4238"
}, {
  "versionRange" : "[2.7.2,2.7.2]",
  "severity" : 4.3,
  "cveName" : "CVE-2013-4238",
  "description" : "The ssl.match_hostname function in the SSL module in Python 2.6 through 3.4 does not properly handle a '\\0' character in a domain name in the Subject Alternative Name field of an X.509 certificate, which allows man-in-the-middle attackers to spoof arbitrary SSL servers via a crafted certificate issued by a legitimate Certification Authority, a related issue to CVE-2009-2408.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-4238"
}, {
  "versionRange" : "[3.1.1,3.1.1]",
  "severity" : 5.9,
  "cveName" : "CVE-2013-7440",
  "description" : "The ssl.match_hostname function in CPython (aka Python) before 2.7.9 and 3.x before 3.3.3 does not properly handle wildcards in hostnames, which might allow man-in-the-middle attackers to spoof servers via a crafted certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-7440"
}, {
  "versionRange" : "[3.7.0,3.7.9)",
  "severity" : 5.9,
  "cveName" : "CVE-2020-14422",
  "description" : "Lib/ipaddress.py in Python through 3.8.3 improperly computes hash values in the IPv4Interface and IPv6Interface classes, which might allow a remote attacker to cause a denial of service if an application is affected by the performance of a dictionary containing IPv4Interface or IPv6Interface objects, and this attacker can cause many dictionary entries to be created. This is fixed in: v3.5.10, v3.5.10rc1; v3.6.12; v3.7.9; v3.8.4, v3.8.4rc1, v3.8.5, v3.8.6, v3.8.6rc1; v3.9.0, v3.9.0b4, v3.9.0b5, v3.9.0rc1, v3.9.0rc2.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2020-14422"
}, {
  "versionRange" : "[3.2.6,3.2.6]",
  "severity" : 3.3,
  "cveName" : "CVE-2014-2667",
  "description" : "Race condition in the _get_masked_mode function in Lib/os.py in Python 3.2 through 3.5, when exist_ok is set to true and multiple threads are used, might allow local users to bypass intended file permissions by leveraging a separate application vulnerability before the umask has been set to the expected value.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-2667"
}, {
  "versionRange" : "(,2.7.7]",
  "severity" : 6.4,
  "cveName" : "CVE-2014-7185",
  "description" : "Integer overflow in bufferobject.c in Python before 2.7.8 allows context-dependent attackers to obtain sensitive information from process memory via a large size and offset in a \"buffer\" function.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-7185"
}, {
  "versionRange" : "[2.7.0,2.7.15)",
  "severity" : 7.5,
  "cveName" : "CVE-2018-1060",
  "description" : "python before versions 2.7.15, 3.4.9, 3.5.6rc1, 3.6.5rc1 and 3.7.0 is vulnerable to catastrophic backtracking in pop3lib's apop() method. An attacker could use this flaw to cause denial of service.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2018-1060"
}, {
  "versionRange" : "[3.5.0,3.5.8)",
  "severity" : 6.1,
  "cveName" : "CVE-2019-9740",
  "description" : "An issue was discovered in urllib2 in Python 2.x through 2.7.16 and urllib in Python 3.x through 3.7.3. CRLF injection is possible if the attacker controls a url parameter, as demonstrated by the first argument to urllib.request.urlopen with \\r\\n (specifically in the query string after a ? character) followed by an HTTP header or a Redis command. This is fixed in: v2.7.17, v2.7.17rc1, v2.7.18, v2.7.18rc1; v3.5.10, v3.5.10rc1, v3.5.8, v3.5.8rc1, v3.5.8rc2, v3.5.9; v3.6.10, v3.6.10rc1, v3.6.11, v3.6.11rc1, v3.6.12, v3.6.9, v3.6.9rc1; v3.7.4, v3.7.4rc1, v3.7.4rc2, v3.7.5, v3.7.5rc1, v3.7.6, v3.7.6rc1, v3.7.7, v3.7.7rc1, v3.7.8, v3.7.8rc1, v3.7.9.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2019-9740"
}, {
  "versionRange" : "[3.7.0,3.7.4)",
  "severity" : 9.1,
  "cveName" : "CVE-2019-9948",
  "description" : "urllib in Python 2.x through 2.7.16 supports the local_file: scheme, which makes it easier for remote attackers to bypass protection mechanisms that blacklist file: URIs, as demonstrated by triggering a urllib.urlopen('local_file:///etc/passwd') call.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2019-9948"
}, {
  "versionRange" : "[3.1.2,3.1.2]",
  "severity" : 7.5,
  "cveName" : "CVE-2014-1912",
  "description" : "Buffer overflow in the socket.recvfrom_into function in Modules/socketmodule.c in Python 2.5 before 2.7.7, 3.x before 3.3.4, and 3.4.x before 3.4rc1 allows remote attackers to execute arbitrary code via a crafted string.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-1912"
}, {
  "versionRange" : "[3.5.0,3.5.4)",
  "severity" : 7.5,
  "cveName" : "CVE-2017-9233",
  "description" : "XML External Entity vulnerability in libexpat 2.2.0 and earlier (Expat XML Parser Library) allows attackers to put the parser in an infinite loop using a malformed external entity definition from an external DTD.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2017-9233"
}, {
  "versionRange" : "[2.4.6,2.4.6]",
  "severity" : 2.6,
  "cveName" : "CVE-2011-4940",
  "description" : "The list_directory function in Lib/SimpleHTTPServer.py in SimpleHTTPServer in Python before 2.5.6c1, 2.6.x before 2.6.7 rc2, and 2.7.x before 2.7.2 does not place a charset parameter in the Content-Type HTTP header, which makes it easier for remote attackers to conduct cross-site scripting (XSS) attacks against Internet Explorer 7 via UTF-7 encoding.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-4940"
}, {
  "versionRange" : "[3.3.5,3.3.5]",
  "severity" : 6.5,
  "cveName" : "CVE-2016-0772",
  "description" : "The smtplib library in CPython (aka Python) before 2.7.12, 3.x before 3.4.5, and 3.5.x before 3.5.2 does not return an error when StartTLS fails, which might allow man-in-the-middle attackers to bypass the TLS protections by leveraging a network position between the client and the registry to block the StartTLS command, aka a \"StartTLS stripping attack.\"",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-0772"
}, {
  "versionRange" : "[3.4.4,3.4.4]",
  "severity" : 9.8,
  "cveName" : "CVE-2016-5636",
  "description" : "Integer overflow in the get_data function in zipimport.c in CPython (aka Python) before 2.7.12, 3.x before 3.4.5, and 3.5.x before 3.5.2 allows remote attackers to have unspecified impact via a negative data size value, which triggers a heap-based buffer overflow.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-5636"
}, {
  "versionRange" : "(,2.7.18)",
  "severity" : 5.7,
  "cveName" : "CVE-2021-3426",
  "description" : "There's a flaw in Python 3's pydoc. A local or adjacent attacker who discovers or is able to convince another local or adjacent user to start a pydoc server could access the server and use it to disclose sensitive information belonging to the other user that they would not normally be able to access. The highest risk of this flaw is to data confidentiality. This flaw affects Python versions before 3.8.9, Python versions before 3.9.3 and Python versions before 3.10.0a7.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2021-3426"
}, {
  "versionRange" : "[3.1.1,3.1.1]",
  "severity" : 5.0,
  "cveName" : "CVE-2012-1150",
  "description" : "Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 computes hash values without restricting the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-1150"
}, {
  "versionRange" : "[3.3.6,3.3.6]",
  "severity" : 6.1,
  "cveName" : "CVE-2016-5699",
  "description" : "CRLF injection vulnerability in the HTTPConnection.putheader function in urllib2 and urllib in CPython (aka Python) before 2.7.10 and 3.x before 3.4.4 allows remote attackers to inject arbitrary HTTP headers via CRLF sequences in a URL.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-5699"
}, {
  "versionRange" : "[3.2.3,3.2.3]",
  "severity" : 9.8,
  "cveName" : "CVE-2016-5636",
  "description" : "Integer overflow in the get_data function in zipimport.c in CPython (aka Python) before 2.7.12, 3.x before 3.4.5, and 3.5.x before 3.5.2 allows remote attackers to have unspecified impact via a negative data size value, which triggers a heap-based buffer overflow.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-5636"
}, {
  "versionRange" : "[3.3.3,3.3.3]",
  "severity" : 3.3,
  "cveName" : "CVE-2014-2667",
  "description" : "Race condition in the _get_masked_mode function in Lib/os.py in Python 3.2 through 3.5, when exist_ok is set to true and multiple threads are used, might allow local users to bypass intended file permissions by leveraging a separate application vulnerability before the umask has been set to the expected value.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-2667"
}, {
  "versionRange" : "[3.10.0,3.10.3)",
  "severity" : 9.8,
  "cveName" : "CVE-2019-12900",
  "description" : "BZ2_decompress in decompress.c in bzip2 through 1.0.6 has an out-of-bounds write when there are many selectors.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2019-12900"
}, {
  "versionRange" : "[3.6.0,3.6.2)",
  "severity" : 8.1,
  "cveName" : "CVE-2016-4472",
  "description" : "The overflow protection in Expat is removed by compilers with certain optimization settings, which allows remote attackers to cause a denial of service (crash) or possibly execute arbitrary code via crafted XML data.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2015-1283 and CVE-2015-2716.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-4472"
}, {
  "versionRange" : "[2.4.2,2.4.2]",
  "severity" : 5.0,
  "cveName" : "CVE-2012-0845",
  "description" : "SimpleXMLRPCServer.py in SimpleXMLRPCServer in Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 allows remote attackers to cause a denial of service (infinite loop and CPU consumption) via an XML-RPC POST request that contains a smaller amount of data than specified by the Content-Length header.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-0845"
}, {
  "versionRange" : "[2.7.3,2.7.3]",
  "severity" : 1.9,
  "cveName" : "CVE-2011-4944",
  "description" : "Python 2.6 through 3.2 creates ~/.pypirc with world-readable permissions before changing them after data has been written, which introduces a race condition that allows local users to obtain a username and password by reading this file.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-4944"
}, {
  "versionRange" : "[3.2.1,3.2.1]",
  "severity" : 9.8,
  "cveName" : "CVE-2016-5636",
  "description" : "Integer overflow in the get_data function in zipimport.c in CPython (aka Python) before 2.7.12, 3.x before 3.4.5, and 3.5.x before 3.5.2 allows remote attackers to have unspecified impact via a negative data size value, which triggers a heap-based buffer overflow.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-5636"
}, {
  "versionRange" : "[3.8.0,3.8.13)",
  "severity" : 9.8,
  "cveName" : "CVE-2019-12900",
  "description" : "BZ2_decompress in decompress.c in bzip2 through 1.0.6 has an out-of-bounds write when there are many selectors.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2019-12900"
}, {
  "versionRange" : "[2.6.3,2.6.3]",
  "severity" : 4.3,
  "cveName" : "CVE-2013-4238",
  "description" : "The ssl.match_hostname function in the SSL module in Python 2.6 through 3.4 does not properly handle a '\\0' character in a domain name in the Subject Alternative Name field of an X.509 certificate, which allows man-in-the-middle attackers to spoof arbitrary SSL servers via a crafted certificate issued by a legitimate Certification Authority, a related issue to CVE-2009-2408.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-4238"
}, {
  "versionRange" : "[2.7.0,2.7.15)",
  "severity" : 9.8,
  "cveName" : "CVE-2016-0718",
  "description" : "Expat allows context-dependent attackers to cause a denial of service (crash) or possibly execute arbitrary code via a malformed input document, which triggers a buffer overflow.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-0718"
}, {
  "versionRange" : "[3.4.2,3.4.2]",
  "severity" : 9.8,
  "cveName" : "CVE-2016-5636",
  "description" : "Integer overflow in the get_data function in zipimport.c in CPython (aka Python) before 2.7.12, 3.x before 3.4.5, and 3.5.x before 3.5.2 allows remote attackers to have unspecified impact via a negative data size value, which triggers a heap-based buffer overflow.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-5636"
}, {
  "versionRange" : "[2.4.1,2.4.1]",
  "severity" : 2.6,
  "cveName" : "CVE-2011-4940",
  "description" : "The list_directory function in Lib/SimpleHTTPServer.py in SimpleHTTPServer in Python before 2.5.6c1, 2.6.x before 2.6.7 rc2, and 2.7.x before 2.7.2 does not place a charset parameter in the Content-Type HTTP header, which makes it easier for remote attackers to conduct cross-site scripting (XSS) attacks against Internet Explorer 7 via UTF-7 encoding.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-4940"
}, {
  "versionRange" : "[2.6.3,2.6.3]",
  "severity" : 5.0,
  "cveName" : "CVE-2012-0845",
  "description" : "SimpleXMLRPCServer.py in SimpleXMLRPCServer in Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 allows remote attackers to cause a denial of service (infinite loop and CPU consumption) via an XML-RPC POST request that contains a smaller amount of data than specified by the Content-Length header.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-0845"
}, {
  "versionRange" : "[2.0,2.7.17)",
  "severity" : 6.1,
  "cveName" : "CVE-2019-9740",
  "description" : "An issue was discovered in urllib2 in Python 2.x through 2.7.16 and urllib in Python 3.x through 3.7.3. CRLF injection is possible if the attacker controls a url parameter, as demonstrated by the first argument to urllib.request.urlopen with \\r\\n (specifically in the query string after a ? character) followed by an HTTP header or a Redis command. This is fixed in: v2.7.17, v2.7.17rc1, v2.7.18, v2.7.18rc1; v3.5.10, v3.5.10rc1, v3.5.8, v3.5.8rc1, v3.5.8rc2, v3.5.9; v3.6.10, v3.6.10rc1, v3.6.11, v3.6.11rc1, v3.6.12, v3.6.9, v3.6.9rc1; v3.7.4, v3.7.4rc1, v3.7.4rc2, v3.7.5, v3.7.5rc1, v3.7.6, v3.7.6rc1, v3.7.7, v3.7.7rc1, v3.7.8, v3.7.8rc1, v3.7.9.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2019-9740"
}, {
  "versionRange" : "[2.7.2,2.7.2]",
  "severity" : 5.0,
  "cveName" : "CVE-2012-0845",
  "description" : "SimpleXMLRPCServer.py in SimpleXMLRPCServer in Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 allows remote attackers to cause a denial of service (infinite loop and CPU consumption) via an XML-RPC POST request that contains a smaller amount of data than specified by the Content-Length header.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-0845"
}, {
  "versionRange" : "[3.3.1,3.3.1]",
  "severity" : 6.1,
  "cveName" : "CVE-2016-5699",
  "description" : "CRLF injection vulnerability in the HTTPConnection.putheader function in urllib2 and urllib in CPython (aka Python) before 2.7.10 and 3.x before 3.4.4 allows remote attackers to inject arbitrary HTTP headers via CRLF sequences in a URL.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-5699"
}, {
  "versionRange" : "[3.4.0,3.4.0]",
  "severity" : 9.8,
  "cveName" : "CVE-2016-5636",
  "description" : "Integer overflow in the get_data function in zipimport.c in CPython (aka Python) before 2.7.12, 3.x before 3.4.5, and 3.5.x before 3.5.2 allows remote attackers to have unspecified impact via a negative data size value, which triggers a heap-based buffer overflow.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-5636"
}, {
  "versionRange" : "[2.4.4,2.4.4]",
  "severity" : 2.6,
  "cveName" : "CVE-2011-4940",
  "description" : "The list_directory function in Lib/SimpleHTTPServer.py in SimpleHTTPServer in Python before 2.5.6c1, 2.6.x before 2.6.7 rc2, and 2.7.x before 2.7.2 does not place a charset parameter in the Content-Type HTTP header, which makes it easier for remote attackers to conduct cross-site scripting (XSS) attacks against Internet Explorer 7 via UTF-7 encoding.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-4940"
}, {
  "versionRange" : "[3.8.0,3.8.14)",
  "severity" : 7.5,
  "cveName" : "CVE-2018-25032",
  "description" : "zlib before 1.2.12 allows memory corruption when deflating (i.e., when compressing) if the input has many distant matches.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2018-25032"
}, {
  "versionRange" : "[3.0.1,3.0.1]",
  "severity" : 5.0,
  "cveName" : "CVE-2012-1150",
  "description" : "Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 computes hash values without restricting the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-1150"
}, {
  "versionRange" : "[3.1.1,3.1.1]",
  "severity" : 4.3,
  "cveName" : "CVE-2013-4238",
  "description" : "The ssl.match_hostname function in the SSL module in Python 2.6 through 3.4 does not properly handle a '\\0' character in a domain name in the Subject Alternative Name field of an X.509 certificate, which allows man-in-the-middle attackers to spoof arbitrary SSL servers via a crafted certificate issued by a legitimate Certification Authority, a related issue to CVE-2009-2408.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-4238"
}, {
  "versionRange" : "[3.4.1,3.4.1]",
  "severity" : 3.3,
  "cveName" : "CVE-2014-2667",
  "description" : "Race condition in the _get_masked_mode function in Lib/os.py in Python 3.2 through 3.5, when exist_ok is set to true and multiple threads are used, might allow local users to bypass intended file permissions by leveraging a separate application vulnerability before the umask has been set to the expected value.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-2667"
}, {
  "versionRange" : "[3.2.5,3.2.5]",
  "severity" : 4.3,
  "cveName" : "CVE-2013-2099",
  "description" : "Algorithmic complexity vulnerability in the ssl.match_hostname function in Python 3.2.x, 3.3.x, and earlier, and unspecified versions of python-backports-ssl_match_hostname as used for older Python versions, allows remote attackers to cause a denial of service (CPU consumption) via multiple wildcard characters in the common name in a certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-2099"
}, {
  "versionRange" : "[2.7.0,2.7.12)",
  "severity" : 6.8,
  "cveName" : "CVE-2015-1283",
  "description" : "Multiple integer overflows in the XML_GetBuffer function in Expat through 2.1.0, as used in Google Chrome before 44.0.2403.89 and other products, allow remote attackers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact via crafted XML data, a related issue to CVE-2015-2716.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2015-1283"
}, {
  "versionRange" : "[3.7.0,3.7.10)",
  "severity" : 6.5,
  "cveName" : "CVE-2022-48564",
  "description" : "read_ints in plistlib.py in Python through 3.9.1 is vulnerable to a potential DoS attack via CPU and RAM exhaustion when processing malformed Apple Property List files in binary format.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2022-48564"
}, {
  "versionRange" : "[3.1.3,3.1.3]",
  "severity" : 6.4,
  "cveName" : "CVE-2011-1521",
  "description" : "The urllib and urllib2 modules in Python 2.x before 2.7.2 and 3.x before 3.2.1 process Location headers that specify redirection to file: URLs, which makes it easier for remote attackers to obtain sensitive information or cause a denial of service (resource consumption) via a crafted URL, as demonstrated by the file:///etc/passwd and file:///dev/zero URLs.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-1521"
}, {
  "versionRange" : "(,2.7.9]",
  "severity" : 6.1,
  "cveName" : "CVE-2016-5699",
  "description" : "CRLF injection vulnerability in the HTTPConnection.putheader function in urllib2 and urllib in CPython (aka Python) before 2.7.10 and 3.x before 3.4.4 allows remote attackers to inject arbitrary HTTP headers via CRLF sequences in a URL.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-5699"
}, {
  "versionRange" : "[3.3.5,3.3.5]",
  "severity" : 4.3,
  "cveName" : "CVE-2013-7040",
  "description" : "Python 2.7 before 3.4 only uses the last eight bits of the prefix to randomize hash values, which causes it to compute hash values without restricting the ability to trigger hash collisions predictably and makes it easier for context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2012-1150.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-7040"
}, {
  "versionRange" : "[3.7.0,3.7.5)",
  "severity" : 7.5,
  "cveName" : "CVE-2019-15903",
  "description" : "In libexpat before 2.2.8, crafted XML input could fool the parser into changing from DTD parsing to document parsing too early; a consecutive call to XML_GetCurrentLineNumber (or XML_GetCurrentColumnNumber) then resulted in a heap-based buffer over-read.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2019-15903"
}, {
  "versionRange" : "[2.6.0,2.6.8)",
  "severity" : 4.3,
  "cveName" : "CVE-2012-0876",
  "description" : "The XML parser (xmlparse.c) in expat before 2.1.0 computes hash values without restricting the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via an XML file with many identifiers with the same value.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-0876"
}, {
  "versionRange" : "[3.3.0,3.3.0]",
  "severity" : 4.3,
  "cveName" : "CVE-2013-2099",
  "description" : "Algorithmic complexity vulnerability in the ssl.match_hostname function in Python 3.2.x, 3.3.x, and earlier, and unspecified versions of python-backports-ssl_match_hostname as used for older Python versions, allows remote attackers to cause a denial of service (CPU consumption) via multiple wildcard characters in the common name in a certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-2099"
}, {
  "versionRange" : "[3.5.0,3.5.5)",
  "severity" : 9.8,
  "cveName" : "CVE-2017-1000158",
  "description" : "CPython (aka Python) up to 2.7.13 is vulnerable to an integer overflow in the PyString_DecodeEscape function in stringobject.c, resulting in heap-based buffer overflow (and possible arbitrary code execution)",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2017-1000158"
}, {
  "versionRange" : "(,3.7.2]",
  "severity" : 7.5,
  "cveName" : "CVE-2019-9674",
  "description" : "Lib/zipfile.py in Python through 3.7.2 allows remote attackers to cause a denial of service (resource consumption) via a ZIP bomb.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2019-9674"
}, {
  "versionRange" : "[2.6.2,2.6.2]",
  "severity" : 5.0,
  "cveName" : "CVE-2012-0845",
  "description" : "SimpleXMLRPCServer.py in SimpleXMLRPCServer in Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 allows remote attackers to cause a denial of service (infinite loop and CPU consumption) via an XML-RPC POST request that contains a smaller amount of data than specified by the Content-Length header.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-0845"
}, {
  "versionRange" : "[3.7.0,3.7.8)",
  "severity" : 6.1,
  "cveName" : "CVE-2019-18348",
  "description" : "An issue was discovered in urllib2 in Python 2.x through 2.7.17 and urllib in Python 3.x through 3.8.0. CRLF injection is possible if the attacker controls a url parameter, as demonstrated by the first argument to urllib.request.urlopen with \\r\\n (specifically in the host component of a URL) followed by an HTTP header. This is similar to the CVE-2019-9740 query string issue and the CVE-2019-9947 path string issue. (This is not exploitable when glibc has CVE-2016-10739 fixed.). This is fixed in: v2.7.18, v2.7.18rc1; v3.5.10, v3.5.10rc1; v3.6.11, v3.6.11rc1, v3.6.12; v3.7.8, v3.7.8rc1, v3.7.9; v3.8.3, v3.8.3rc1, v3.8.4, v3.8.4rc1, v3.8.5, v3.8.6, v3.8.6rc1.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2019-18348"
}, {
  "versionRange" : "[3.4,3.4]",
  "severity" : 5.8,
  "cveName" : "CVE-2014-9365",
  "description" : "The HTTP clients in the (1) httplib, (2) urllib, (3) urllib2, and (4) xmlrpclib libraries in CPython (aka Python) 2.x before 2.7.9 and 3.x before 3.4.3, when accessing an HTTPS URL, do not (a) check the certificate against a trust store or verify that the server hostname matches a domain name in the subject's (b) Common Name or (c) subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-9365"
}, {
  "versionRange" : "[3.8.0,3.8.16)",
  "severity" : 9.8,
  "cveName" : "CVE-2022-37454",
  "description" : "The Keccak XKCP SHA-3 reference implementation before fdc6fef has an integer overflow and resultant buffer overflow that allows attackers to execute arbitrary code or eliminate expected cryptographic properties. This occurs in the sponge function interface.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2022-37454"
}, {
  "versionRange" : "[3.7.0,3.7.11)",
  "severity" : 7.5,
  "cveName" : "CVE-2021-3737",
  "description" : "A flaw was found in python. An improperly handled HTTP response in the HTTP client code of python may allow a remote attacker, who controls the HTTP server, to make the client script enter an infinite loop, consuming CPU time. The highest threat from this vulnerability is to system availability.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2021-3737"
}, {
  "versionRange" : "[3.3.0,3.3.7)",
  "severity" : 6.8,
  "cveName" : "CVE-2015-1283",
  "description" : "Multiple integer overflows in the XML_GetBuffer function in Expat through 2.1.0, as used in Google Chrome before 44.0.2403.89 and other products, allow remote attackers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact via crafted XML data, a related issue to CVE-2015-2716.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2015-1283"
}, {
  "versionRange" : "[3.3.4,3.3.4]",
  "severity" : 4.3,
  "cveName" : "CVE-2013-7040",
  "description" : "Python 2.7 before 3.4 only uses the last eight bits of the prefix to randomize hash values, which causes it to compute hash values without restricting the ability to trigger hash collisions predictably and makes it easier for context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2012-1150.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-7040"
}, {
  "versionRange" : "[3.0.1,3.0.1]",
  "severity" : 6.1,
  "cveName" : "CVE-2016-5699",
  "description" : "CRLF injection vulnerability in the HTTPConnection.putheader function in urllib2 and urllib in CPython (aka Python) before 2.7.10 and 3.x before 3.4.4 allows remote attackers to inject arbitrary HTTP headers via CRLF sequences in a URL.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-5699"
}, {
  "versionRange" : "[3.9.0,3.9.17)",
  "severity" : 6.8,
  "cveName" : "CVE-2007-4559",
  "description" : "Directory traversal vulnerability in the (1) extract and (2) extractall functions in the tarfile module in Python allows user-assisted remote attackers to overwrite arbitrary files via a .. (dot dot) sequence in filenames in a TAR archive, a related issue to CVE-2001-1267.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2007-4559"
}, {
  "versionRange" : "[3.5.0,3.5.7)",
  "severity" : 7.5,
  "cveName" : "CVE-2019-5010",
  "description" : "An exploitable denial-of-service vulnerability exists in the X509 certificate parser of Python.org Python 2.7.11 / 3.6.6. A specially crafted X509 certificate can cause a NULL pointer dereference, resulting in a denial of service. An attacker can initiate or accept TLS connections using crafted certificates to trigger this vulnerability.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2019-5010"
}, {
  "versionRange" : "[2.4.2,2.4.2]",
  "severity" : 5.0,
  "cveName" : "CVE-2012-1150",
  "description" : "Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 computes hash values without restricting the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-1150"
}, {
  "versionRange" : "[3.3.0,3.3.6)",
  "severity" : 7.5,
  "cveName" : "CVE-2013-1753",
  "description" : "The gzip_decode function in the xmlrpc client library in Python 3.4 and earlier allows remote attackers to cause a denial of service (memory consumption) via a crafted HTTP request.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-1753"
}, {
  "versionRange" : "[3.6.0,3.6.10)",
  "severity" : 7.5,
  "cveName" : "CVE-2019-15903",
  "description" : "In libexpat before 2.2.8, crafted XML input could fool the parser into changing from DTD parsing to document parsing too early; a consecutive call to XML_GetCurrentLineNumber (or XML_GetCurrentColumnNumber) then resulted in a heap-based buffer over-read.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2019-15903"
}, {
  "versionRange" : "[3.10.0,3.10.2]",
  "severity" : 7.0,
  "cveName" : "CVE-2022-26488",
  "description" : "In Python before 3.10.3 on Windows, local users can gain privileges because the search path is inadequately secured. The installer may allow a local attacker to add user-writable directories to the system search path. To exploit, an administrator must have installed Python for all users and enabled PATH entries. A non-administrative user can trigger a repair that incorrectly adds user-writable paths into PATH, enabling search-path hijacking of other users and system services. This affects Python (CPython) through 3.7.12, 3.8.x through 3.8.12, 3.9.x through 3.9.10, and 3.10.x through 3.10.2.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2022-26488"
}, {
  "versionRange" : "[3.3.4,3.3.4]",
  "severity" : 3.3,
  "cveName" : "CVE-2014-2667",
  "description" : "Race condition in the _get_masked_mode function in Lib/os.py in Python 3.2 through 3.5, when exist_ok is set to true and multiple threads are used, might allow local users to bypass intended file permissions by leveraging a separate application vulnerability before the umask has been set to the expected value.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-2667"
}, {
  "versionRange" : "[3.1.5,3.1.5]",
  "severity" : 1.9,
  "cveName" : "CVE-2011-4944",
  "description" : "Python 2.6 through 3.2 creates ~/.pypirc with world-readable permissions before changing them after data has been written, which introduces a race condition that allows local users to obtain a username and password by reading this file.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-4944"
}, {
  "versionRange" : "[3.11.0,3.11.4)",
  "severity" : 6.8,
  "cveName" : "CVE-2007-4559",
  "description" : "Directory traversal vulnerability in the (1) extract and (2) extractall functions in the tarfile module in Python allows user-assisted remote attackers to overwrite arbitrary files via a .. (dot dot) sequence in filenames in a TAR archive, a related issue to CVE-2001-1267.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2007-4559"
}, {
  "versionRange" : "[3.9.0,3.9.3)",
  "severity" : 5.3,
  "cveName" : "CVE-2021-4189",
  "description" : "A flaw was found in Python, specifically in the FTP (File Transfer Protocol) client library in PASV (passive) mode. The issue is how the FTP client trusts the host from the PASV response by default. This flaw allows an attacker to set up a malicious FTP server that can trick FTP clients into connecting back to a given IP address and port. This vulnerability could lead to FTP client scanning ports, which otherwise would not have been possible.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2021-4189"
}, {
  "versionRange" : "[3.8.0,3.8.7)",
  "severity" : 5.9,
  "cveName" : "CVE-2022-48566",
  "description" : "An issue was discovered in compare_digest in Lib/hmac.py in Python through 3.9.1. Constant-time-defeating optimisations were possible in the accumulator variable in hmac.compare_digest.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2022-48566"
}, {
  "versionRange" : "[2.7.1,2.7.1]",
  "severity" : 6.4,
  "cveName" : "CVE-2011-1521",
  "description" : "The urllib and urllib2 modules in Python 2.x before 2.7.2 and 3.x before 3.2.1 process Location headers that specify redirection to file: URLs, which makes it easier for remote attackers to obtain sensitive information or cause a denial of service (resource consumption) via a crafted URL, as demonstrated by the file:///etc/passwd and file:///dev/zero URLs.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-1521"
}, {
  "versionRange" : "[3.6.0,3.6.12)",
  "severity" : 7.2,
  "cveName" : "CVE-2020-26116",
  "description" : "http.client in Python 3.x before 3.5.10, 3.6.x before 3.6.12, 3.7.x before 3.7.9, and 3.8.x before 3.8.5 allows CRLF injection if the attacker controls the HTTP request method, as demonstrated by inserting CR and LF control characters in the first argument of HTTPConnection.request.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2020-26116"
}, {
  "versionRange" : "[3.5.0,3.5.8)",
  "severity" : 6.1,
  "cveName" : "CVE-2019-9947",
  "description" : "An issue was discovered in urllib2 in Python 2.x through 2.7.16 and urllib in Python 3.x through 3.7.3. CRLF injection is possible if the attacker controls a url parameter, as demonstrated by the first argument to urllib.request.urlopen with \\r\\n (specifically in the path component of a URL that lacks a ? character) followed by an HTTP header or a Redis command. This is similar to the CVE-2019-9740 query string issue. This is fixed in: v2.7.17, v2.7.17rc1, v2.7.18, v2.7.18rc1; v3.5.10, v3.5.10rc1, v3.5.8, v3.5.8rc1, v3.5.8rc2, v3.5.9; v3.6.10, v3.6.10rc1, v3.6.11, v3.6.11rc1, v3.6.12, v3.6.9, v3.6.9rc1; v3.7.4, v3.7.4rc1, v3.7.4rc2, v3.7.5, v3.7.5rc1, v3.7.6, v3.7.6rc1, v3.7.7, v3.7.7rc1, v3.7.8, v3.7.8rc1, v3.7.9.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2019-9947"
}, {
  "versionRange" : "[3.2.3,3.2.3]",
  "severity" : 4.3,
  "cveName" : "CVE-2013-4238",
  "description" : "The ssl.match_hostname function in the SSL module in Python 2.6 through 3.4 does not properly handle a '\\0' character in a domain name in the Subject Alternative Name field of an X.509 certificate, which allows man-in-the-middle attackers to spoof arbitrary SSL servers via a crafted certificate issued by a legitimate Certification Authority, a related issue to CVE-2009-2408.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-4238"
}, {
  "versionRange" : "[2.6.8,2.6.8]",
  "severity" : 5.8,
  "cveName" : "CVE-2014-9365",
  "description" : "The HTTP clients in the (1) httplib, (2) urllib, (3) urllib2, and (4) xmlrpclib libraries in CPython (aka Python) 2.x before 2.7.9 and 3.x before 3.4.3, when accessing an HTTPS URL, do not (a) check the certificate against a trust store or verify that the server hostname matches a domain name in the subject's (b) Common Name or (c) subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-9365"
}, {
  "versionRange" : "[3.1.5,3.1.5]",
  "severity" : 4.3,
  "cveName" : "CVE-2013-7040",
  "description" : "Python 2.7 before 3.4 only uses the last eight bits of the prefix to randomize hash values, which causes it to compute hash values without restricting the ability to trigger hash collisions predictably and makes it easier for context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2012-1150.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-7040"
}, {
  "versionRange" : "[3.4.0,3.4.0]",
  "severity" : 6.5,
  "cveName" : "CVE-2016-0772",
  "description" : "The smtplib library in CPython (aka Python) before 2.7.12, 3.x before 3.4.5, and 3.5.x before 3.5.2 does not return an error when StartTLS fails, which might allow man-in-the-middle attackers to bypass the TLS protections by leveraging a network position between the client and the registry to block the StartTLS command, aka a \"StartTLS stripping attack.\"",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-0772"
}, {
  "versionRange" : "[3.1.2,3.1.2]",
  "severity" : 5.0,
  "cveName" : "CVE-2012-0845",
  "description" : "SimpleXMLRPCServer.py in SimpleXMLRPCServer in Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 allows remote attackers to cause a denial of service (infinite loop and CPU consumption) via an XML-RPC POST request that contains a smaller amount of data than specified by the Content-Length header.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-0845"
}, {
  "versionRange" : "[3.1.4,3.1.4]",
  "severity" : 5.8,
  "cveName" : "CVE-2014-9365",
  "description" : "The HTTP clients in the (1) httplib, (2) urllib, (3) urllib2, and (4) xmlrpclib libraries in CPython (aka Python) 2.x before 2.7.9 and 3.x before 3.4.3, when accessing an HTTPS URL, do not (a) check the certificate against a trust store or verify that the server hostname matches a domain name in the subject's (b) Common Name or (c) subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-9365"
}, {
  "versionRange" : "[3.6.0,3.6.11)",
  "severity" : 6.1,
  "cveName" : "CVE-2019-18348",
  "description" : "An issue was discovered in urllib2 in Python 2.x through 2.7.17 and urllib in Python 3.x through 3.8.0. CRLF injection is possible if the attacker controls a url parameter, as demonstrated by the first argument to urllib.request.urlopen with \\r\\n (specifically in the host component of a URL) followed by an HTTP header. This is similar to the CVE-2019-9740 query string issue and the CVE-2019-9947 path string issue. (This is not exploitable when glibc has CVE-2016-10739 fixed.). This is fixed in: v2.7.18, v2.7.18rc1; v3.5.10, v3.5.10rc1; v3.6.11, v3.6.11rc1, v3.6.12; v3.7.8, v3.7.8rc1, v3.7.9; v3.8.3, v3.8.3rc1, v3.8.4, v3.8.4rc1, v3.8.5, v3.8.6, v3.8.6rc1.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2019-18348"
}, {
  "versionRange" : "[3.3.2,3.3.2]",
  "severity" : 6.1,
  "cveName" : "CVE-2016-5699",
  "description" : "CRLF injection vulnerability in the HTTPConnection.putheader function in urllib2 and urllib in CPython (aka Python) before 2.7.10 and 3.x before 3.4.4 allows remote attackers to inject arbitrary HTTP headers via CRLF sequences in a URL.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-5699"
}, {
  "versionRange" : "[3.4.0,3.4.1)",
  "severity" : 5.9,
  "cveName" : "CVE-2014-4616",
  "description" : "Array index error in the scanstring function in the _json module in Python 2.7 through 3.5 and simplejson before 2.6.1 allows context-dependent attackers to read arbitrary process memory via a negative index value in the idx argument to the raw_decode function.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-4616"
}, {
  "versionRange" : "[2.7.0,2.7.17)",
  "severity" : 9.8,
  "cveName" : "CVE-2019-9636",
  "description" : "Python 2.7.x through 2.7.16 and 3.x through 3.7.2 is affected by: Improper Handling of Unicode Encoding (with an incorrect netloc) during NFKC normalization. The impact is: Information disclosure (credentials, cookies, etc. that are cached against a given hostname). The components are: urllib.parse.urlsplit, urllib.parse.urlparse. The attack vector is: A specially crafted URL could be incorrectly parsed to locate cookies or authentication data and send that information to a different host than when parsed correctly. This is fixed in: v2.7.17, v2.7.17rc1, v2.7.18, v2.7.18rc1; v3.5.10, v3.5.10rc1, v3.5.7, v3.5.8, v3.5.8rc1, v3.5.8rc2, v3.5.9; v3.6.10, v3.6.10rc1, v3.6.11, v3.6.11rc1, v3.6.12, v3.6.9, v3.6.9rc1; v3.7.3, v3.7.3rc1, v3.7.4, v3.7.4rc1, v3.7.4rc2, v3.7.5, v3.7.5rc1, v3.7.6, v3.7.6rc1, v3.7.7, v3.7.7rc1, v3.7.8, v3.7.8rc1, v3.7.9.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2019-9636"
}, {
  "versionRange" : "[3.1.4,3.1.4]",
  "severity" : 4.3,
  "cveName" : "CVE-2013-7040",
  "description" : "Python 2.7 before 3.4 only uses the last eight bits of the prefix to randomize hash values, which causes it to compute hash values without restricting the ability to trigger hash collisions predictably and makes it easier for context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2012-1150.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-7040"
}, {
  "versionRange" : "[3.5.0,3.5.5]",
  "severity" : 7.5,
  "cveName" : "CVE-2018-1061",
  "description" : "python before versions 2.7.15, 3.4.9, 3.5.6rc1, 3.6.5rc1 and 3.7.0 is vulnerable to catastrophic backtracking in the difflib.IS_LINE_JUNK method.  An attacker could use this flaw to cause denial of service.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2018-1061"
}, {
  "versionRange" : "[2.1.2,2.1.2]",
  "severity" : 5.8,
  "cveName" : "CVE-2014-9365",
  "description" : "The HTTP clients in the (1) httplib, (2) urllib, (3) urllib2, and (4) xmlrpclib libraries in CPython (aka Python) 2.x before 2.7.9 and 3.x before 3.4.3, when accessing an HTTPS URL, do not (a) check the certificate against a trust store or verify that the server hostname matches a domain name in the subject's (b) Common Name or (c) subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-9365"
}, {
  "versionRange" : "[2.4.5,2.4.5]",
  "severity" : 7.2,
  "cveName" : "CVE-2008-4108",
  "description" : "Tools/faqwiz/move-faqwiz.sh (aka the generic FAQ wizard moving tool) in Python 2.4.5 might allow local users to overwrite arbitrary files via a symlink attack on a tmp$RANDOM.tmp temporary file.  NOTE: there may not be common usage scenarios in which tmp$RANDOM.tmp is located in an untrusted directory.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2008-4108"
}, {
  "versionRange" : "[3.3.3,3.3.3]",
  "severity" : 4.3,
  "cveName" : "CVE-2013-7040",
  "description" : "Python 2.7 before 3.4 only uses the last eight bits of the prefix to randomize hash values, which causes it to compute hash values without restricting the ability to trigger hash collisions predictably and makes it easier for context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2012-1150.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-7040"
}, {
  "versionRange" : "[3.3.4,3.3.4]",
  "severity" : 6.5,
  "cveName" : "CVE-2016-0772",
  "description" : "The smtplib library in CPython (aka Python) before 2.7.12, 3.x before 3.4.5, and 3.5.x before 3.5.2 does not return an error when StartTLS fails, which might allow man-in-the-middle attackers to bypass the TLS protections by leveraging a network position between the client and the registry to block the StartTLS command, aka a \"StartTLS stripping attack.\"",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-0772"
}, {
  "versionRange" : "[2.6.1,2.6.1]",
  "severity" : 1.9,
  "cveName" : "CVE-2011-4944",
  "description" : "Python 2.6 through 3.2 creates ~/.pypirc with world-readable permissions before changing them after data has been written, which introduces a race condition that allows local users to obtain a username and password by reading this file.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-4944"
}, {
  "versionRange" : "[3.3.1,3.3.1]",
  "severity" : 3.3,
  "cveName" : "CVE-2014-2667",
  "description" : "Race condition in the _get_masked_mode function in Lib/os.py in Python 3.2 through 3.5, when exist_ok is set to true and multiple threads are used, might allow local users to bypass intended file permissions by leveraging a separate application vulnerability before the umask has been set to the expected value.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-2667"
}, {
  "versionRange" : "[3.3.2,3.3.2]",
  "severity" : 4.3,
  "cveName" : "CVE-2013-7040",
  "description" : "Python 2.7 before 3.4 only uses the last eight bits of the prefix to randomize hash values, which causes it to compute hash values without restricting the ability to trigger hash collisions predictably and makes it easier for context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2012-1150.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-7040"
}, {
  "versionRange" : "[2.6.6,2.6.6]",
  "severity" : 6.4,
  "cveName" : "CVE-2011-1521",
  "description" : "The urllib and urllib2 modules in Python 2.x before 2.7.2 and 3.x before 3.2.1 process Location headers that specify redirection to file: URLs, which makes it easier for remote attackers to obtain sensitive information or cause a denial of service (resource consumption) via a crafted URL, as demonstrated by the file:///etc/passwd and file:///dev/zero URLs.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-1521"
}, {
  "versionRange" : "[3.0,3.4.9)",
  "severity" : 7.5,
  "cveName" : "CVE-2018-1061",
  "description" : "python before versions 2.7.15, 3.4.9, 3.5.6rc1, 3.6.5rc1 and 3.7.0 is vulnerable to catastrophic backtracking in the difflib.IS_LINE_JUNK method.  An attacker could use this flaw to cause denial of service.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2018-1061"
}, {
  "versionRange" : "[2.6.2,2.6.2]",
  "severity" : 1.9,
  "cveName" : "CVE-2011-4944",
  "description" : "Python 2.6 through 3.2 creates ~/.pypirc with world-readable permissions before changing them after data has been written, which introduces a race condition that allows local users to obtain a username and password by reading this file.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-4944"
}, {
  "versionRange" : "[3.2.1,3.2.1]",
  "severity" : 5.9,
  "cveName" : "CVE-2013-7440",
  "description" : "The ssl.match_hostname function in CPython (aka Python) before 2.7.9 and 3.x before 3.3.3 does not properly handle wildcards in hostnames, which might allow man-in-the-middle attackers to spoof servers via a crafted certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-7440"
}, {
  "versionRange" : "[3.2.2,3.2.2]",
  "severity" : 7.5,
  "cveName" : "CVE-2014-1912",
  "description" : "Buffer overflow in the socket.recvfrom_into function in Modules/socketmodule.c in Python 2.5 before 2.7.7, 3.x before 3.3.4, and 3.4.x before 3.4rc1 allows remote attackers to execute arbitrary code via a crafted string.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-1912"
}, {
  "versionRange" : "[3.1.3,3.1.3]",
  "severity" : 4.3,
  "cveName" : "CVE-2013-7040",
  "description" : "Python 2.7 before 3.4 only uses the last eight bits of the prefix to randomize hash values, which causes it to compute hash values without restricting the ability to trigger hash collisions predictably and makes it easier for context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2012-1150.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-7040"
}, {
  "versionRange" : "[3.1.2,3.1.2]",
  "severity" : 9.8,
  "cveName" : "CVE-2016-5636",
  "description" : "Integer overflow in the get_data function in zipimport.c in CPython (aka Python) before 2.7.12, 3.x before 3.4.5, and 3.5.x before 3.5.2 allows remote attackers to have unspecified impact via a negative data size value, which triggers a heap-based buffer overflow.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-5636"
}, {
  "versionRange" : "[3.1.4,3.1.4]",
  "severity" : 1.9,
  "cveName" : "CVE-2011-4944",
  "description" : "Python 2.6 through 3.2 creates ~/.pypirc with world-readable permissions before changing them after data has been written, which introduces a race condition that allows local users to obtain a username and password by reading this file.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-4944"
}, {
  "versionRange" : "[3.2.4,3.2.4]",
  "severity" : 3.3,
  "cveName" : "CVE-2014-2667",
  "description" : "Race condition in the _get_masked_mode function in Lib/os.py in Python 3.2 through 3.5, when exist_ok is set to true and multiple threads are used, might allow local users to bypass intended file permissions by leveraging a separate application vulnerability before the umask has been set to the expected value.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-2667"
}, {
  "versionRange" : "[3.1.2,3.1.2]",
  "severity" : 5.8,
  "cveName" : "CVE-2014-9365",
  "description" : "The HTTP clients in the (1) httplib, (2) urllib, (3) urllib2, and (4) xmlrpclib libraries in CPython (aka Python) 2.x before 2.7.9 and 3.x before 3.4.3, when accessing an HTTPS URL, do not (a) check the certificate against a trust store or verify that the server hostname matches a domain name in the subject's (b) Common Name or (c) subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-9365"
}, {
  "versionRange" : "[3.11.0,3.11.0]",
  "severity" : 7.4,
  "cveName" : "CVE-2021-28861",
  "description" : "Python 3.x through 3.10 has an open redirection vulnerability in lib/http/server.py due to no protection against multiple (/) at the beginning of URI path which may leads to information disclosure. NOTE: this is disputed by a third party because the http.server.html documentation page states \"Warning: http.server is not recommended for production. It only implements basic security checks.\"",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2021-28861"
}, {
  "versionRange" : "[3.0.0,3.2.6)",
  "severity" : 5.9,
  "cveName" : "CVE-2014-4616",
  "description" : "Array index error in the scanstring function in the _json module in Python 2.7 through 3.5 and simplejson before 2.6.1 allows context-dependent attackers to read arbitrary process memory via a negative index value in the idx argument to the raw_decode function.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-4616"
}, {
  "versionRange" : "[3.8.3,3.8.15]",
  "severity" : 7.8,
  "cveName" : "CVE-2022-42919",
  "description" : "Python 3.9.x before 3.9.16 and 3.10.x before 3.10.9 on Linux allows local privilege escalation in a non-default configuration. The Python multiprocessing library, when used with the forkserver start method on Linux, allows pickles to be deserialized from any user in the same machine local network namespace, which in many system configurations means any user on the same machine. Pickles can execute arbitrary code. Thus, this allows for local user privilege escalation to the user that any forkserver process is running as. Setting multiprocessing.util.abstract_sockets_supported to False is a workaround. The forkserver start method for multiprocessing is not the default start method. This issue is Linux specific because only Linux supports abstract namespace sockets. CPython before 3.9 does not make use of Linux abstract namespace sockets by default. Support for users manually specifying an abstract namespace socket was added as a bugfix in 3.7.8 and 3.8.3, but users would need to make specific uncommon API calls in order to do that in CPython before 3.9.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2022-42919"
}, {
  "versionRange" : "[3.1.4,3.1.4]",
  "severity" : 9.8,
  "cveName" : "CVE-2016-5636",
  "description" : "Integer overflow in the get_data function in zipimport.c in CPython (aka Python) before 2.7.12, 3.x before 3.4.5, and 3.5.x before 3.5.2 allows remote attackers to have unspecified impact via a negative data size value, which triggers a heap-based buffer overflow.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-5636"
}, {
  "versionRange" : "[3.10.0,3.10.12)",
  "severity" : 7.5,
  "cveName" : "CVE-2023-24329",
  "description" : "An issue in the urllib.parse component of Python before 3.11.4 allows attackers to bypass blocklisting methods by supplying a URL that starts with blank characters.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2023-24329"
}, {
  "versionRange" : "[3.2.3,3.2.3]",
  "severity" : 7.5,
  "cveName" : "CVE-2014-1912",
  "description" : "Buffer overflow in the socket.recvfrom_into function in Modules/socketmodule.c in Python 2.5 before 2.7.7, 3.x before 3.3.4, and 3.4.x before 3.4rc1 allows remote attackers to execute arbitrary code via a crafted string.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-1912"
}, {
  "versionRange" : "[3.3.0,3.3.7)",
  "severity" : 8.1,
  "cveName" : "CVE-2016-4472",
  "description" : "The overflow protection in Expat is removed by compilers with certain optimization settings, which allows remote attackers to cause a denial of service (crash) or possibly execute arbitrary code via crafted XML data.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2015-1283 and CVE-2015-2716.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-4472"
}, {
  "versionRange" : "[3.8.0,3.8.15]",
  "severity" : 7.5,
  "cveName" : "CVE-2022-45061",
  "description" : "An issue was discovered in Python before 3.11.1. An unnecessary quadratic algorithm exists in one path when processing some inputs to the IDNA (RFC 3490) decoder, such that a crafted, unreasonably long name being presented to the decoder could lead to a CPU denial of service. Hostnames are often supplied by remote servers that could be controlled by a malicious actor; in such a scenario, they could trigger excessive CPU consumption on the client attempting to make use of an attacker-supplied supposed hostname. For example, the attack payload could be placed in the Location header of an HTTP response with status code 302. A fix is planned in 3.11.1, 3.10.9, 3.9.16, 3.8.16, and 3.7.16.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2022-45061"
}, {
  "versionRange" : "[2.3.3,2.3.3]",
  "severity" : 6.4,
  "cveName" : "CVE-2011-1521",
  "description" : "The urllib and urllib2 modules in Python 2.x before 2.7.2 and 3.x before 3.2.1 process Location headers that specify redirection to file: URLs, which makes it easier for remote attackers to obtain sensitive information or cause a denial of service (resource consumption) via a crafted URL, as demonstrated by the file:///etc/passwd and file:///dev/zero URLs.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-1521"
}, {
  "versionRange" : "[3.3.1,3.3.1]",
  "severity" : 4.3,
  "cveName" : "CVE-2013-7040",
  "description" : "Python 2.7 before 3.4 only uses the last eight bits of the prefix to randomize hash values, which causes it to compute hash values without restricting the ability to trigger hash collisions predictably and makes it easier for context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2012-1150.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-7040"
}, {
  "versionRange" : "[3.2.2,3.2.2]",
  "severity" : 6.5,
  "cveName" : "CVE-2016-0772",
  "description" : "The smtplib library in CPython (aka Python) before 2.7.12, 3.x before 3.4.5, and 3.5.x before 3.5.2 does not return an error when StartTLS fails, which might allow man-in-the-middle attackers to bypass the TLS protections by leveraging a network position between the client and the registry to block the StartTLS command, aka a \"StartTLS stripping attack.\"",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-0772"
}, {
  "versionRange" : "[3.3.5,3.3.5]",
  "severity" : 9.8,
  "cveName" : "CVE-2016-5636",
  "description" : "Integer overflow in the get_data function in zipimport.c in CPython (aka Python) before 2.7.12, 3.x before 3.4.5, and 3.5.x before 3.5.2 allows remote attackers to have unspecified impact via a negative data size value, which triggers a heap-based buffer overflow.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-5636"
}, {
  "versionRange" : "[3.1.2,3.1.2]",
  "severity" : 4.3,
  "cveName" : "CVE-2013-7040",
  "description" : "Python 2.7 before 3.4 only uses the last eight bits of the prefix to randomize hash values, which causes it to compute hash values without restricting the ability to trigger hash collisions predictably and makes it easier for context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2012-1150.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-7040"
}, {
  "versionRange" : "(,3.6.13)",
  "severity" : 5.9,
  "cveName" : "CVE-2021-23336",
  "description" : "The package python/cpython from 0 and before 3.6.13, from 3.7.0 and before 3.7.10, from 3.8.0 and before 3.8.8, from 3.9.0 and before 3.9.2 are vulnerable to Web Cache Poisoning via urllib.parse.parse_qsl and urllib.parse.parse_qs by using a vector called parameter cloaking. When the attacker can separate query parameters using a semicolon (;), they can cause a difference in the interpretation of the request between the proxy (running with default configuration) and the server. This can result in malicious requests being cached as completely safe ones, as the proxy would usually not see the semicolon as a separator, and therefore would not include it in a cache key of an unkeyed parameter.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2021-23336"
}, {
  "versionRange" : "[2.5.2,2.5.2]",
  "severity" : 2.6,
  "cveName" : "CVE-2011-4940",
  "description" : "The list_directory function in Lib/SimpleHTTPServer.py in SimpleHTTPServer in Python before 2.5.6c1, 2.6.x before 2.6.7 rc2, and 2.7.x before 2.7.2 does not place a charset parameter in the Content-Type HTTP header, which makes it easier for remote attackers to conduct cross-site scripting (XSS) attacks against Internet Explorer 7 via UTF-7 encoding.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-4940"
}, {
  "versionRange" : "[2.5.1,2.5.1]",
  "severity" : 7.5,
  "cveName" : "CVE-2014-1912",
  "description" : "Buffer overflow in the socket.recvfrom_into function in Modules/socketmodule.c in Python 2.5 before 2.7.7, 3.x before 3.3.4, and 3.4.x before 3.4rc1 allows remote attackers to execute arbitrary code via a crafted string.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-1912"
}, {
  "versionRange" : "[3.3.1,3.3.1]",
  "severity" : 9.8,
  "cveName" : "CVE-2016-5636",
  "description" : "Integer overflow in the get_data function in zipimport.c in CPython (aka Python) before 2.7.12, 3.x before 3.4.5, and 3.5.x before 3.5.2 allows remote attackers to have unspecified impact via a negative data size value, which triggers a heap-based buffer overflow.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-5636"
}, {
  "versionRange" : "[2.7.6,2.7.6]",
  "severity" : 7.5,
  "cveName" : "CVE-2014-1912",
  "description" : "Buffer overflow in the socket.recvfrom_into function in Modules/socketmodule.c in Python 2.5 before 2.7.7, 3.x before 3.3.4, and 3.4.x before 3.4rc1 allows remote attackers to execute arbitrary code via a crafted string.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-1912"
}, {
  "versionRange" : "[2.3.7,2.3.7]",
  "severity" : 5.8,
  "cveName" : "CVE-2014-9365",
  "description" : "The HTTP clients in the (1) httplib, (2) urllib, (3) urllib2, and (4) xmlrpclib libraries in CPython (aka Python) 2.x before 2.7.9 and 3.x before 3.4.3, when accessing an HTTPS URL, do not (a) check the certificate against a trust store or verify that the server hostname matches a domain name in the subject's (b) Common Name or (c) subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-9365"
}, {
  "versionRange" : "[3.3.0,3.3.0]",
  "severity" : 9.8,
  "cveName" : "CVE-2016-5636",
  "description" : "Integer overflow in the get_data function in zipimport.c in CPython (aka Python) before 2.7.12, 3.x before 3.4.5, and 3.5.x before 3.5.2 allows remote attackers to have unspecified impact via a negative data size value, which triggers a heap-based buffer overflow.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-5636"
}, {
  "versionRange" : "[2.6.6,2.6.6]",
  "severity" : 5.0,
  "cveName" : "CVE-2012-0845",
  "description" : "SimpleXMLRPCServer.py in SimpleXMLRPCServer in Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 allows remote attackers to cause a denial of service (infinite loop and CPU consumption) via an XML-RPC POST request that contains a smaller amount of data than specified by the Content-Length header.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-0845"
}, {
  "versionRange" : "[3.3.1,3.3.1]",
  "severity" : 4.3,
  "cveName" : "CVE-2013-2099",
  "description" : "Algorithmic complexity vulnerability in the ssl.match_hostname function in Python 3.2.x, 3.3.x, and earlier, and unspecified versions of python-backports-ssl_match_hostname as used for older Python versions, allows remote attackers to cause a denial of service (CPU consumption) via multiple wildcard characters in the common name in a certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-2099"
}, {
  "versionRange" : "[2.5.4,2.5.4]",
  "severity" : 5.8,
  "cveName" : "CVE-2014-9365",
  "description" : "The HTTP clients in the (1) httplib, (2) urllib, (3) urllib2, and (4) xmlrpclib libraries in CPython (aka Python) 2.x before 2.7.9 and 3.x before 3.4.3, when accessing an HTTPS URL, do not (a) check the certificate against a trust store or verify that the server hostname matches a domain name in the subject's (b) Common Name or (c) subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-9365"
}, {
  "versionRange" : "[3.6.0,3.6.12)",
  "severity" : 7.8,
  "cveName" : "CVE-2020-15523",
  "description" : "In Python 3.6 through 3.6.10, 3.7 through 3.7.8, 3.8 through 3.8.4rc1, and 3.9 through 3.9.0b4 on Windows, a Trojan horse python3.dll might be used in cases where CPython is embedded in a native application. This occurs because python3X.dll may use an invalid search path for python3.dll loading (after Py_SetPath has been used). NOTE: this issue CANNOT occur when using python.exe from a standard (non-embedded) Python installation on Windows.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2020-15523"
}, {
  "versionRange" : "[3.7.0,3.7.4)",
  "severity" : 6.1,
  "cveName" : "CVE-2019-9947",
  "description" : "An issue was discovered in urllib2 in Python 2.x through 2.7.16 and urllib in Python 3.x through 3.7.3. CRLF injection is possible if the attacker controls a url parameter, as demonstrated by the first argument to urllib.request.urlopen with \\r\\n (specifically in the path component of a URL that lacks a ? character) followed by an HTTP header or a Redis command. This is similar to the CVE-2019-9740 query string issue. This is fixed in: v2.7.17, v2.7.17rc1, v2.7.18, v2.7.18rc1; v3.5.10, v3.5.10rc1, v3.5.8, v3.5.8rc1, v3.5.8rc2, v3.5.9; v3.6.10, v3.6.10rc1, v3.6.11, v3.6.11rc1, v3.6.12, v3.6.9, v3.6.9rc1; v3.7.4, v3.7.4rc1, v3.7.4rc2, v3.7.5, v3.7.5rc1, v3.7.6, v3.7.6rc1, v3.7.7, v3.7.7rc1, v3.7.8, v3.7.8rc1, v3.7.9.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2019-9947"
}, {
  "versionRange" : "[2.5.3,2.5.3]",
  "severity" : 7.5,
  "cveName" : "CVE-2014-1912",
  "description" : "Buffer overflow in the socket.recvfrom_into function in Modules/socketmodule.c in Python 2.5 before 2.7.7, 3.x before 3.3.4, and 3.4.x before 3.4rc1 allows remote attackers to execute arbitrary code via a crafted string.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-1912"
}, {
  "versionRange" : "[2.1.3,2.1.3]",
  "severity" : 5.0,
  "cveName" : "CVE-2012-0845",
  "description" : "SimpleXMLRPCServer.py in SimpleXMLRPCServer in Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 allows remote attackers to cause a denial of service (infinite loop and CPU consumption) via an XML-RPC POST request that contains a smaller amount of data than specified by the Content-Length header.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-0845"
}, {
  "versionRange" : "[3.1.2,3.1.2]",
  "severity" : 6.1,
  "cveName" : "CVE-2016-5699",
  "description" : "CRLF injection vulnerability in the HTTPConnection.putheader function in urllib2 and urllib in CPython (aka Python) before 2.7.10 and 3.x before 3.4.4 allows remote attackers to inject arbitrary HTTP headers via CRLF sequences in a URL.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-5699"
}, {
  "versionRange" : "[2.5.2,2.5.2]",
  "severity" : 5.8,
  "cveName" : "CVE-2014-9365",
  "description" : "The HTTP clients in the (1) httplib, (2) urllib, (3) urllib2, and (4) xmlrpclib libraries in CPython (aka Python) 2.x before 2.7.9 and 3.x before 3.4.3, when accessing an HTTPS URL, do not (a) check the certificate against a trust store or verify that the server hostname matches a domain name in the subject's (b) Common Name or (c) subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-9365"
}, {
  "versionRange" : "[2.7.4,2.7.4]",
  "severity" : 7.5,
  "cveName" : "CVE-2014-1912",
  "description" : "Buffer overflow in the socket.recvfrom_into function in Modules/socketmodule.c in Python 2.5 before 2.7.7, 3.x before 3.3.4, and 3.4.x before 3.4rc1 allows remote attackers to execute arbitrary code via a crafted string.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-1912"
}, {
  "versionRange" : "[2.4.1,2.4.1]",
  "severity" : 6.4,
  "cveName" : "CVE-2011-1521",
  "description" : "The urllib and urllib2 modules in Python 2.x before 2.7.2 and 3.x before 3.2.1 process Location headers that specify redirection to file: URLs, which makes it easier for remote attackers to obtain sensitive information or cause a denial of service (resource consumption) via a crafted URL, as demonstrated by the file:///etc/passwd and file:///dev/zero URLs.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-1521"
}, {
  "versionRange" : "[3.4.2,3.4.2]",
  "severity" : 6.1,
  "cveName" : "CVE-2016-5699",
  "description" : "CRLF injection vulnerability in the HTTPConnection.putheader function in urllib2 and urllib in CPython (aka Python) before 2.7.10 and 3.x before 3.4.4 allows remote attackers to inject arbitrary HTTP headers via CRLF sequences in a URL.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-5699"
}, {
  "versionRange" : "[3.7.0,3.7.9)",
  "severity" : 7.5,
  "cveName" : "CVE-2019-20907",
  "description" : "In Lib/tarfile.py in Python through 3.8.3, an attacker is able to craft a TAR archive leading to an infinite loop when opened by tarfile.open, because _proc_pax lacks header validation.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2019-20907"
}, {
  "versionRange" : "[2.3.5,2.3.5]",
  "severity" : 5.8,
  "cveName" : "CVE-2014-9365",
  "description" : "The HTTP clients in the (1) httplib, (2) urllib, (3) urllib2, and (4) xmlrpclib libraries in CPython (aka Python) 2.x before 2.7.9 and 3.x before 3.4.3, when accessing an HTTPS URL, do not (a) check the certificate against a trust store or verify that the server hostname matches a domain name in the subject's (b) Common Name or (c) subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-9365"
}, {
  "versionRange" : "[2.4.3,2.4.3]",
  "severity" : 5.8,
  "cveName" : "CVE-2014-9365",
  "description" : "The HTTP clients in the (1) httplib, (2) urllib, (3) urllib2, and (4) xmlrpclib libraries in CPython (aka Python) 2.x before 2.7.9 and 3.x before 3.4.3, when accessing an HTTPS URL, do not (a) check the certificate against a trust store or verify that the server hostname matches a domain name in the subject's (b) Common Name or (c) subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-9365"
}, {
  "versionRange" : "[3.7.0,3.7.0]",
  "severity" : 7.5,
  "cveName" : "CVE-2019-17514",
  "description" : "library/glob.html in the Python 2 and 3 documentation before 2016 has potentially misleading information about whether sorting occurs, as demonstrated by irreproducible cancer-research results. NOTE: the effects of this documentation cross application domains, and thus it is likely that security-relevant code elsewhere is affected. This issue is not a Python implementation bug, and there are no reports that NMR researchers were specifically relying on library/glob.html. In other words, because the older documentation stated \"finds all the pathnames matching a specified pattern according to the rules used by the Unix shell,\" one might have incorrectly inferred that the sorting that occurs in a Unix shell also occurred for glob.glob. There is a workaround in newer versions of Willoughby nmr-data_compilation-p2.py and nmr-data_compilation-p3.py, which call sort() directly.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2019-17514"
}, {
  "versionRange" : "[2.7.0,2.7.15)",
  "severity" : 9.8,
  "cveName" : "CVE-2016-9063",
  "description" : "An integer overflow during the parsing of XML using the Expat library. This vulnerability affects Firefox < 50.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-9063"
}, {
  "versionRange" : "[3.6.0,3.6.9)",
  "severity" : 6.1,
  "cveName" : "CVE-2019-9947",
  "description" : "An issue was discovered in urllib2 in Python 2.x through 2.7.16 and urllib in Python 3.x through 3.7.3. CRLF injection is possible if the attacker controls a url parameter, as demonstrated by the first argument to urllib.request.urlopen with \\r\\n (specifically in the path component of a URL that lacks a ? character) followed by an HTTP header or a Redis command. This is similar to the CVE-2019-9740 query string issue. This is fixed in: v2.7.17, v2.7.17rc1, v2.7.18, v2.7.18rc1; v3.5.10, v3.5.10rc1, v3.5.8, v3.5.8rc1, v3.5.8rc2, v3.5.9; v3.6.10, v3.6.10rc1, v3.6.11, v3.6.11rc1, v3.6.12, v3.6.9, v3.6.9rc1; v3.7.4, v3.7.4rc1, v3.7.4rc2, v3.7.5, v3.7.5rc1, v3.7.6, v3.7.6rc1, v3.7.7, v3.7.7rc1, v3.7.8, v3.7.8rc1, v3.7.9.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2019-9947"
}, {
  "versionRange" : "(,2.5.2]",
  "severity" : 9.3,
  "cveName" : "CVE-2008-1887",
  "description" : "Python 2.5.2 and earlier allows context-dependent attackers to execute arbitrary code via multiple vectors that cause a negative size value to be provided to the PyString_FromStringAndSize function, which allocates less memory than expected when assert() is disabled and triggers a buffer overflow.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2008-1887"
}, {
  "versionRange" : "[2.6.4,2.6.4]",
  "severity" : 5.8,
  "cveName" : "CVE-2014-9365",
  "description" : "The HTTP clients in the (1) httplib, (2) urllib, (3) urllib2, and (4) xmlrpclib libraries in CPython (aka Python) 2.x before 2.7.9 and 3.x before 3.4.3, when accessing an HTTPS URL, do not (a) check the certificate against a trust store or verify that the server hostname matches a domain name in the subject's (b) Common Name or (c) subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-9365"
}, {
  "versionRange" : "[3.1.3,3.1.3]",
  "severity" : 5.0,
  "cveName" : "CVE-2012-0845",
  "description" : "SimpleXMLRPCServer.py in SimpleXMLRPCServer in Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 allows remote attackers to cause a denial of service (infinite loop and CPU consumption) via an XML-RPC POST request that contains a smaller amount of data than specified by the Content-Length header.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-0845"
}, {
  "versionRange" : "[3.4.2,3.4.2]",
  "severity" : 5.8,
  "cveName" : "CVE-2014-9365",
  "description" : "The HTTP clients in the (1) httplib, (2) urllib, (3) urllib2, and (4) xmlrpclib libraries in CPython (aka Python) 2.x before 2.7.9 and 3.x before 3.4.3, when accessing an HTTPS URL, do not (a) check the certificate against a trust store or verify that the server hostname matches a domain name in the subject's (b) Common Name or (c) subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-9365"
}, {
  "versionRange" : "[3.3.4,3.3.4]",
  "severity" : 5.8,
  "cveName" : "CVE-2014-9365",
  "description" : "The HTTP clients in the (1) httplib, (2) urllib, (3) urllib2, and (4) xmlrpclib libraries in CPython (aka Python) 2.x before 2.7.9 and 3.x before 3.4.3, when accessing an HTTPS URL, do not (a) check the certificate against a trust store or verify that the server hostname matches a domain name in the subject's (b) Common Name or (c) subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-9365"
}, {
  "versionRange" : "[2.5.6,2.5.6]",
  "severity" : 5.8,
  "cveName" : "CVE-2014-9365",
  "description" : "The HTTP clients in the (1) httplib, (2) urllib, (3) urllib2, and (4) xmlrpclib libraries in CPython (aka Python) 2.x before 2.7.9 and 3.x before 3.4.3, when accessing an HTTPS URL, do not (a) check the certificate against a trust store or verify that the server hostname matches a domain name in the subject's (b) Common Name or (c) subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-9365"
}, {
  "versionRange" : "[3.1.0,3.1.5]",
  "severity" : 7.5,
  "cveName" : "CVE-2019-16056",
  "description" : "An issue was discovered in Python through 2.7.16, 3.x through 3.5.7, 3.6.x through 3.6.9, and 3.7.x through 3.7.4. The email module wrongly parses email addresses that contain multiple @ characters. An application that uses the email module and implements some kind of checks on the From/To headers of a message could be tricked into accepting an email address that should be denied. An attack may be the same as in CVE-2019-11340; however, this CVE applies to Python more generally.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2019-16056"
}, {
  "versionRange" : "[2.7.2,2.7.2]",
  "severity" : 7.5,
  "cveName" : "CVE-2014-1912",
  "description" : "Buffer overflow in the socket.recvfrom_into function in Modules/socketmodule.c in Python 2.5 before 2.7.7, 3.x before 3.3.4, and 3.4.x before 3.4rc1 allows remote attackers to execute arbitrary code via a crafted string.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-1912"
}, {
  "versionRange" : "[2.7.3,2.7.3]",
  "severity" : 5.8,
  "cveName" : "CVE-2014-9365",
  "description" : "The HTTP clients in the (1) httplib, (2) urllib, (3) urllib2, and (4) xmlrpclib libraries in CPython (aka Python) 2.x before 2.7.9 and 3.x before 3.4.3, when accessing an HTTPS URL, do not (a) check the certificate against a trust store or verify that the server hostname matches a domain name in the subject's (b) Common Name or (c) subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-9365"
}, {
  "versionRange" : "[2.4.1,2.4.1]",
  "severity" : 5.8,
  "cveName" : "CVE-2014-9365",
  "description" : "The HTTP clients in the (1) httplib, (2) urllib, (3) urllib2, and (4) xmlrpclib libraries in CPython (aka Python) 2.x before 2.7.9 and 3.x before 3.4.3, when accessing an HTTPS URL, do not (a) check the certificate against a trust store or verify that the server hostname matches a domain name in the subject's (b) Common Name or (c) subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-9365"
}, {
  "versionRange" : "[2.3.3,2.3.3]",
  "severity" : 5.8,
  "cveName" : "CVE-2014-9365",
  "description" : "The HTTP clients in the (1) httplib, (2) urllib, (3) urllib2, and (4) xmlrpclib libraries in CPython (aka Python) 2.x before 2.7.9 and 3.x before 3.4.3, when accessing an HTTPS URL, do not (a) check the certificate against a trust store or verify that the server hostname matches a domain name in the subject's (b) Common Name or (c) subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-9365"
}, {
  "versionRange" : "[3.2.5,3.2.5]",
  "severity" : 5.8,
  "cveName" : "CVE-2014-9365",
  "description" : "The HTTP clients in the (1) httplib, (2) urllib, (3) urllib2, and (4) xmlrpclib libraries in CPython (aka Python) 2.x before 2.7.9 and 3.x before 3.4.3, when accessing an HTTPS URL, do not (a) check the certificate against a trust store or verify that the server hostname matches a domain name in the subject's (b) Common Name or (c) subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-9365"
}, {
  "versionRange" : "[3.1.4,3.1.4]",
  "severity" : 4.3,
  "cveName" : "CVE-2013-4238",
  "description" : "The ssl.match_hostname function in the SSL module in Python 2.6 through 3.4 does not properly handle a '\\0' character in a domain name in the Subject Alternative Name field of an X.509 certificate, which allows man-in-the-middle attackers to spoof arbitrary SSL servers via a crafted certificate issued by a legitimate Certification Authority, a related issue to CVE-2009-2408.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-4238"
}, {
  "versionRange" : "[2.4.1,2.4.1]",
  "severity" : 5.0,
  "cveName" : "CVE-2012-1150",
  "description" : "Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 computes hash values without restricting the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-1150"
}, {
  "versionRange" : "[2.6.1,2.6.1]",
  "severity" : 2.6,
  "cveName" : "CVE-2011-4940",
  "description" : "The list_directory function in Lib/SimpleHTTPServer.py in SimpleHTTPServer in Python before 2.5.6c1, 2.6.x before 2.6.7 rc2, and 2.7.x before 2.7.2 does not place a charset parameter in the Content-Type HTTP header, which makes it easier for remote attackers to conduct cross-site scripting (XSS) attacks against Internet Explorer 7 via UTF-7 encoding.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-4940"
}, {
  "versionRange" : "[2.6.6,2.6.6]",
  "severity" : 5.8,
  "cveName" : "CVE-2014-9365",
  "description" : "The HTTP clients in the (1) httplib, (2) urllib, (3) urllib2, and (4) xmlrpclib libraries in CPython (aka Python) 2.x before 2.7.9 and 3.x before 3.4.3, when accessing an HTTPS URL, do not (a) check the certificate against a trust store or verify that the server hostname matches a domain name in the subject's (b) Common Name or (c) subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-9365"
}, {
  "versionRange" : "[3.5.0,3.5.4)",
  "severity" : 9.8,
  "cveName" : "CVE-2016-9063",
  "description" : "An integer overflow during the parsing of XML using the Expat library. This vulnerability affects Firefox < 50.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-9063"
}, {
  "versionRange" : "(,2.6.7]",
  "severity" : 5.0,
  "cveName" : "CVE-2012-0845",
  "description" : "SimpleXMLRPCServer.py in SimpleXMLRPCServer in Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 allows remote attackers to cause a denial of service (infinite loop and CPU consumption) via an XML-RPC POST request that contains a smaller amount of data than specified by the Content-Length header.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-0845"
}, {
  "versionRange" : "[2.3.1,2.3.1]",
  "severity" : 5.0,
  "cveName" : "CVE-2012-0845",
  "description" : "SimpleXMLRPCServer.py in SimpleXMLRPCServer in Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 allows remote attackers to cause a denial of service (infinite loop and CPU consumption) via an XML-RPC POST request that contains a smaller amount of data than specified by the Content-Length header.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-0845"
}, {
  "versionRange" : "[3.2.0,3.4.9)",
  "severity" : 6.7,
  "cveName" : "CVE-2018-1000117",
  "description" : "Python Software Foundation CPython version From 3.2 until 3.6.4 on Windows contains a Buffer Overflow vulnerability in os.symlink() function on Windows that can result in Arbitrary code execution, likely escalation of privilege. This attack appears to be exploitable via a python script that creates a symlink with an attacker controlled name or location. This vulnerability appears to have been fixed in 3.7.0 and 3.6.5.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2018-1000117"
}, {
  "versionRange" : "[2.7.5,2.7.5]",
  "severity" : 5.8,
  "cveName" : "CVE-2014-9365",
  "description" : "The HTTP clients in the (1) httplib, (2) urllib, (3) urllib2, and (4) xmlrpclib libraries in CPython (aka Python) 2.x before 2.7.9 and 3.x before 3.4.3, when accessing an HTTPS URL, do not (a) check the certificate against a trust store or verify that the server hostname matches a domain name in the subject's (b) Common Name or (c) subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-9365"
}, {
  "versionRange" : "[2.4.2,2.4.2]",
  "severity" : 2.6,
  "cveName" : "CVE-2011-4940",
  "description" : "The list_directory function in Lib/SimpleHTTPServer.py in SimpleHTTPServer in Python before 2.5.6c1, 2.6.x before 2.6.7 rc2, and 2.7.x before 2.7.2 does not place a charset parameter in the Content-Type HTTP header, which makes it easier for remote attackers to conduct cross-site scripting (XSS) attacks against Internet Explorer 7 via UTF-7 encoding.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-4940"
}, {
  "versionRange" : "[2.5.3,2.5.3]",
  "severity" : 6.4,
  "cveName" : "CVE-2011-1521",
  "description" : "The urllib and urllib2 modules in Python 2.x before 2.7.2 and 3.x before 3.2.1 process Location headers that specify redirection to file: URLs, which makes it easier for remote attackers to obtain sensitive information or cause a denial of service (resource consumption) via a crafted URL, as demonstrated by the file:///etc/passwd and file:///dev/zero URLs.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-1521"
}, {
  "versionRange" : "[3.3.2,3.3.2]",
  "severity" : 5.8,
  "cveName" : "CVE-2014-9365",
  "description" : "The HTTP clients in the (1) httplib, (2) urllib, (3) urllib2, and (4) xmlrpclib libraries in CPython (aka Python) 2.x before 2.7.9 and 3.x before 3.4.3, when accessing an HTTPS URL, do not (a) check the certificate against a trust store or verify that the server hostname matches a domain name in the subject's (b) Common Name or (c) subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-9365"
}, {
  "versionRange" : "[3.10.0,3.10.0]",
  "severity" : 5.7,
  "cveName" : "CVE-2021-3426",
  "description" : "There's a flaw in Python 3's pydoc. A local or adjacent attacker who discovers or is able to convince another local or adjacent user to start a pydoc server could access the server and use it to disclose sensitive information belonging to the other user that they would not normally be able to access. The highest risk of this flaw is to data confidentiality. This flaw affects Python versions before 3.8.9, Python versions before 3.9.3 and Python versions before 3.10.0a7.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2021-3426"
}, {
  "versionRange" : "[2.6.1,2.6.1]",
  "severity" : 4.3,
  "cveName" : "CVE-2013-4238",
  "description" : "The ssl.match_hostname function in the SSL module in Python 2.6 through 3.4 does not properly handle a '\\0' character in a domain name in the Subject Alternative Name field of an X.509 certificate, which allows man-in-the-middle attackers to spoof arbitrary SSL servers via a crafted certificate issued by a legitimate Certification Authority, a related issue to CVE-2009-2408.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-4238"
}, {
  "versionRange" : "[3.6.0,3.6.12)",
  "severity" : 5.9,
  "cveName" : "CVE-2020-14422",
  "description" : "Lib/ipaddress.py in Python through 3.8.3 improperly computes hash values in the IPv4Interface and IPv6Interface classes, which might allow a remote attacker to cause a denial of service if an application is affected by the performance of a dictionary containing IPv4Interface or IPv6Interface objects, and this attacker can cause many dictionary entries to be created. This is fixed in: v3.5.10, v3.5.10rc1; v3.6.12; v3.7.9; v3.8.4, v3.8.4rc1, v3.8.5, v3.8.6, v3.8.6rc1; v3.9.0, v3.9.0b4, v3.9.0b5, v3.9.0rc1, v3.9.0rc2.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2020-14422"
}, {
  "versionRange" : "[3.9.0,3.9.1)",
  "severity" : 6.5,
  "cveName" : "CVE-2022-48564",
  "description" : "read_ints in plistlib.py in Python through 3.9.1 is vulnerable to a potential DoS attack via CPU and RAM exhaustion when processing malformed Apple Property List files in binary format.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2022-48564"
}, {
  "versionRange" : "[3.5.0,3.5.6)",
  "severity" : 6.7,
  "cveName" : "CVE-2018-1000117",
  "description" : "Python Software Foundation CPython version From 3.2 until 3.6.4 on Windows contains a Buffer Overflow vulnerability in os.symlink() function on Windows that can result in Arbitrary code execution, likely escalation of privilege. This attack appears to be exploitable via a python script that creates a symlink with an attacker controlled name or location. This vulnerability appears to have been fixed in 3.7.0 and 3.6.5.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2018-1000117"
}, {
  "versionRange" : "[2.7.2,2.7.2]",
  "severity" : 1.9,
  "cveName" : "CVE-2011-4944",
  "description" : "Python 2.6 through 3.2 creates ~/.pypirc with world-readable permissions before changing them after data has been written, which introduces a race condition that allows local users to obtain a username and password by reading this file.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-4944"
}, {
  "versionRange" : "[3.5.0,3.5.9]",
  "severity" : 6.5,
  "cveName" : "CVE-2020-8492",
  "description" : "Python 2.7 through 2.7.17, 3.5 through 3.5.9, 3.6 through 3.6.10, 3.7 through 3.7.6, and 3.8 through 3.8.1 allows an HTTP server to conduct Regular Expression Denial of Service (ReDoS) attacks against a client because of urllib.request.AbstractBasicAuthHandler catastrophic backtracking.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2020-8492"
}, {
  "versionRange" : "[3.3.2,3.3.2]",
  "severity" : 7.1,
  "cveName" : "CVE-2013-7338",
  "description" : "Python before 3.3.4 RC1 allows remote attackers to cause a denial of service (infinite loop and CPU consumption) via a file size value larger than the size of the zip file to the (1) ZipExtFile.read, (2) ZipExtFile.read(n), (3) ZipExtFile.readlines, (4) ZipFile.extract, or (5) ZipFile.extractall function.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-7338"
}, {
  "versionRange" : "[3.3.3,3.3.3]",
  "severity" : 7.1,
  "cveName" : "CVE-2013-7338",
  "description" : "Python before 3.3.4 RC1 allows remote attackers to cause a denial of service (infinite loop and CPU consumption) via a file size value larger than the size of the zip file to the (1) ZipExtFile.read, (2) ZipExtFile.read(n), (3) ZipExtFile.readlines, (4) ZipFile.extract, or (5) ZipFile.extractall function.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-7338"
}, {
  "versionRange" : "[3.1.5,3.1.5]",
  "severity" : 7.5,
  "cveName" : "CVE-2014-1912",
  "description" : "Buffer overflow in the socket.recvfrom_into function in Modules/socketmodule.c in Python 2.5 before 2.7.7, 3.x before 3.3.4, and 3.4.x before 3.4rc1 allows remote attackers to execute arbitrary code via a crafted string.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-1912"
}, {
  "versionRange" : "[3.2.1,3.2.1]",
  "severity" : 3.3,
  "cveName" : "CVE-2014-2667",
  "description" : "Race condition in the _get_masked_mode function in Lib/os.py in Python 3.2 through 3.5, when exist_ok is set to true and multiple threads are used, might allow local users to bypass intended file permissions by leveraging a separate application vulnerability before the umask has been set to the expected value.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-2667"
}, {
  "versionRange" : "[3.4.0,3.4.7)",
  "severity" : 9.8,
  "cveName" : "CVE-2016-0718",
  "description" : "Expat allows context-dependent attackers to cause a denial of service (crash) or possibly execute arbitrary code via a malformed input document, which triggers a buffer overflow.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-0718"
}, {
  "versionRange" : "[3.4.0,3.4.7)",
  "severity" : 9.8,
  "cveName" : "CVE-2016-9063",
  "description" : "An integer overflow during the parsing of XML using the Expat library. This vulnerability affects Firefox < 50.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-9063"
}, {
  "versionRange" : "[3.6.0,3.6.9)",
  "severity" : 6.1,
  "cveName" : "CVE-2019-9740",
  "description" : "An issue was discovered in urllib2 in Python 2.x through 2.7.16 and urllib in Python 3.x through 3.7.3. CRLF injection is possible if the attacker controls a url parameter, as demonstrated by the first argument to urllib.request.urlopen with \\r\\n (specifically in the query string after a ? character) followed by an HTTP header or a Redis command. This is fixed in: v2.7.17, v2.7.17rc1, v2.7.18, v2.7.18rc1; v3.5.10, v3.5.10rc1, v3.5.8, v3.5.8rc1, v3.5.8rc2, v3.5.9; v3.6.10, v3.6.10rc1, v3.6.11, v3.6.11rc1, v3.6.12, v3.6.9, v3.6.9rc1; v3.7.4, v3.7.4rc1, v3.7.4rc2, v3.7.5, v3.7.5rc1, v3.7.6, v3.7.6rc1, v3.7.7, v3.7.7rc1, v3.7.8, v3.7.8rc1, v3.7.9.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2019-9740"
}, {
  "versionRange" : "[3.1.3,3.1.3]",
  "severity" : 7.5,
  "cveName" : "CVE-2014-1912",
  "description" : "Buffer overflow in the socket.recvfrom_into function in Modules/socketmodule.c in Python 2.5 before 2.7.7, 3.x before 3.3.4, and 3.4.x before 3.4rc1 allows remote attackers to execute arbitrary code via a crafted string.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-1912"
}, {
  "versionRange" : "[2.7.0,2.7.16)",
  "severity" : 7.5,
  "cveName" : "CVE-2019-5010",
  "description" : "An exploitable denial-of-service vulnerability exists in the X509 certificate parser of Python.org Python 2.7.11 / 3.6.6. A specially crafted X509 certificate can cause a NULL pointer dereference, resulting in a denial of service. An attacker can initiate or accept TLS connections using crafted certificates to trigger this vulnerability.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2019-5010"
}, {
  "versionRange" : "[3.8.4,3.8.4]",
  "severity" : 7.8,
  "cveName" : "CVE-2020-15523",
  "description" : "In Python 3.6 through 3.6.10, 3.7 through 3.7.8, 3.8 through 3.8.4rc1, and 3.9 through 3.9.0b4 on Windows, a Trojan horse python3.dll might be used in cases where CPython is embedded in a native application. This occurs because python3X.dll may use an invalid search path for python3.dll loading (after Py_SetPath has been used). NOTE: this issue CANNOT occur when using python.exe from a standard (non-embedded) Python installation on Windows.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2020-15523"
}, {
  "versionRange" : "[3.7.0,3.7.3)",
  "severity" : 7.5,
  "cveName" : "CVE-2019-5010",
  "description" : "An exploitable denial-of-service vulnerability exists in the X509 certificate parser of Python.org Python 2.7.11 / 3.6.6. A specially crafted X509 certificate can cause a NULL pointer dereference, resulting in a denial of service. An attacker can initiate or accept TLS connections using crafted certificates to trigger this vulnerability.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2019-5010"
}, {
  "versionRange" : "[3.3.1,3.3.1]",
  "severity" : 7.1,
  "cveName" : "CVE-2013-7338",
  "description" : "Python before 3.3.4 RC1 allows remote attackers to cause a denial of service (infinite loop and CPU consumption) via a file size value larger than the size of the zip file to the (1) ZipExtFile.read, (2) ZipExtFile.read(n), (3) ZipExtFile.readlines, (4) ZipFile.extract, or (5) ZipFile.extractall function.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-7338"
}, {
  "versionRange" : "[3.8.0,3.8.8)",
  "severity" : 5.9,
  "cveName" : "CVE-2021-23336",
  "description" : "The package python/cpython from 0 and before 3.6.13, from 3.7.0 and before 3.7.10, from 3.8.0 and before 3.8.8, from 3.9.0 and before 3.9.2 are vulnerable to Web Cache Poisoning via urllib.parse.parse_qsl and urllib.parse.parse_qs by using a vector called parameter cloaking. When the attacker can separate query parameters using a semicolon (;), they can cause a difference in the interpretation of the request between the proxy (running with default configuration) and the server. This can result in malicious requests being cached as completely safe ones, as the proxy would usually not see the semicolon as a separator, and therefore would not include it in a cache key of an unkeyed parameter.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2021-23336"
}, {
  "versionRange" : "(,2.5.2]",
  "severity" : 5.0,
  "cveName" : "CVE-2008-3144",
  "description" : "Multiple integer overflows in the PyOS_vsnprintf function in Python/mysnprintf.c in Python 2.5.2 and earlier allow context-dependent attackers to cause a denial of service (memory corruption) or have unspecified other impact via crafted input to string formatting operations.  NOTE: the handling of certain integer values is also affected by related integer underflows and an off-by-one error.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2008-3144"
}, {
  "versionRange" : "[3.4.0,3.4.9]",
  "severity" : 7.5,
  "cveName" : "CVE-2018-14647",
  "description" : "Python's elementtree C accelerator failed to initialise Expat's hash salt during initialization. This could make it easy to conduct denial of service attacks against Expat by constructing an XML document that would cause pathological hash collisions in Expat's internal data structures, consuming large amounts CPU and RAM. The vulnerability exists in Python versions 3.7.0, 3.6.0 through 3.6.6, 3.5.0 through 3.5.6, 3.4.0 through 3.4.9, 2.7.0 through 2.7.15.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2018-14647"
}, {
  "versionRange" : "[2.5.6,2.5.6]",
  "severity" : 5.0,
  "cveName" : "CVE-2012-0845",
  "description" : "SimpleXMLRPCServer.py in SimpleXMLRPCServer in Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 allows remote attackers to cause a denial of service (infinite loop and CPU consumption) via an XML-RPC POST request that contains a smaller amount of data than specified by the Content-Length header.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-0845"
}, {
  "versionRange" : "[3.2.1,3.2.1]",
  "severity" : 6.1,
  "cveName" : "CVE-2016-5699",
  "description" : "CRLF injection vulnerability in the HTTPConnection.putheader function in urllib2 and urllib in CPython (aka Python) before 2.7.10 and 3.x before 3.4.4 allows remote attackers to inject arbitrary HTTP headers via CRLF sequences in a URL.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-5699"
}, {
  "versionRange" : "[3.3.0,3.3.0]",
  "severity" : 7.1,
  "cveName" : "CVE-2013-7338",
  "description" : "Python before 3.3.4 RC1 allows remote attackers to cause a denial of service (infinite loop and CPU consumption) via a file size value larger than the size of the zip file to the (1) ZipExtFile.read, (2) ZipExtFile.read(n), (3) ZipExtFile.readlines, (4) ZipFile.extract, or (5) ZipFile.extractall function.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-7338"
}, {
  "versionRange" : "[2.6.2,2.6.2]",
  "severity" : 2.6,
  "cveName" : "CVE-2011-4940",
  "description" : "The list_directory function in Lib/SimpleHTTPServer.py in SimpleHTTPServer in Python before 2.5.6c1, 2.6.x before 2.6.7 rc2, and 2.7.x before 2.7.2 does not place a charset parameter in the Content-Type HTTP header, which makes it easier for remote attackers to conduct cross-site scripting (XSS) attacks against Internet Explorer 7 via UTF-7 encoding.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-4940"
}, {
  "versionRange" : "[3.7.0,3.7.10)",
  "severity" : 5.7,
  "cveName" : "CVE-2021-3426",
  "description" : "There's a flaw in Python 3's pydoc. A local or adjacent attacker who discovers or is able to convince another local or adjacent user to start a pydoc server could access the server and use it to disclose sensitive information belonging to the other user that they would not normally be able to access. The highest risk of this flaw is to data confidentiality. This flaw affects Python versions before 3.8.9, Python versions before 3.9.3 and Python versions before 3.10.0a7.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2021-3426"
}, {
  "versionRange" : "[2.6.0,2.6.6)",
  "severity" : 5.0,
  "cveName" : "CVE-2010-1634",
  "description" : "Multiple integer overflows in audioop.c in the audioop module in Python 2.6, 2.7, 3.1, and 3.2 allow context-dependent attackers to cause a denial of service (application crash) via a large fragment, as demonstrated by a call to audioop.lin2lin with a long string in the first argument, leading to a buffer overflow.  NOTE: this vulnerability exists because of an incorrect fix for CVE-2008-3143.5.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2010-1634"
}, {
  "versionRange" : "[3.1.1,3.1.1]",
  "severity" : 1.9,
  "cveName" : "CVE-2011-4944",
  "description" : "Python 2.6 through 3.2 creates ~/.pypirc with world-readable permissions before changing them after data has been written, which introduces a race condition that allows local users to obtain a username and password by reading this file.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-4944"
}, {
  "versionRange" : "[3.5.0,3.5.10)",
  "severity" : 7.8,
  "cveName" : "CVE-2020-15523",
  "description" : "In Python 3.6 through 3.6.10, 3.7 through 3.7.8, 3.8 through 3.8.4rc1, and 3.9 through 3.9.0b4 on Windows, a Trojan horse python3.dll might be used in cases where CPython is embedded in a native application. This occurs because python3X.dll may use an invalid search path for python3.dll loading (after Py_SetPath has been used). NOTE: this issue CANNOT occur when using python.exe from a standard (non-embedded) Python installation on Windows.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2020-15523"
}, {
  "versionRange" : "[3.2.2,3.2.2]",
  "severity" : 5.9,
  "cveName" : "CVE-2013-7440",
  "description" : "The ssl.match_hostname function in CPython (aka Python) before 2.7.9 and 3.x before 3.3.3 does not properly handle wildcards in hostnames, which might allow man-in-the-middle attackers to spoof servers via a crafted certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-7440"
}, {
  "versionRange" : "(,2.6.6)",
  "severity" : 6.9,
  "cveName" : "CVE-2008-5983",
  "description" : "Untrusted search path vulnerability in the PySys_SetArgv API function in Python 2.6 and earlier, and possibly later versions, prepends an empty string to sys.path when the argv[0] argument does not contain a path separator, which might allow local users to execute arbitrary code via a Trojan horse Python file in the current working directory.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2008-5983"
}, {
  "versionRange" : "[3.3,3.3]",
  "severity" : 4.3,
  "cveName" : "CVE-2013-7040",
  "description" : "Python 2.7 before 3.4 only uses the last eight bits of the prefix to randomize hash values, which causes it to compute hash values without restricting the ability to trigger hash collisions predictably and makes it easier for context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2012-1150.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-7040"
}, {
  "versionRange" : "[2.3.7,2.3.7]",
  "severity" : 6.4,
  "cveName" : "CVE-2011-1521",
  "description" : "The urllib and urllib2 modules in Python 2.x before 2.7.2 and 3.x before 3.2.1 process Location headers that specify redirection to file: URLs, which makes it easier for remote attackers to obtain sensitive information or cause a denial of service (resource consumption) via a crafted URL, as demonstrated by the file:///etc/passwd and file:///dev/zero URLs.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-1521"
}, {
  "versionRange" : "[2.7.1,2.7.1]",
  "severity" : 5.8,
  "cveName" : "CVE-2014-9365",
  "description" : "The HTTP clients in the (1) httplib, (2) urllib, (3) urllib2, and (4) xmlrpclib libraries in CPython (aka Python) 2.x before 2.7.9 and 3.x before 3.4.3, when accessing an HTTPS URL, do not (a) check the certificate against a trust store or verify that the server hostname matches a domain name in the subject's (b) Common Name or (c) subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-9365"
}, {
  "versionRange" : "[3.3.6,3.3.6]",
  "severity" : 5.8,
  "cveName" : "CVE-2014-9365",
  "description" : "The HTTP clients in the (1) httplib, (2) urllib, (3) urllib2, and (4) xmlrpclib libraries in CPython (aka Python) 2.x before 2.7.9 and 3.x before 3.4.3, when accessing an HTTPS URL, do not (a) check the certificate against a trust store or verify that the server hostname matches a domain name in the subject's (b) Common Name or (c) subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-9365"
}, {
  "versionRange" : "(,2.7.14]",
  "severity" : 3.6,
  "cveName" : "CVE-2018-1000030",
  "description" : "Python 2.7.14 is vulnerable to a Heap-Buffer-Overflow as well as a Heap-Use-After-Free. Python versions prior to 2.7.14 may also be vulnerable and it appears that Python 2.7.17 and prior may also be vulnerable however this has not been confirmed. The vulnerability lies when multiply threads are handling large amounts of data. In both cases there is essentially a race condition that occurs. For the Heap-Buffer-Overflow, Thread 2 is creating the size for a buffer, but Thread1 is already writing to the buffer without knowing how much to write. So when a large amount of data is being processed, it is very easy to cause memory corruption using a Heap-Buffer-Overflow. As for the Use-After-Free, Thread3->Malloc->Thread1->Free's->Thread2-Re-uses-Free'd Memory. The PSRT has stated that this is not a security vulnerability due to the fact that the attacker must be able to run code, however in some situations, such as function as a service, this vulnerability can potentially be used by an attacker to violate a trust boundary, as such the DWF feels this issue deserves a CVE.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2018-1000030"
}, {
  "versionRange" : "[3.11.0,3.11.4]",
  "severity" : 7.5,
  "cveName" : "CVE-2023-41105",
  "description" : "An issue was discovered in Python 3.11 through 3.11.4. If a path containing '\\0' bytes is passed to os.path.normpath(), the path will be truncated unexpectedly at the first '\\0' byte. There are plausible cases in which an application would have rejected a filename for security reasons in Python 3.10.x or earlier, but that filename is no longer rejected in Python 3.11.x.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2023-41105"
}, {
  "versionRange" : "[2.0.1,2.0.1]",
  "severity" : 5.0,
  "cveName" : "CVE-2012-0845",
  "description" : "SimpleXMLRPCServer.py in SimpleXMLRPCServer in Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 allows remote attackers to cause a denial of service (infinite loop and CPU consumption) via an XML-RPC POST request that contains a smaller amount of data than specified by the Content-Length header.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-0845"
}, {
  "versionRange" : "[2.6.2,2.6.2]",
  "severity" : 5.8,
  "cveName" : "CVE-2014-9365",
  "description" : "The HTTP clients in the (1) httplib, (2) urllib, (3) urllib2, and (4) xmlrpclib libraries in CPython (aka Python) 2.x before 2.7.9 and 3.x before 3.4.3, when accessing an HTTPS URL, do not (a) check the certificate against a trust store or verify that the server hostname matches a domain name in the subject's (b) Common Name or (c) subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-9365"
}, {
  "versionRange" : "[3.1.1,3.1.1]",
  "severity" : 7.5,
  "cveName" : "CVE-2014-1912",
  "description" : "Buffer overflow in the socket.recvfrom_into function in Modules/socketmodule.c in Python 2.5 before 2.7.7, 3.x before 3.3.4, and 3.4.x before 3.4rc1 allows remote attackers to execute arbitrary code via a crafted string.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-1912"
}, {
  "versionRange" : "(,3.6.3]",
  "severity" : 8.8,
  "cveName" : "CVE-2017-17522",
  "description" : "Lib/webbrowser.py in Python through 3.6.3 does not validate strings before launching the program specified by the BROWSER environment variable, which might allow remote attackers to conduct argument-injection attacks via a crafted URL. NOTE: a software maintainer indicates that exploitation is impossible because the code relies on subprocess.Popen and the default shell=False setting",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2017-17522"
}, {
  "versionRange" : "[3.0.0,3.5.8)",
  "severity" : 6.1,
  "cveName" : "CVE-2019-16935",
  "description" : "The documentation XML-RPC server in Python through 2.7.16, 3.x through 3.6.9, and 3.7.x through 3.7.4 has XSS via the server_title field. This occurs in Lib/DocXMLRPCServer.py in Python 2.x, and in Lib/xmlrpc/server.py in Python 3.x. If set_server_title is called with untrusted input, arbitrary JavaScript can be delivered to clients that visit the http URL for this server.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2019-16935"
}, {
  "versionRange" : "[3.7.0,3.7.14)",
  "severity" : 7.5,
  "cveName" : "CVE-2018-25032",
  "description" : "zlib before 1.2.12 allows memory corruption when deflating (i.e., when compressing) if the input has many distant matches.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2018-25032"
}, {
  "versionRange" : "[2.7.1,2.7.1]",
  "severity" : 2.6,
  "cveName" : "CVE-2011-4940",
  "description" : "The list_directory function in Lib/SimpleHTTPServer.py in SimpleHTTPServer in Python before 2.5.6c1, 2.6.x before 2.6.7 rc2, and 2.7.x before 2.7.2 does not place a charset parameter in the Content-Type HTTP header, which makes it easier for remote attackers to conduct cross-site scripting (XSS) attacks against Internet Explorer 7 via UTF-7 encoding.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-4940"
}, {
  "versionRange" : "[3.3.0,3.3.7)",
  "severity" : 6.1,
  "cveName" : "CVE-2016-1000110",
  "description" : "The CGIHandler class in Python before 2.7.12 does not protect against the HTTP_PROXY variable name clash in a CGI script, which could allow a remote attacker to redirect HTTP requests.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-1000110"
}, {
  "versionRange" : "[3.7.0,3.7.12)",
  "severity" : 6.8,
  "cveName" : "CVE-2013-0340",
  "description" : "expat 2.1.0 and earlier does not properly handle entities expansion unless an application developer uses the XML_SetEntityDeclHandler function, which allows remote attackers to cause a denial of service (resource consumption), send HTTP requests to intranet servers, or read arbitrary files via a crafted XML document, aka an XML External Entity (XXE) issue.  NOTE: it could be argued that because expat already provides the ability to disable external entity expansion, the responsibility for resolving this issue lies with application developers; according to this argument, this entry should be REJECTed, and each affected application would need its own CVE.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-0340"
}, {
  "versionRange" : "[3.1.3,3.1.3]",
  "severity" : 5.9,
  "cveName" : "CVE-2013-7440",
  "description" : "The ssl.match_hostname function in CPython (aka Python) before 2.7.9 and 3.x before 3.3.3 does not properly handle wildcards in hostnames, which might allow man-in-the-middle attackers to spoof servers via a crafted certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-7440"
}, {
  "versionRange" : "[3.1.4,3.1.4]",
  "severity" : 6.1,
  "cveName" : "CVE-2016-5699",
  "description" : "CRLF injection vulnerability in the HTTPConnection.putheader function in urllib2 and urllib in CPython (aka Python) before 2.7.10 and 3.x before 3.4.4 allows remote attackers to inject arbitrary HTTP headers via CRLF sequences in a URL.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-5699"
}, {
  "versionRange" : "[3.10.0,3.10.0]",
  "severity" : 5.3,
  "cveName" : "CVE-2021-4189",
  "description" : "A flaw was found in Python, specifically in the FTP (File Transfer Protocol) client library in PASV (passive) mode. The issue is how the FTP client trusts the host from the PASV response by default. This flaw allows an attacker to set up a malicious FTP server that can trick FTP clients into connecting back to a given IP address and port. This vulnerability could lead to FTP client scanning ports, which otherwise would not have been possible.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2021-4189"
}, {
  "versionRange" : "[3.1.0,3.1.3)",
  "severity" : 6.9,
  "cveName" : "CVE-2008-5983",
  "description" : "Untrusted search path vulnerability in the PySys_SetArgv API function in Python 2.6 and earlier, and possibly later versions, prepends an empty string to sys.path when the argv[0] argument does not contain a path separator, which might allow local users to execute arbitrary code via a Trojan horse Python file in the current working directory.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2008-5983"
}, {
  "versionRange" : "[3.1.0,3.1.5)",
  "severity" : 4.3,
  "cveName" : "CVE-2012-0876",
  "description" : "The XML parser (xmlparse.c) in expat before 2.1.0 computes hash values without restricting the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via an XML file with many identifiers with the same value.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-0876"
}, {
  "versionRange" : "[3.7.0,3.7.11)",
  "severity" : 6.5,
  "cveName" : "CVE-2021-3733",
  "description" : "There's a flaw in urllib's AbstractBasicAuthHandler class. An attacker who controls a malicious HTTP server that an HTTP client (such as web browser) connects to, could trigger a Regular Expression Denial of Service (ReDOS) during an authentication request with a specially crafted payload that is sent by the server to the client. The greatest threat that this flaw poses is to application availability.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2021-3733"
}, {
  "versionRange" : "[3.7.0,3.7.4)",
  "severity" : 9.8,
  "cveName" : "CVE-2019-10160",
  "description" : "A security regression of CVE-2019-9636 was discovered in python since commit d537ab0ff9767ef024f26246899728f0116b1ec3 affecting versions 2.7, 3.5, 3.6, 3.7 and from v3.8.0a4 through v3.8.0b1, which still allows an attacker to exploit CVE-2019-9636 by abusing the user and password parts of a URL. When an application parses user-supplied URLs to store cookies, authentication credentials, or other kind of information, it is possible for an attacker to provide specially crafted URLs to make the application locate host-related information (e.g. cookies, authentication data) and send them to a different host than where it should, unlike if the URLs had been correctly parsed. The result of an attack may vary based on the application.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2019-10160"
}, {
  "versionRange" : "[3.4.0,3.4.10)",
  "severity" : 7.5,
  "cveName" : "CVE-2019-5010",
  "description" : "An exploitable denial-of-service vulnerability exists in the X509 certificate parser of Python.org Python 2.7.11 / 3.6.6. A specially crafted X509 certificate can cause a NULL pointer dereference, resulting in a denial of service. An attacker can initiate or accept TLS connections using crafted certificates to trigger this vulnerability.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2019-5010"
}, {
  "versionRange" : "[3.7.0,3.7.9]",
  "severity" : 9.8,
  "cveName" : "CVE-2021-3177",
  "description" : "Python 3.x through 3.9.1 has a buffer overflow in PyCArg_repr in _ctypes/callproc.c, which may lead to remote code execution in certain Python applications that accept floating-point numbers as untrusted input, as demonstrated by a 1e300 argument to c_double.from_param. This occurs because sprintf is used unsafely.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2021-3177"
}, {
  "versionRange" : "[2.6.0,2.6.6)",
  "severity" : 5.0,
  "cveName" : "CVE-2010-2089",
  "description" : "The audioop module in Python 2.7 and 3.2 does not verify the relationships between size arguments and byte string lengths, which allows context-dependent attackers to cause a denial of service (memory corruption and application crash) via crafted arguments, as demonstrated by a call to audioop.reverse with a one-byte string, a different vulnerability than CVE-2010-1634.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2010-2089"
}, {
  "versionRange" : "[3.6.0,3.6.9)",
  "severity" : 9.8,
  "cveName" : "CVE-2019-10160",
  "description" : "A security regression of CVE-2019-9636 was discovered in python since commit d537ab0ff9767ef024f26246899728f0116b1ec3 affecting versions 2.7, 3.5, 3.6, 3.7 and from v3.8.0a4 through v3.8.0b1, which still allows an attacker to exploit CVE-2019-9636 by abusing the user and password parts of a URL. When an application parses user-supplied URLs to store cookies, authentication credentials, or other kind of information, it is possible for an attacker to provide specially crafted URLs to make the application locate host-related information (e.g. cookies, authentication data) and send them to a different host than where it should, unlike if the URLs had been correctly parsed. The result of an attack may vary based on the application.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2019-10160"
}, {
  "versionRange" : "[2.1.2,2.1.2]",
  "severity" : 6.4,
  "cveName" : "CVE-2011-1521",
  "description" : "The urllib and urllib2 modules in Python 2.x before 2.7.2 and 3.x before 3.2.1 process Location headers that specify redirection to file: URLs, which makes it easier for remote attackers to obtain sensitive information or cause a denial of service (resource consumption) via a crafted URL, as demonstrated by the file:///etc/passwd and file:///dev/zero URLs.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-1521"
}, {
  "versionRange" : "[2.2.2,2.2.2]",
  "severity" : 2.6,
  "cveName" : "CVE-2011-4940",
  "description" : "The list_directory function in Lib/SimpleHTTPServer.py in SimpleHTTPServer in Python before 2.5.6c1, 2.6.x before 2.6.7 rc2, and 2.7.x before 2.7.2 does not place a charset parameter in the Content-Type HTTP header, which makes it easier for remote attackers to conduct cross-site scripting (XSS) attacks against Internet Explorer 7 via UTF-7 encoding.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-4940"
}, {
  "versionRange" : "[2.6.5,2.6.5]",
  "severity" : 6.4,
  "cveName" : "CVE-2011-1521",
  "description" : "The urllib and urllib2 modules in Python 2.x before 2.7.2 and 3.x before 3.2.1 process Location headers that specify redirection to file: URLs, which makes it easier for remote attackers to obtain sensitive information or cause a denial of service (resource consumption) via a crafted URL, as demonstrated by the file:///etc/passwd and file:///dev/zero URLs.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-1521"
}, {
  "versionRange" : "[3.7.0,3.7.11)",
  "severity" : 7.5,
  "cveName" : "CVE-2022-0391",
  "description" : "A flaw was found in Python, specifically within the urllib.parse module. This module helps break Uniform Resource Locator (URL) strings into components. The issue involves how the urlparse method does not sanitize input and allows characters like '\\r' and '\\n' in the URL path. This flaw allows an attacker to input a crafted URL, leading to injection attacks. This flaw affects Python versions prior to 3.10.0b1, 3.9.5, 3.8.11, 3.7.11 and 3.6.14.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2022-0391"
}, {
  "versionRange" : "[3.4.1,3.4.1]",
  "severity" : 9.8,
  "cveName" : "CVE-2016-5636",
  "description" : "Integer overflow in the get_data function in zipimport.c in CPython (aka Python) before 2.7.12, 3.x before 3.4.5, and 3.5.x before 3.5.2 allows remote attackers to have unspecified impact via a negative data size value, which triggers a heap-based buffer overflow.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-5636"
}, {
  "versionRange" : "[3.5.0,3.5.6)",
  "severity" : 7.5,
  "cveName" : "CVE-2018-1060",
  "description" : "python before versions 2.7.15, 3.4.9, 3.5.6rc1, 3.6.5rc1 and 3.7.0 is vulnerable to catastrophic backtracking in pop3lib's apop() method. An attacker could use this flaw to cause denial of service.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2018-1060"
}, {
  "versionRange" : "[2.3.5,2.3.5]",
  "severity" : 5.0,
  "cveName" : "CVE-2012-1150",
  "description" : "Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 computes hash values without restricting the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-1150"
}, {
  "versionRange" : "[3.2.3,3.2.3]",
  "severity" : 6.1,
  "cveName" : "CVE-2016-5699",
  "description" : "CRLF injection vulnerability in the HTTPConnection.putheader function in urllib2 and urllib in CPython (aka Python) before 2.7.10 and 3.x before 3.4.4 allows remote attackers to inject arbitrary HTTP headers via CRLF sequences in a URL.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-5699"
}, {
  "versionRange" : "[3.0.1,3.0.1]",
  "severity" : 5.0,
  "cveName" : "CVE-2012-0845",
  "description" : "SimpleXMLRPCServer.py in SimpleXMLRPCServer in Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 allows remote attackers to cause a denial of service (infinite loop and CPU consumption) via an XML-RPC POST request that contains a smaller amount of data than specified by the Content-Length header.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-0845"
}, {
  "versionRange" : "[3.9.0,3.9.5)",
  "severity" : 9.8,
  "cveName" : "CVE-2021-29921",
  "description" : "In Python before 3,9,5, the ipaddress library mishandles leading zero characters in the octets of an IP address string. This (in some situations) allows attackers to bypass access control that is based on IP addresses.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2021-29921"
}, {
  "versionRange" : "[3.3.0,3.3.0]",
  "severity" : 6.5,
  "cveName" : "CVE-2016-0772",
  "description" : "The smtplib library in CPython (aka Python) before 2.7.12, 3.x before 3.4.5, and 3.5.x before 3.5.2 does not return an error when StartTLS fails, which might allow man-in-the-middle attackers to bypass the TLS protections by leveraging a network position between the client and the registry to block the StartTLS command, aka a \"StartTLS stripping attack.\"",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-0772"
}, {
  "versionRange" : "[3.9.0,3.9.11)",
  "severity" : 9.8,
  "cveName" : "CVE-2019-12900",
  "description" : "BZ2_decompress in decompress.c in bzip2 through 1.0.6 has an out-of-bounds write when there are many selectors.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2019-12900"
}, {
  "versionRange" : "[3.0.0,3.5.10)",
  "severity" : 7.2,
  "cveName" : "CVE-2020-26116",
  "description" : "http.client in Python 3.x before 3.5.10, 3.6.x before 3.6.12, 3.7.x before 3.7.9, and 3.8.x before 3.8.5 allows CRLF injection if the attacker controls the HTTP request method, as demonstrated by inserting CR and LF control characters in the first argument of HTTPConnection.request.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2020-26116"
}, {
  "versionRange" : "[2.3.4,2.3.4]",
  "severity" : 6.4,
  "cveName" : "CVE-2011-1521",
  "description" : "The urllib and urllib2 modules in Python 2.x before 2.7.2 and 3.x before 3.2.1 process Location headers that specify redirection to file: URLs, which makes it easier for remote attackers to obtain sensitive information or cause a denial of service (resource consumption) via a crafted URL, as demonstrated by the file:///etc/passwd and file:///dev/zero URLs.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-1521"
}, {
  "versionRange" : "[2.6.8,2.6.8]",
  "severity" : 7.5,
  "cveName" : "CVE-2014-1912",
  "description" : "Buffer overflow in the socket.recvfrom_into function in Modules/socketmodule.c in Python 2.5 before 2.7.7, 3.x before 3.3.4, and 3.4.x before 3.4rc1 allows remote attackers to execute arbitrary code via a crafted string.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-1912"
}, {
  "versionRange" : "[3.9.0,3.9.13)",
  "severity" : 7.5,
  "cveName" : "CVE-2018-25032",
  "description" : "zlib before 1.2.12 allows memory corruption when deflating (i.e., when compressing) if the input has many distant matches.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2018-25032"
}, {
  "versionRange" : "[3.3,3.3]",
  "severity" : 7.5,
  "cveName" : "CVE-2014-1912",
  "description" : "Buffer overflow in the socket.recvfrom_into function in Modules/socketmodule.c in Python 2.5 before 2.7.7, 3.x before 3.3.4, and 3.4.x before 3.4rc1 allows remote attackers to execute arbitrary code via a crafted string.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-1912"
}, {
  "versionRange" : "[3.5.0,3.5.4)",
  "severity" : 8.1,
  "cveName" : "CVE-2016-4472",
  "description" : "The overflow protection in Expat is removed by compilers with certain optimization settings, which allows remote attackers to cause a denial of service (crash) or possibly execute arbitrary code via crafted XML data.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2015-1283 and CVE-2015-2716.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-4472"
}, {
  "versionRange" : "[3.5.0,3.5.3)",
  "severity" : 7.5,
  "cveName" : "CVE-2016-2183",
  "description" : "The DES and Triple DES ciphers, as used in the TLS, SSH, and IPSec protocols and other protocols and products, have a birthday bound of approximately four billion blocks, which makes it easier for remote attackers to obtain cleartext data via a birthday attack against a long-duration encrypted session, as demonstrated by an HTTPS session using Triple DES in CBC mode, aka a \"Sweet32\" attack.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-2183"
}, {
  "versionRange" : "(3.6.0,3.6.5)",
  "severity" : 7.5,
  "cveName" : "CVE-2018-1060",
  "description" : "python before versions 2.7.15, 3.4.9, 3.5.6rc1, 3.6.5rc1 and 3.7.0 is vulnerable to catastrophic backtracking in pop3lib's apop() method. An attacker could use this flaw to cause denial of service.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2018-1060"
}, {
  "versionRange" : "[2.6.7,2.6.7]",
  "severity" : 7.5,
  "cveName" : "CVE-2014-1912",
  "description" : "Buffer overflow in the socket.recvfrom_into function in Modules/socketmodule.c in Python 2.5 before 2.7.7, 3.x before 3.3.4, and 3.4.x before 3.4rc1 allows remote attackers to execute arbitrary code via a crafted string.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-1912"
}, {
  "versionRange" : "(,2.5.2]",
  "severity" : 7.5,
  "cveName" : "CVE-2008-2315",
  "description" : "Multiple integer overflows in Python 2.5.2 and earlier allow context-dependent attackers to have an unknown impact via vectors related to the (1) stringobject, (2) unicodeobject, (3) bufferobject, (4) longobject, (5) tupleobject, (6) stropmodule, (7) gcmodule, and (8) mmapmodule modules.  NOTE: The expandtabs integer overflows in stringobject and unicodeobject in 2.5.2 are covered by CVE-2008-5031.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2008-2315"
}, {
  "versionRange" : "[2.6.1,2.6.1]",
  "severity" : 7.5,
  "cveName" : "CVE-2014-1912",
  "description" : "Buffer overflow in the socket.recvfrom_into function in Modules/socketmodule.c in Python 2.5 before 2.7.7, 3.x before 3.3.4, and 3.4.x before 3.4rc1 allows remote attackers to execute arbitrary code via a crafted string.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-1912"
}, {
  "versionRange" : "[2.3.7,2.3.7]",
  "severity" : 5.0,
  "cveName" : "CVE-2012-1150",
  "description" : "Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 computes hash values without restricting the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-1150"
}, {
  "versionRange" : "[2.6.5,2.6.5]",
  "severity" : 7.5,
  "cveName" : "CVE-2014-1912",
  "description" : "Buffer overflow in the socket.recvfrom_into function in Modules/socketmodule.c in Python 2.5 before 2.7.7, 3.x before 3.3.4, and 3.4.x before 3.4rc1 allows remote attackers to execute arbitrary code via a crafted string.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-1912"
}, {
  "versionRange" : "[2.4.6,2.4.6]",
  "severity" : 6.4,
  "cveName" : "CVE-2011-1521",
  "description" : "The urllib and urllib2 modules in Python 2.x before 2.7.2 and 3.x before 3.2.1 process Location headers that specify redirection to file: URLs, which makes it easier for remote attackers to obtain sensitive information or cause a denial of service (resource consumption) via a crafted URL, as demonstrated by the file:///etc/passwd and file:///dev/zero URLs.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-1521"
}, {
  "versionRange" : "[3.7.0,3.7.3)",
  "severity" : 9.8,
  "cveName" : "CVE-2019-9636",
  "description" : "Python 2.7.x through 2.7.16 and 3.x through 3.7.2 is affected by: Improper Handling of Unicode Encoding (with an incorrect netloc) during NFKC normalization. The impact is: Information disclosure (credentials, cookies, etc. that are cached against a given hostname). The components are: urllib.parse.urlsplit, urllib.parse.urlparse. The attack vector is: A specially crafted URL could be incorrectly parsed to locate cookies or authentication data and send that information to a different host than when parsed correctly. This is fixed in: v2.7.17, v2.7.17rc1, v2.7.18, v2.7.18rc1; v3.5.10, v3.5.10rc1, v3.5.7, v3.5.8, v3.5.8rc1, v3.5.8rc2, v3.5.9; v3.6.10, v3.6.10rc1, v3.6.11, v3.6.11rc1, v3.6.12, v3.6.9, v3.6.9rc1; v3.7.3, v3.7.3rc1, v3.7.4, v3.7.4rc1, v3.7.4rc2, v3.7.5, v3.7.5rc1, v3.7.6, v3.7.6rc1, v3.7.7, v3.7.7rc1, v3.7.8, v3.7.8rc1, v3.7.9.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2019-9636"
}, {
  "versionRange" : "(,2.7.11]",
  "severity" : 6.5,
  "cveName" : "CVE-2016-0772",
  "description" : "The smtplib library in CPython (aka Python) before 2.7.12, 3.x before 3.4.5, and 3.5.x before 3.5.2 does not return an error when StartTLS fails, which might allow man-in-the-middle attackers to bypass the TLS protections by leveraging a network position between the client and the registry to block the StartTLS command, aka a \"StartTLS stripping attack.\"",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-0772"
}, {
  "versionRange" : "[2.3.1,2.3.1]",
  "severity" : 6.4,
  "cveName" : "CVE-2011-1521",
  "description" : "The urllib and urllib2 modules in Python 2.x before 2.7.2 and 3.x before 3.2.1 process Location headers that specify redirection to file: URLs, which makes it easier for remote attackers to obtain sensitive information or cause a denial of service (resource consumption) via a crafted URL, as demonstrated by the file:///etc/passwd and file:///dev/zero URLs.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-1521"
}, {
  "versionRange" : "[2.6.6,2.6.6]",
  "severity" : 7.5,
  "cveName" : "CVE-2014-1912",
  "description" : "Buffer overflow in the socket.recvfrom_into function in Modules/socketmodule.c in Python 2.5 before 2.7.7, 3.x before 3.3.4, and 3.4.x before 3.4rc1 allows remote attackers to execute arbitrary code via a crafted string.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-1912"
}, {
  "versionRange" : "[2.7.0,2.7.8)",
  "severity" : 9.8,
  "cveName" : "CVE-2014-4650",
  "description" : "The CGIHTTPServer module in Python 2.7.5 and 3.3.4 does not properly handle URLs in which URL encoding is used for path separators, which allows remote attackers to read script source code or conduct directory traversal attacks and execute unintended code via a crafted character sequence, as demonstrated by a %2f separator.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-4650"
}, {
  "versionRange" : "[3.0.0,3.0.1]",
  "severity" : 7.5,
  "cveName" : "CVE-2019-16056",
  "description" : "An issue was discovered in Python through 2.7.16, 3.x through 3.5.7, 3.6.x through 3.6.9, and 3.7.x through 3.7.4. The email module wrongly parses email addresses that contain multiple @ characters. An application that uses the email module and implements some kind of checks on the From/To headers of a message could be tricked into accepting an email address that should be denied. An attack may be the same as in CVE-2019-11340; however, this CVE applies to Python more generally.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2019-16056"
}, {
  "versionRange" : "[2.1.2,2.1.2]",
  "severity" : 2.6,
  "cveName" : "CVE-2011-4940",
  "description" : "The list_directory function in Lib/SimpleHTTPServer.py in SimpleHTTPServer in Python before 2.5.6c1, 2.6.x before 2.6.7 rc2, and 2.7.x before 2.7.2 does not place a charset parameter in the Content-Type HTTP header, which makes it easier for remote attackers to conduct cross-site scripting (XSS) attacks against Internet Explorer 7 via UTF-7 encoding.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-4940"
}, {
  "versionRange" : "[3.2.4,3.2.4]",
  "severity" : 6.5,
  "cveName" : "CVE-2016-0772",
  "description" : "The smtplib library in CPython (aka Python) before 2.7.12, 3.x before 3.4.5, and 3.5.x before 3.5.2 does not return an error when StartTLS fails, which might allow man-in-the-middle attackers to bypass the TLS protections by leveraging a network position between the client and the registry to block the StartTLS command, aka a \"StartTLS stripping attack.\"",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-0772"
}, {
  "versionRange" : "[2.6.2,2.6.2]",
  "severity" : 7.5,
  "cveName" : "CVE-2014-1912",
  "description" : "Buffer overflow in the socket.recvfrom_into function in Modules/socketmodule.c in Python 2.5 before 2.7.7, 3.x before 3.3.4, and 3.4.x before 3.4rc1 allows remote attackers to execute arbitrary code via a crafted string.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-1912"
}, {
  "versionRange" : "[3.2.0,3.2.4)",
  "severity" : 6.4,
  "cveName" : "CVE-2012-2135",
  "description" : "The utf-16 decoder in Python 3.1 through 3.3 does not update the aligned_end variable after calling the unicode_decode_call_errorhandler function, which allows remote attackers to obtain sensitive information (process memory) or cause a denial of service (memory corruption and crash) via unspecified vectors.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-2135"
}, {
  "versionRange" : "[2.6.4,2.6.4]",
  "severity" : 7.5,
  "cveName" : "CVE-2014-1912",
  "description" : "Buffer overflow in the socket.recvfrom_into function in Modules/socketmodule.c in Python 2.5 before 2.7.7, 3.x before 3.3.4, and 3.4.x before 3.4rc1 allows remote attackers to execute arbitrary code via a crafted string.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-1912"
}, {
  "versionRange" : "[2.6.3,2.6.3]",
  "severity" : 7.5,
  "cveName" : "CVE-2014-1912",
  "description" : "Buffer overflow in the socket.recvfrom_into function in Modules/socketmodule.c in Python 2.5 before 2.7.7, 3.x before 3.3.4, and 3.4.x before 3.4rc1 allows remote attackers to execute arbitrary code via a crafted string.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-1912"
}, {
  "versionRange" : "[3.8.0,3.8.4)",
  "severity" : 5.9,
  "cveName" : "CVE-2020-14422",
  "description" : "Lib/ipaddress.py in Python through 3.8.3 improperly computes hash values in the IPv4Interface and IPv6Interface classes, which might allow a remote attacker to cause a denial of service if an application is affected by the performance of a dictionary containing IPv4Interface or IPv6Interface objects, and this attacker can cause many dictionary entries to be created. This is fixed in: v3.5.10, v3.5.10rc1; v3.6.12; v3.7.9; v3.8.4, v3.8.4rc1, v3.8.5, v3.8.6, v3.8.6rc1; v3.9.0, v3.9.0b4, v3.9.0b5, v3.9.0rc1, v3.9.0rc2.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2020-14422"
}, {
  "versionRange" : "[3.2.3,3.2.3]",
  "severity" : 5.8,
  "cveName" : "CVE-2014-9365",
  "description" : "The HTTP clients in the (1) httplib, (2) urllib, (3) urllib2, and (4) xmlrpclib libraries in CPython (aka Python) 2.x before 2.7.9 and 3.x before 3.4.3, when accessing an HTTPS URL, do not (a) check the certificate against a trust store or verify that the server hostname matches a domain name in the subject's (b) Common Name or (c) subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-9365"
}, {
  "versionRange" : "[3.9.0,3.9.1)",
  "severity" : 9.8,
  "cveName" : "CVE-2020-27619",
  "description" : "In Python 3 through 3.9.0, the Lib/test/multibytecodec_support.py CJK codec tests call eval() on content retrieved via HTTP.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2020-27619"
}, {
  "versionRange" : "[2.2.2,2.2.2]",
  "severity" : 5.8,
  "cveName" : "CVE-2014-9365",
  "description" : "The HTTP clients in the (1) httplib, (2) urllib, (3) urllib2, and (4) xmlrpclib libraries in CPython (aka Python) 2.x before 2.7.9 and 3.x before 3.4.3, when accessing an HTTPS URL, do not (a) check the certificate against a trust store or verify that the server hostname matches a domain name in the subject's (b) Common Name or (c) subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-9365"
}, {
  "versionRange" : "[3.3.1,3.3.1]",
  "severity" : 6.5,
  "cveName" : "CVE-2016-0772",
  "description" : "The smtplib library in CPython (aka Python) before 2.7.12, 3.x before 3.4.5, and 3.5.x before 3.5.2 does not return an error when StartTLS fails, which might allow man-in-the-middle attackers to bypass the TLS protections by leveraging a network position between the client and the registry to block the StartTLS command, aka a \"StartTLS stripping attack.\"",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-0772"
}, {
  "versionRange" : "[3.0.1,3.0.1]",
  "severity" : 7.5,
  "cveName" : "CVE-2014-1912",
  "description" : "Buffer overflow in the socket.recvfrom_into function in Modules/socketmodule.c in Python 2.5 before 2.7.7, 3.x before 3.3.4, and 3.4.x before 3.4rc1 allows remote attackers to execute arbitrary code via a crafted string.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-1912"
}, {
  "versionRange" : "[3.6.0,3.6.12)",
  "severity" : 7.5,
  "cveName" : "CVE-2019-20907",
  "description" : "In Lib/tarfile.py in Python through 3.8.3, an attacker is able to craft a TAR archive leading to an infinite loop when opened by tarfile.open, because _proc_pax lacks header validation.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2019-20907"
}, {
  "versionRange" : "[2.3.7,2.3.7]",
  "severity" : 5.0,
  "cveName" : "CVE-2012-0845",
  "description" : "SimpleXMLRPCServer.py in SimpleXMLRPCServer in Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 allows remote attackers to cause a denial of service (infinite loop and CPU consumption) via an XML-RPC POST request that contains a smaller amount of data than specified by the Content-Length header.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-0845"
}, {
  "versionRange" : "[2.7.0,2.7.15]",
  "severity" : 7.5,
  "cveName" : "CVE-2018-14647",
  "description" : "Python's elementtree C accelerator failed to initialise Expat's hash salt during initialization. This could make it easy to conduct denial of service attacks against Expat by constructing an XML document that would cause pathological hash collisions in Expat's internal data structures, consuming large amounts CPU and RAM. The vulnerability exists in Python versions 3.7.0, 3.6.0 through 3.6.6, 3.5.0 through 3.5.6, 3.4.0 through 3.4.9, 2.7.0 through 2.7.15.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2018-14647"
}, {
  "versionRange" : "[2.7.1,2.7.1]",
  "severity" : 4.3,
  "cveName" : "CVE-2013-4238",
  "description" : "The ssl.match_hostname function in the SSL module in Python 2.6 through 3.4 does not properly handle a '\\0' character in a domain name in the Subject Alternative Name field of an X.509 certificate, which allows man-in-the-middle attackers to spoof arbitrary SSL servers via a crafted certificate issued by a legitimate Certification Authority, a related issue to CVE-2009-2408.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-4238"
}, {
  "versionRange" : "[3.8.0,3.8.13)",
  "severity" : 6.5,
  "cveName" : "CVE-2016-3189",
  "description" : "Use-after-free vulnerability in bzip2recover in bzip2 1.0.6 allows remote attackers to cause a denial of service (crash) via a crafted bzip2 file, related to block ends set to before the start of the block.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-3189"
}, {
  "versionRange" : "[3.0,3.1.2)",
  "severity" : 5.0,
  "cveName" : "CVE-2010-3492",
  "description" : "The asyncore module in Python before 3.2 does not properly handle unsuccessful calls to the accept function, and does not have accompanying documentation describing how daemon applications should handle unsuccessful calls to the accept function, which makes it easier for remote attackers to conduct denial of service attacks that terminate these applications via network connections.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2010-3492"
}, {
  "versionRange" : "[2.7.0,2.7.17)",
  "severity" : 6.1,
  "cveName" : "CVE-2019-16935",
  "description" : "The documentation XML-RPC server in Python through 2.7.16, 3.x through 3.6.9, and 3.7.x through 3.7.4 has XSS via the server_title field. This occurs in Lib/DocXMLRPCServer.py in Python 2.x, and in Lib/xmlrpc/server.py in Python 3.x. If set_server_title is called with untrusted input, arbitrary JavaScript can be delivered to clients that visit the http URL for this server.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2019-16935"
}, {
  "versionRange" : "[3.4,3.4]",
  "severity" : 7.5,
  "cveName" : "CVE-2014-1912",
  "description" : "Buffer overflow in the socket.recvfrom_into function in Modules/socketmodule.c in Python 2.5 before 2.7.7, 3.x before 3.3.4, and 3.4.x before 3.4rc1 allows remote attackers to execute arbitrary code via a crafted string.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-1912"
}, {
  "versionRange" : "[3.5.0,3.5.8)",
  "severity" : 7.5,
  "cveName" : "CVE-2019-15903",
  "description" : "In libexpat before 2.2.8, crafted XML input could fool the parser into changing from DTD parsing to document parsing too early; a consecutive call to XML_GetCurrentLineNumber (or XML_GetCurrentColumnNumber) then resulted in a heap-based buffer over-read.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2019-15903"
}, {
  "versionRange" : "[2.3.1,2.3.1]",
  "severity" : 5.0,
  "cveName" : "CVE-2012-1150",
  "description" : "Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 computes hash values without restricting the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-1150"
}, {
  "versionRange" : "[3.2.1,3.2.1]",
  "severity" : 5.8,
  "cveName" : "CVE-2014-9365",
  "description" : "The HTTP clients in the (1) httplib, (2) urllib, (3) urllib2, and (4) xmlrpclib libraries in CPython (aka Python) 2.x before 2.7.9 and 3.x before 3.4.3, when accessing an HTTPS URL, do not (a) check the certificate against a trust store or verify that the server hostname matches a domain name in the subject's (b) Common Name or (c) subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-9365"
}, {
  "versionRange" : "[3.0.1,3.0.1]",
  "severity" : 5.9,
  "cveName" : "CVE-2013-7440",
  "description" : "The ssl.match_hostname function in CPython (aka Python) before 2.7.9 and 3.x before 3.3.3 does not properly handle wildcards in hostnames, which might allow man-in-the-middle attackers to spoof servers via a crafted certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-7440"
}, {
  "versionRange" : "[3.8.0,3.8.11)",
  "severity" : 7.5,
  "cveName" : "CVE-2022-0391",
  "description" : "A flaw was found in Python, specifically within the urllib.parse module. This module helps break Uniform Resource Locator (URL) strings into components. The issue involves how the urlparse method does not sanitize input and allows characters like '\\r' and '\\n' in the URL path. This flaw allows an attacker to input a crafted URL, leading to injection attacks. This flaw affects Python versions prior to 3.10.0b1, 3.9.5, 3.8.11, 3.7.11 and 3.6.14.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2022-0391"
}, {
  "versionRange" : "[2.3.2,2.3.2]",
  "severity" : 2.6,
  "cveName" : "CVE-2011-4940",
  "description" : "The list_directory function in Lib/SimpleHTTPServer.py in SimpleHTTPServer in Python before 2.5.6c1, 2.6.x before 2.6.7 rc2, and 2.7.x before 2.7.2 does not place a charset parameter in the Content-Type HTTP header, which makes it easier for remote attackers to conduct cross-site scripting (XSS) attacks against Internet Explorer 7 via UTF-7 encoding.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-4940"
}, {
  "versionRange" : "[3.4.0,3.4.0]",
  "severity" : 6.1,
  "cveName" : "CVE-2016-5699",
  "description" : "CRLF injection vulnerability in the HTTPConnection.putheader function in urllib2 and urllib in CPython (aka Python) before 2.7.10 and 3.x before 3.4.4 allows remote attackers to inject arbitrary HTTP headers via CRLF sequences in a URL.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-5699"
}, {
  "versionRange" : "[2.0,2.7.16]",
  "severity" : 5.3,
  "cveName" : "CVE-2018-20852",
  "description" : "http.cookiejar.DefaultPolicy.domain_return_ok in Lib/http/cookiejar.py in Python before 3.7.3 does not correctly validate the domain: it can be tricked into sending existing cookies to the wrong server. An attacker may abuse this flaw by using a server with a hostname that has another valid hostname as a suffix (e.g., pythonicexample.com to steal cookies for example.com). When a program uses http.cookiejar.DefaultPolicy and tries to do an HTTP connection to an attacker-controlled server, existing cookies can be leaked to the attacker. This affects 2.x through 2.7.16, 3.x before 3.4.10, 3.5.x before 3.5.7, 3.6.x before 3.6.9, and 3.7.x before 3.7.3.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2018-20852"
}, {
  "versionRange" : "[3.0.1,3.0.1]",
  "severity" : 6.5,
  "cveName" : "CVE-2016-0772",
  "description" : "The smtplib library in CPython (aka Python) before 2.7.12, 3.x before 3.4.5, and 3.5.x before 3.5.2 does not return an error when StartTLS fails, which might allow man-in-the-middle attackers to bypass the TLS protections by leveraging a network position between the client and the registry to block the StartTLS command, aka a \"StartTLS stripping attack.\"",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-0772"
}, {
  "versionRange" : "[3.5.0,3.5.7)",
  "severity" : 5.3,
  "cveName" : "CVE-2018-20852",
  "description" : "http.cookiejar.DefaultPolicy.domain_return_ok in Lib/http/cookiejar.py in Python before 3.7.3 does not correctly validate the domain: it can be tricked into sending existing cookies to the wrong server. An attacker may abuse this flaw by using a server with a hostname that has another valid hostname as a suffix (e.g., pythonicexample.com to steal cookies for example.com). When a program uses http.cookiejar.DefaultPolicy and tries to do an HTTP connection to an attacker-controlled server, existing cookies can be leaked to the attacker. This affects 2.x through 2.7.16, 3.x before 3.4.10, 3.5.x before 3.5.7, 3.6.x before 3.6.9, and 3.7.x before 3.7.3.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2018-20852"
}, {
  "versionRange" : "[3.2.5,3.2.5]",
  "severity" : 6.5,
  "cveName" : "CVE-2016-0772",
  "description" : "The smtplib library in CPython (aka Python) before 2.7.12, 3.x before 3.4.5, and 3.5.x before 3.5.2 does not return an error when StartTLS fails, which might allow man-in-the-middle attackers to bypass the TLS protections by leveraging a network position between the client and the registry to block the StartTLS command, aka a \"StartTLS stripping attack.\"",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-0772"
}, {
  "versionRange" : "[3.7.0,3.7.6]",
  "severity" : 6.5,
  "cveName" : "CVE-2020-8492",
  "description" : "Python 2.7 through 2.7.17, 3.5 through 3.5.9, 3.6 through 3.6.10, 3.7 through 3.7.6, and 3.8 through 3.8.1 allows an HTTP server to conduct Regular Expression Denial of Service (ReDoS) attacks against a client because of urllib.request.AbstractBasicAuthHandler catastrophic backtracking.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2020-8492"
}, {
  "versionRange" : "[2.3.2,2.3.2]",
  "severity" : 5.0,
  "cveName" : "CVE-2012-1150",
  "description" : "Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 computes hash values without restricting the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-1150"
}, {
  "versionRange" : "[2.7.7,2.7.7]",
  "severity" : 5.8,
  "cveName" : "CVE-2014-9365",
  "description" : "The HTTP clients in the (1) httplib, (2) urllib, (3) urllib2, and (4) xmlrpclib libraries in CPython (aka Python) 2.x before 2.7.9 and 3.x before 3.4.3, when accessing an HTTPS URL, do not (a) check the certificate against a trust store or verify that the server hostname matches a domain name in the subject's (b) Common Name or (c) subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-9365"
}, {
  "versionRange" : "[2.4.3,2.4.3]",
  "severity" : 5.0,
  "cveName" : "CVE-2012-0845",
  "description" : "SimpleXMLRPCServer.py in SimpleXMLRPCServer in Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 allows remote attackers to cause a denial of service (infinite loop and CPU consumption) via an XML-RPC POST request that contains a smaller amount of data than specified by the Content-Length header.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-0845"
}, {
  "versionRange" : "[2.6.2,2.6.2]",
  "severity" : 4.3,
  "cveName" : "CVE-2013-4238",
  "description" : "The ssl.match_hostname function in the SSL module in Python 2.6 through 3.4 does not properly handle a '\\0' character in a domain name in the Subject Alternative Name field of an X.509 certificate, which allows man-in-the-middle attackers to spoof arbitrary SSL servers via a crafted certificate issued by a legitimate Certification Authority, a related issue to CVE-2009-2408.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-4238"
}, {
  "versionRange" : "[3.0.1,3.0.1]",
  "severity" : 6.4,
  "cveName" : "CVE-2011-1521",
  "description" : "The urllib and urllib2 modules in Python 2.x before 2.7.2 and 3.x before 3.2.1 process Location headers that specify redirection to file: URLs, which makes it easier for remote attackers to obtain sensitive information or cause a denial of service (resource consumption) via a crafted URL, as demonstrated by the file:///etc/passwd and file:///dev/zero URLs.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-1521"
}, {
  "versionRange" : "[3.0.1,3.0.1]",
  "severity" : 4.3,
  "cveName" : "CVE-2013-7040",
  "description" : "Python 2.7 before 3.4 only uses the last eight bits of the prefix to randomize hash values, which causes it to compute hash values without restricting the ability to trigger hash collisions predictably and makes it easier for context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2012-1150.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-7040"
}, {
  "versionRange" : "[2.0,2.7.17]",
  "severity" : 6.1,
  "cveName" : "CVE-2019-18348",
  "description" : "An issue was discovered in urllib2 in Python 2.x through 2.7.17 and urllib in Python 3.x through 3.8.0. CRLF injection is possible if the attacker controls a url parameter, as demonstrated by the first argument to urllib.request.urlopen with \\r\\n (specifically in the host component of a URL) followed by an HTTP header. This is similar to the CVE-2019-9740 query string issue and the CVE-2019-9947 path string issue. (This is not exploitable when glibc has CVE-2016-10739 fixed.). This is fixed in: v2.7.18, v2.7.18rc1; v3.5.10, v3.5.10rc1; v3.6.11, v3.6.11rc1, v3.6.12; v3.7.8, v3.7.8rc1, v3.7.9; v3.8.3, v3.8.3rc1, v3.8.4, v3.8.4rc1, v3.8.5, v3.8.6, v3.8.6rc1.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2019-18348"
}, {
  "versionRange" : "[3.8.0,3.8.15]",
  "severity" : 7.6,
  "cveName" : "CVE-2015-20107",
  "description" : "In Python (aka CPython) up to 3.10.8, the mailcap module does not add escape characters into commands discovered in the system mailcap file. This may allow attackers to inject shell commands into applications that call mailcap.findmatch with untrusted input (if they lack validation of user-provided filenames or arguments). The fix is also back-ported to 3.7, 3.8, 3.9",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2015-20107"
}, {
  "versionRange" : "[2.3.3,2.3.3]",
  "severity" : 5.0,
  "cveName" : "CVE-2012-1150",
  "description" : "Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 computes hash values without restricting the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-1150"
}, {
  "versionRange" : "[3.8.0,3.8.2)",
  "severity" : 7.5,
  "cveName" : "CVE-2022-48560",
  "description" : "A use-after-free exists in Python through 3.9 via heappushpop in heapq.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2022-48560"
}, {
  "versionRange" : "[3.12.0,3.12.0]",
  "severity" : 4.9,
  "cveName" : "CVE-2023-6507",
  "description" : "An issue was found in CPython 3.12.0 `subprocess` module on POSIX platforms. The issue was fixed in CPython 3.12.1 and does not affect other stable releases.\n\nWhen using the `extra_groups=` parameter with an empty list as a value (ie `extra_groups=[]`) the logic regressed to not call `setgroups(0, NULL)` before calling `exec()`, thus not dropping the original processes' groups before starting the new process. There is no issue when the parameter isn't used or when any value is used besides an empty list.\n\nThis issue only impacts CPython processes run with sufficient privilege to make the `setgroups` system call (typically `root`).\n\n",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2023-6507"
}, {
  "versionRange" : "[3.6.0,3.7.16)",
  "severity" : 9.8,
  "cveName" : "CVE-2022-37454",
  "description" : "The Keccak XKCP SHA-3 reference implementation before fdc6fef has an integer overflow and resultant buffer overflow that allows attackers to execute arbitrary code or eliminate expected cryptographic properties. This occurs in the sponge function interface.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2022-37454"
}, {
  "versionRange" : "[3.6.0,3.6.2)",
  "severity" : 9.8,
  "cveName" : "CVE-2016-9063",
  "description" : "An integer overflow during the parsing of XML using the Expat library. This vulnerability affects Firefox < 50.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-9063"
}, {
  "versionRange" : "[3.9.0,3.9.5)",
  "severity" : 6.5,
  "cveName" : "CVE-2021-3733",
  "description" : "There's a flaw in urllib's AbstractBasicAuthHandler class. An attacker who controls a malicious HTTP server that an HTTP client (such as web browser) connects to, could trigger a Regular Expression Denial of Service (ReDOS) during an authentication request with a specially crafted payload that is sent by the server to the client. The greatest threat that this flaw poses is to application availability.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2021-3733"
}, {
  "versionRange" : "(,3.5.0]",
  "severity" : 7.2,
  "cveName" : "CVE-2015-5652",
  "description" : "Untrusted search path vulnerability in python.exe in Python through 3.5.0 on Windows allows local users to gain privileges via a Trojan horse readline.pyd file in the current working directory.  NOTE: the vendor says \"It was determined that this is a longtime behavior of Python that cannot really be altered at this point.\"",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2015-5652"
}, {
  "versionRange" : "[2.0.1,2.0.1]",
  "severity" : 5.8,
  "cveName" : "CVE-2014-9365",
  "description" : "The HTTP clients in the (1) httplib, (2) urllib, (3) urllib2, and (4) xmlrpclib libraries in CPython (aka Python) 2.x before 2.7.9 and 3.x before 3.4.3, when accessing an HTTPS URL, do not (a) check the certificate against a trust store or verify that the server hostname matches a domain name in the subject's (b) Common Name or (c) subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-9365"
}, {
  "versionRange" : "(,2.4.2]",
  "severity" : 3.7,
  "cveName" : "CVE-2006-1542",
  "description" : "Stack-based buffer overflow in Python 2.4.2 and earlier, running on Linux 2.6.12.5 under gcc 4.0.3 with libc 2.3.5, allows local users to cause a \"stack overflow,\" and possibly gain privileges, by running a script from a current working directory that has a long name, related to the realpath function.  NOTE: this might not be a vulnerability. However, the fact that it appears in a programming language interpreter could mean that some applications are affected, although attack scenarios might be limited because the attacker might already need to cross privilege boundaries to cause an exploitable program to be placed in a directory with a long name; or, depending on the method that Python uses to determine the current working directory, setuid applications might be affected.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2006-1542"
}, {
  "versionRange" : "[3.1.5,3.1.5]",
  "severity" : 4.3,
  "cveName" : "CVE-2013-4238",
  "description" : "The ssl.match_hostname function in the SSL module in Python 2.6 through 3.4 does not properly handle a '\\0' character in a domain name in the Subject Alternative Name field of an X.509 certificate, which allows man-in-the-middle attackers to spoof arbitrary SSL servers via a crafted certificate issued by a legitimate Certification Authority, a related issue to CVE-2009-2408.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-4238"
}, {
  "versionRange" : "[3.3,3.3]",
  "severity" : 5.8,
  "cveName" : "CVE-2014-9365",
  "description" : "The HTTP clients in the (1) httplib, (2) urllib, (3) urllib2, and (4) xmlrpclib libraries in CPython (aka Python) 2.x before 2.7.9 and 3.x before 3.4.3, when accessing an HTTPS URL, do not (a) check the certificate against a trust store or verify that the server hostname matches a domain name in the subject's (b) Common Name or (c) subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2014-9365"
}, {
  "versionRange" : "[3.1.2,3.1.2]",
  "severity" : 5.9,
  "cveName" : "CVE-2013-7440",
  "description" : "The ssl.match_hostname function in CPython (aka Python) before 2.7.9 and 3.x before 3.3.3 does not properly handle wildcards in hostnames, which might allow man-in-the-middle attackers to spoof servers via a crafted certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-7440"
}, {
  "versionRange" : "[3.2.3,3.2.3]",
  "severity" : 5.9,
  "cveName" : "CVE-2013-7440",
  "description" : "The ssl.match_hostname function in CPython (aka Python) before 2.7.9 and 3.x before 3.3.3 does not properly handle wildcards in hostnames, which might allow man-in-the-middle attackers to spoof servers via a crafted certificate.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2013-7440"
}, {
  "versionRange" : "[3.1.3,3.1.3]",
  "severity" : 9.8,
  "cveName" : "CVE-2016-5636",
  "description" : "Integer overflow in the get_data function in zipimport.c in CPython (aka Python) before 2.7.12, 3.x before 3.4.5, and 3.5.x before 3.5.2 allows remote attackers to have unspecified impact via a negative data size value, which triggers a heap-based buffer overflow.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-5636"
}, {
  "versionRange" : "[3.7.0,3.7.3)",
  "severity" : 5.3,
  "cveName" : "CVE-2018-20852",
  "description" : "http.cookiejar.DefaultPolicy.domain_return_ok in Lib/http/cookiejar.py in Python before 3.7.3 does not correctly validate the domain: it can be tricked into sending existing cookies to the wrong server. An attacker may abuse this flaw by using a server with a hostname that has another valid hostname as a suffix (e.g., pythonicexample.com to steal cookies for example.com). When a program uses http.cookiejar.DefaultPolicy and tries to do an HTTP connection to an attacker-controlled server, existing cookies can be leaked to the attacker. This affects 2.x through 2.7.16, 3.x before 3.4.10, 3.5.x before 3.5.7, 3.6.x before 3.6.9, and 3.7.x before 3.7.3.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2018-20852"
}, {
  "versionRange" : "[2.6.8,2.6.8]",
  "severity" : 1.9,
  "cveName" : "CVE-2011-4944",
  "description" : "Python 2.6 through 3.2 creates ~/.pypirc with world-readable permissions before changing them after data has been written, which introduces a race condition that allows local users to obtain a username and password by reading this file.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-4944"
}, {
  "versionRange" : "[2.3.5,2.3.5]",
  "severity" : 2.6,
  "cveName" : "CVE-2011-4940",
  "description" : "The list_directory function in Lib/SimpleHTTPServer.py in SimpleHTTPServer in Python before 2.5.6c1, 2.6.x before 2.6.7 rc2, and 2.7.x before 2.7.2 does not place a charset parameter in the Content-Type HTTP header, which makes it easier for remote attackers to conduct cross-site scripting (XSS) attacks against Internet Explorer 7 via UTF-7 encoding.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2011-4940"
}, {
  "versionRange" : "[3.8.0,3.8.8)",
  "severity" : 5.7,
  "cveName" : "CVE-2021-3426",
  "description" : "There's a flaw in Python 3's pydoc. A local or adjacent attacker who discovers or is able to convince another local or adjacent user to start a pydoc server could access the server and use it to disclose sensitive information belonging to the other user that they would not normally be able to access. The highest risk of this flaw is to data confidentiality. This flaw affects Python versions before 3.8.9, Python versions before 3.9.3 and Python versions before 3.10.0a7.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2021-3426"
}, {
  "versionRange" : "[3.2.5,3.2.5]",
  "severity" : 6.1,
  "cveName" : "CVE-2016-5699",
  "description" : "CRLF injection vulnerability in the HTTPConnection.putheader function in urllib2 and urllib in CPython (aka Python) before 2.7.10 and 3.x before 3.4.4 allows remote attackers to inject arbitrary HTTP headers via CRLF sequences in a URL.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-5699"
}, {
  "versionRange" : "[3.8.0,3.8.11)",
  "severity" : 7.5,
  "cveName" : "CVE-2021-3737",
  "description" : "A flaw was found in python. An improperly handled HTTP response in the HTTP client code of python may allow a remote attacker, who controls the HTTP server, to make the client script enter an infinite loop, consuming CPU time. The highest threat from this vulnerability is to system availability.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2021-3737"
}, {
  "versionRange" : "[2.3.4,2.3.4]",
  "severity" : 5.0,
  "cveName" : "CVE-2012-1150",
  "description" : "Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 computes hash values without restricting the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2012-1150"
}, {
  "versionRange" : "(,2.3.5)",
  "severity" : 7.5,
  "cveName" : "CVE-2005-0089",
  "description" : "The SimpleXMLRPCServer library module in Python 2.2, 2.3 before 2.3.5, and 2.4, when used by XML-RPC servers that use the register_instance method to register an object without a _dispatch method, allows remote attackers to read or modify globals of the associated module, and possibly execute arbitrary code, via dotted attributes.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2005-0089"
}, {
  "versionRange" : "[3.3.4,3.3.4]",
  "severity" : 9.8,
  "cveName" : "CVE-2016-5636",
  "description" : "Integer overflow in the get_data function in zipimport.c in CPython (aka Python) before 2.7.12, 3.x before 3.4.5, and 3.5.x before 3.5.2 allows remote attackers to have unspecified impact via a negative data size value, which triggers a heap-based buffer overflow.",
  "nistUrl" : "https://nvd.nist.gov/vuln/detail/CVE-2016-5636"
} ]
